<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sumulige</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.sumulige.com/"/>
  <updated>2020-03-16T16:24:58.645Z</updated>
  <id>http://www.sumulige.com/</id>
  
  <author>
    <name>sumulige</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>优秀的博客推荐</title>
    <link href="http://www.sumulige.com/2020/03/16/%E4%BC%98%E7%A7%80%E5%8D%9A%E5%AE%A2%E6%8E%A8%E8%8D%90%EF%BC%8C%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E3%80%82/"/>
    <id>http://www.sumulige.com/2020/03/16/%E4%BC%98%E7%A7%80%E5%8D%9A%E5%AE%A2%E6%8E%A8%E8%8D%90%EF%BC%8C%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E3%80%82/</id>
    <published>2020-03-16T04:22:22.000Z</published>
    <updated>2020-03-16T16:24:58.645Z</updated>
    
    <content type="html"><![CDATA[<p>这份名单我会花大量时间去整理，希望大家评论里留言。</p><h1 id="优秀的博客推荐"><a href="#优秀的博客推荐" class="headerlink" title="优秀的博客推荐"></a>优秀的博客推荐</h1><blockquote><p>写在前面，本人将会持续更新。排名不分先后。</p></blockquote><h2 id="1、http-lucida-me"><a href="#1、http-lucida-me" class="headerlink" title="1、http://lucida.me/"></a>1、<a href="http://lucida.me/" target="_blank" rel="noopener">http://lucida.me/</a></h2><p> 摄影分享，技术分享：<br> <img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/17/1d61477e2a5c4880ac9bef2cc8c9f4fb.png" alt="1D61477E-2A5C-4880-AC9B-EF2CC8C9F4FB"></p><h2 id="2、https-blog-codingnow-com"><a href="#2、https-blog-codingnow-com" class="headerlink" title="2、https://blog.codingnow.com/"></a>2、<a href="https://blog.codingnow.com/" target="_blank" rel="noopener">https://blog.codingnow.com/</a></h2><p>开发游戏的大神<br><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/17/ff2cf2c6eada48e08100ba5f6566eeec.png" alt="FF2CF2C6-EADA-48E0-8100-BA5F6566EEE"></p><h2 id="3、https-www-yangzhiping-com"><a href="#3、https-www-yangzhiping-com" class="headerlink" title="3、https://www.yangzhiping.com/"></a>3、<a href="https://www.yangzhiping.com/" target="_blank" rel="noopener">https://www.yangzhiping.com/</a></h2><p>大名鼎鼎的阳志平读书博客<br><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/17/a17799a023204351be1572913170349f.png" alt="A17799A0-2320-4351-BE15-72913170349F"></p><h2 id="4、http-mindhacks-cn"><a href="#4、http-mindhacks-cn" class="headerlink" title="4、http://mindhacks.cn/"></a>4、<a href="http://mindhacks.cn/" target="_blank" rel="noopener">http://mindhacks.cn/</a></h2><p>心智程序员大神<br><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/17/4565bf4e4e1e4b7c911490f2816ac75a.png" alt="4565BF4E-4E1E-4B7C-9114-90F2816AC75A"></p><h2 id="5、https-onevcat-com"><a href="#5、https-onevcat-com" class="headerlink" title="5、https://onevcat.com/"></a>5、<a href="https://onevcat.com/" target="_blank" rel="noopener">https://onevcat.com/</a></h2><p>iOS、swift大神，据说博主是 Github iOS 类 follower 最多的人<br><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/17/1a1bd47cc8834cde9ff3021c64a1023e.png" alt="1A1BD47C-C883-4CDE-9FF3-021C64A1023E"></p><h2 id="6、http-zengrong-net"><a href="#6、http-zengrong-net" class="headerlink" title="6、http://zengrong.net/"></a>6、<a href="http://zengrong.net/" target="_blank" rel="noopener">http://zengrong.net/</a></h2><p>以为游戏开发妹子，文章写得不错<br><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/17/a6530c0964904216bf9acf04e3a6701a.png" alt="A6530C09-6490-4216-BF9A-CF04E3A6701A"></p><h2 id="7、-https-wuzhiwei-net"><a href="#7、-https-wuzhiwei-net" class="headerlink" title="7、 https://wuzhiwei.net/"></a>7、 <a href="https://wuzhiwei.net/" target="_blank" rel="noopener">https://wuzhiwei.net/</a></h2><p>专注于读书、游戏开发、算法与问题解决<br><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/17/75b3e2ef6ae84617a7290b487a0cd60c.png" alt="75B3E2EF-6AE8-4617-A729-0B487A0CD60"></p><h2 id="8、https-coolshell-cn"><a href="#8、https-coolshell-cn" class="headerlink" title="8、https://coolshell.cn/"></a>8、<a href="https://coolshell.cn/" target="_blank" rel="noopener">https://coolshell.cn/</a></h2><p>热衷于技术编程的以为博主<br><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/17/a2a95e1df5974d37b48969c629e8a45f.png" alt="A2A95E1D-F597-4D37-B489-69C629E8A45F"></p><h2 id="9、https-v2ex-com"><a href="#9、https-v2ex-com" class="headerlink" title="9、https://v2ex.com/"></a>9、<a href="https://v2ex.com/" target="_blank" rel="noopener">https://v2ex.com/</a></h2><p>国内一流的妇女安全协会<br><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/17/ca71d341802e4fec89e18d87d4057c3a.png" alt="CA71D341-802E-4FEC-89E1-8D87D4057C3A"></p><h2 id="10、http-www-sightcorner-com"><a href="#10、http-www-sightcorner-com" class="headerlink" title="10、http://www.sightcorner.com/"></a>10、<a href="http://www.sightcorner.com/" target="_blank" rel="noopener">http://www.sightcorner.com/</a></h2><p>网页设计旅行<br><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/17/358ae15bac894243b1e13b4da388ea84.png" alt="358AE15B-AC89-4243-B1E1-3B4DA388EA84"></p><h2 id="11、http-shouxieke-net"><a href="#11、http-shouxieke-net" class="headerlink" title="11、http://shouxieke.net/"></a>11、<a href="http://shouxieke.net/" target="_blank" rel="noopener">http://shouxieke.net/</a></h2><p>一个真正在网页上写字的播客<br><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/17/c10fced6bd0442afa32884f70756982e.png" alt="C10FCED6-BD04-42AF-A328-84F70756982E"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这份名单我会花大量时间去整理，希望大家评论里留言。&lt;/p&gt;
&lt;h1 id=&quot;优秀的博客推荐&quot;&gt;&lt;a href=&quot;#优秀的博客推荐&quot; class=&quot;headerlink&quot; title=&quot;优秀的博客推荐&quot;&gt;&lt;/a&gt;优秀的博客推荐&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;写在前面
      
    
    </summary>
    
    
    
      <category term="日常推荐" scheme="http://www.sumulige.com/tags/%E6%97%A5%E5%B8%B8%E6%8E%A8%E8%8D%90/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记-IO（六）</title>
    <link href="http://www.sumulige.com/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-IO%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>http://www.sumulige.com/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-IO%EF%BC%88%E5%85%AD%EF%BC%89/</id>
    <published>2020-03-05T18:12:41.000Z</published>
    <updated>2020-03-05T19:00:33.219Z</updated>
    
    <content type="html"><![CDATA[<p>标签：常见 io 流总结</p><hr><h2 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h2><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834277170182.jpg" alt=""></p><h2 id="JAVA中流方向的分类："><a href="#JAVA中流方向的分类：" class="headerlink" title="JAVA中流方向的分类："></a>JAVA中流方向的分类：</h2><ul><li><p>输入流：数据流向是数据源到程序(以InputStream、Reader结尾的流)。</p></li><li><p>输出流：数据流向是程序到目的地(以OutPutStream、Writer结尾的流)。</p></li></ul><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834277260566.jpg" alt=""></p><h2 id="按处理数据的单元分类："><a href="#按处理数据的单元分类：" class="headerlink" title="按处理数据的单元分类："></a>按处理数据的单元分类：</h2><ul><li><p>字节流：以字节为单位获取数据，命名上以Stream结尾的流一般是字节流，如FileInputStream、FileOutputStream。</p></li><li><p>字符流：以字符为单位获取数据，命名上以Reader/Writer结尾的流一般是字符流，如FileReader、FileWriter。</p></li></ul><h2 id="按处理对象不同分类"><a href="#按处理对象不同分类" class="headerlink" title="按处理对象不同分类"></a>按处理对象不同分类</h2><ul><li><p>节点流：可以直接从数据源或目的地读写数据，如FileInputStream、FileReader、DataInputStream等。</p></li><li><p>处理流：不直接连接到数据源或目的地，是”处理流的流”。通过对其他流的处理提高程序的性能，如BufferedInputStream、BufferedReader等。处理流也叫包装流。</p></li><li><p><strong>节点流处于IO操作的第一线，所有操作必须通过它们进行;处理流可以对节点流进行包装，提高性能或提高程序的灵活性。</strong></p></li></ul><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834277359782.jpg" alt=""></p><h2 id="显然是对文件做输入和输出操作的。我们下面简单做个总结："><a href="#显然是对文件做输入和输出操作的。我们下面简单做个总结：" class="headerlink" title="显然是对文件做输入和输出操作的。我们下面简单做个总结："></a>显然是对文件做输入和输出操作的。我们下面简单做个总结：</h2><ol><li>InputStream/OutputStream</li></ol><p>字节流的抽象类。</p><ol start="2"><li>Reader/Writer</li></ol><p>字符流的抽象类。</p><ol start="3"><li>FileInputStream/FileOutputStream</li></ol><p>节点流：以字节为单位直接操作“文件”。</p><ol start="4"><li>ByteArrayInputStream/ByteArrayOutputStream</li></ol><p>节点流：以字节为单位直接操作“字节数组对象”。</p><ol start="5"><li>ObjectInputStream/ObjectOutputStream</li></ol><p>处理流：以字节为单位直接操作“对象”。</p><ol start="6"><li>DataInputStream/DataOutputStream</li></ol><p>处理流：以字节为单位直接操作“基本数据类型与字符串类型”。</p><ol start="7"><li>FileReader/FileWriter</li></ol><p>节点流：以字符为单位直接操作“文本文件”(注意：只能读写文本文件)。</p><ol start="8"><li>BufferedReader/BufferedWriter</li></ol><p>处理流：将Reader/Writer对象进行包装，增加缓存功能，提高读写效率。</p><ol start="9"><li>BufferedInputStream/BufferedOutputStream</li></ol><p>处理流：将InputStream/OutputStream对象进行包装，增加缓存功能，提高 读写效率。</p><ol start="10"><li>InputStreamReader/OutputStreamWriter</li></ol><p>处理流：将字节流对象转化成字符流对象。</p><ol start="11"><li>PrintStream</li></ol><p>处理流：将OutputStream进行包装，可以方便地输出字符，更加灵活。</p><h2 id="java-IO体系架构图"><a href="#java-IO体系架构图" class="headerlink" title="java IO体系架构图"></a>java IO体系架构图</h2><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834278007199.jpg" alt=""></p><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834278462342.jpg" alt=""></p><h2 id="inputStream"><a href="#inputStream" class="headerlink" title="inputStream"></a>inputStream</h2><p>继承自InputSteam的流都是用于向程序中输入数据，且数据的单位为字节(8 bit)。</p><blockquote><p>常用方法：int read()：读取一个字节的数据，并将字节的值作为int类型返回(0-255之间的一个值)。如果未读出字节则返回-1(返回值为-1表示读取结束)。</p></blockquote><blockquote><p>小贴士：void close()：关闭输入流对象，释放相关系统资源。</p></blockquote><h2 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h2><ul><li><p>Reader用于读取的字符流抽象类，数据单位为字符。</p></li><li><p>int read(): 读取一个字符的数据，并将字符的值作为int类型返回(0-65535之间的一个值，即Unicode值)。如果未读出字符则返回-1(返回值为-1表示读取结束)。</p></li><li><p>void close() ： 关闭流对象，释放相关系统资源。</p></li></ul><h2 id="将字符串-字节数组的内容写入到文件中"><a href="#将字符串-字节数组的内容写入到文件中" class="headerlink" title="将字符串/字节数组的内容写入到文件中"></a>将字符串/字节数组的内容写入到文件中</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOutputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileOutputStream fops = <span class="keyword">null</span> ;</span><br><span class="line">        String s = <span class="string">"将字符串/字节数组的内容写入到文件中"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// true表示内容会追加到文件末尾；false表示重写整个文件内容。</span></span><br><span class="line">            fops = <span class="keyword">new</span> FileOutputStream(<span class="string">"char.txt"</span>,<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//该方法是直接将一个字节数组写入文件中; 而write(int n)是写入一个字节</span></span><br><span class="line">            fops.write(s.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fops != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fops.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用到一个write方法：void write(byte[ ] b)，该方法不再一个字节一个字节地写入，而是直接写入一个字节数组;另外其还有一个重载的方法：void write(byte[ ] b, int off, int length)，这个方法也是写入一个字节数组，但是我们程序员可以指定从字节数组的哪个位置开始写入，写入的长度是多少。</strong></p><h2 id="利用文件流实现文件的复制"><a href="#利用文件流实现文件的复制" class="headerlink" title="利用文件流实现文件的复制"></a>利用文件流实现文件的复制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈一句话功能简述〉&lt;br&gt; </span></span><br><span class="line"><span class="comment"> * 〈利用文件流实现文件的复制〉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> willem</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-05-15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFileCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        copyFile(<span class="string">"char.txt"</span>,<span class="string">"char1.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(String src,String dec)</span></span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//为了提高效率设置缓存数组（读取的字节数据暂时会存在该字节数组中）</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> temp = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(dec);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//边读边写</span></span><br><span class="line">            <span class="comment">//temp指的是本次读取的真实长度，-1的时候表示读取完成</span></span><br><span class="line">            <span class="keyword">while</span> ((temp = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">/*将缓存数组中的数据写入文件中，注意：写入的是读取的真实长度；</span></span><br><span class="line"><span class="comment">                 *如果使用fos.write(buffer)方法，那么写入的长度将会是1024，即缓存</span></span><br><span class="line"><span class="comment">                 *数组的长度*/</span></span><br><span class="line">                fos.write(buffer,<span class="number">0</span>,temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fis != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在使用文件字节流时，我们需要注意以下两点：</p><ol><li><p>为了减少对硬盘的读写次数，提高效率，通常设置缓存数组。相应地，读取时使用的方法为：read(byte[] b);写入时的方法为：write(byte[ ] b, int off, int length)。</p></li><li><p>程序中如果遇到多个流，每个流都要单独关闭，防止其中一个流出现异常后导致其他流无法关闭的情况。</p></li></ol></li></ul><h2 id="利用文件字符流复制"><a href="#利用文件字符流复制" class="headerlink" title="利用文件字符流复制"></a>利用文件字符流复制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈一句话功能简述〉&lt;br&gt; </span></span><br><span class="line"><span class="comment"> * 〈使用FileReader与FileWriter实现文本文件的复制〉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> willem</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-05-15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFileCopy2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        copyFile2(<span class="string">"char.txt"</span>,<span class="string">"char3.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile2</span><span class="params">(String src ,String dec)</span></span>&#123;</span><br><span class="line">        FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">        FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fr = <span class="keyword">new</span> FileReader(src);</span><br><span class="line">            fw = <span class="keyword">new</span> FileWriter(dec);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//为了提供效率引入缓存数组</span></span><br><span class="line">            <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span>((len = fr.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                fw.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fr != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fr.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fw != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意</p><ol><li><p>在关闭流时，应该先关闭最外层的包装流，即“后开的先关闭”。</p></li><li><p>缓存区的大小默认是8192字节，也可以使用其它的构造方法自己指定大小。</p></li></ol><h2 id="使用BufferReader和BufferWriter进行文本复制"><a href="#使用BufferReader和BufferWriter进行文本复制" class="headerlink" title="使用BufferReader和BufferWriter进行文本复制"></a>使用BufferReader和BufferWriter进行文本复制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copyright (C), 2015-2019, 中信银行有限公司</span></span><br><span class="line"><span class="comment"> * FileName: TestBufferedFileCopy2</span></span><br><span class="line"><span class="comment"> * Author:   willem</span></span><br><span class="line"><span class="comment"> * Date:     2019-05-16 08:48</span></span><br><span class="line"><span class="comment"> * Description: 使用BufferReader和BufferWriter</span></span><br><span class="line"><span class="comment"> * History:</span></span><br><span class="line"><span class="comment"> * &lt;author&gt;          &lt;time&gt;          &lt;version&gt;          &lt;desc&gt;</span></span><br><span class="line"><span class="comment"> * 作者姓名           修改时间           版本号              描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.citic.java.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈一句话功能简述〉&lt;br&gt; </span></span><br><span class="line"><span class="comment"> * 〈使用BufferReader和BufferWriter进行文件复制〉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> willem</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-05-16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBufferedFileCopy2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">        FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">        BufferedWriter bw = <span class="keyword">null</span>;</span><br><span class="line">        String tempString = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fr = <span class="keyword">new</span> FileReader(<span class="string">"char.txt"</span>);</span><br><span class="line">            fw = <span class="keyword">new</span> FileWriter(<span class="string">"char4.txt"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用缓存字符流进行包装</span></span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">            bw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line">            <span class="comment">//bufferreader提供了更好的方法readline（)方法</span></span><br><span class="line">            <span class="keyword">while</span>((tempString = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                bw.write(tempString);</span><br><span class="line"></span><br><span class="line">                bw.newLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(bw != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bw.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(br != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fw != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fr != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fr.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><ol><li><p>readLine()方法是BufferedReader特有的方法，可以对文本文件进行更加方便的读取操作。</p></li><li><p>写入一行后要记得使用newLine()方法换行。</p></li></ol><h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h2><ul><li><p>我们前边学到的数据流只能实现对基本数据类型和字符串类型的读写，并不能读取对象(字符串除外)，如果要对某个对象进行读写操作，我们需要学习一对新的处理流：ObjectInputStream/ObjectOutputStream。</p></li><li><p>ObjectInputStream/ObjectOutputStream是以“对象”为数据源，但是必须将传输的对象进行序列化与反序列化操作。</p></li></ul><p><strong>注意：</strong></p><ol><li><p>对象流不仅可以读写对象，还可以读写基本数据类型。</p></li><li><p>使用对象流读写对象时，该对象必须序列化与反序列化。</p></li><li><p>系统提供的类(如Date等)已经实现了序列化接口，自定义类必须手动实现序列化接口。</p></li></ol><h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><ul><li><p>InputStreamReader/OutputStreamWriter用来实现将字节流转化成字符流。比如，如下场景：</p></li><li><p>System.in是字节流对象，代表键盘的输入，如果我们想按行接收用户的输入时，就必须用到缓冲字符流BufferedReader特有的方法readLine()，但是经过观察会发现在创建BufferedReader的构造方法的参数必须是一个Reader对象，这时候我们的转换流InputStreamReader就派上用场了。</p></li><li><p>而System.out也是字节流对象，代表输出到显示器，按行读取用户的输入后，并且要将读取的一行字符串直接显示到控制台，就需要用到字符流的write(String str)方法，所以我们要使用OutputStreamWriter将字节流转化为字符流。</p></li></ul><h2 id="序列化和反序列化是什么"><a href="#序列化和反序列化是什么" class="headerlink" title="序列化和反序列化是什么"></a>序列化和反序列化是什么</h2><ul><li><p>当两个进程远程通信时，彼此可以发送各种类型的数据。 无论是何种类型的数据，都会以二进制序列的形式在网络上传送。比如，我们可以通过http协议发送字符串信息;我们也可以在网络上直接发送Java对象。发送方需要把这个Java对象转换为字节序列，才能在网络上传送;接收方则需要把字节序列再恢复为Java对象才能正常读取。</p></li><li><p>把Java对象转换为字节序列的过程称为对象的序列化。把字节序列恢复为Java对象的过程称为对象的反序列化。</p></li></ul><p>对象序列化的作用有如下两种：</p><ul><li><p>持久化： 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中，比如：休眠的实现。以后服务器session管理，hibernate将对象持久化实现。</p></li><li><p>网络通信：在网络上传送对象的字节序列。比如：服务器之间的数据通信、对象传递。</p></li></ul><h2 id="序列化涉及的类和接口"><a href="#序列化涉及的类和接口" class="headerlink" title="序列化涉及的类和接口"></a>序列化涉及的类和接口</h2><ul><li><p>ObjectOutputStream代表对象输出流，它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。</p></li><li><p>ObjectInputStream代表对象输入流，它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。</p></li><li><p>只有实现了Serializable接口的类的对象才能被序列化。 Serializable接口是一个空接口，只起到标记作用。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copyright (C), 2015-2019, 中信银行有限公司</span></span><br><span class="line"><span class="comment"> * FileName: TestSerializable</span></span><br><span class="line"><span class="comment"> * Author:   willem</span></span><br><span class="line"><span class="comment"> * Date:     2019-05-16 11:00</span></span><br><span class="line"><span class="comment"> * Description: 将Person类的实例进行序列化和反序列化</span></span><br><span class="line"><span class="comment"> * History:</span></span><br><span class="line"><span class="comment"> * &lt;author&gt;          &lt;time&gt;          &lt;version&gt;          &lt;desc&gt;</span></span><br><span class="line"><span class="comment"> * 作者姓名           修改时间           版本号              描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.citic.java.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈一句话功能简述〉&lt;br&gt; </span></span><br><span class="line"><span class="comment"> * 〈将Person类的实例进行序列化和反序列化〉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> willem</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-05-16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1l</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> id,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> id == person.id &amp;&amp;</span><br><span class="line">                age == person.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, id, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", id="</span> + id +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSerializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过ObjectOutStream将Person对象数据写入到文件中，序列化。</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"哈皮"</span>,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//序列化</span></span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"heool.txt"</span>);</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">            oos.writeObject(person);</span><br><span class="line">            oos.flush();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//序列化</span></span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">"heool.txt"</span>);</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">            Person p = (Person) ois.readObject();</span><br><span class="line">            System.out.println(p);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:</p><ol><li><p>static属性不参与序列化。</p></li><li><p>对象中的某些属性如果不想被序列化，不能使用static，而是使用transient修饰。</p></li><li><p>为了防止读和写的序列化ID不一致，一般指定一个固定的序列化ID。</p></li></ol><h2 id="IO流体系中的装饰器模式"><a href="#IO流体系中的装饰器模式" class="headerlink" title="IO流体系中的装饰器模式"></a>IO流体系中的装饰器模式</h2><ul><li>IO流体系中大量使用了装饰器模式，让流具有更强的功能、更强的灵活性。比如：</li><li>显然BufferedInputStream装饰了原有的FileInputStream，让普通的FileInputStream也具备了缓存功能，提高了效率。 大家举一反三，可以翻看本章代码，看看还有哪些地方使用了装饰器模式。</li></ul><h2 id="Apache-IOUtils和FileUtils的使用"><a href="#Apache-IOUtils和FileUtils的使用" class="headerlink" title="Apache IOUtils和FileUtils的使用"></a>Apache IOUtils和FileUtils的使用</h2><p>FieUtils类中常常方法的介绍</p><ul><li><p>打开文件实用程序的API文档，我们抽出一些工作中比较常用的方法，进行总结和讲解总结如下：</p></li><li><p>cleanDirectory：清空目录，但不删除目录。</p></li><li><p>contentEquals：比较两个文件的内容是否相同。</p></li><li><p>copyDirectory：将一个目录内容拷贝到另一个目录。可以通过FileFilter过滤需要拷贝的文件。</p></li><li><p>CopyFile：将一个文件拷贝到一个新的地址。</p></li><li><p>copyFileToDirectory：将一个文件拷贝到某个目录下。</p></li><li><p>copyInputStreamToFile：将一个输入流中的内容拷贝到某个文件。</p></li><li><p>deleteDirectory：删除目录。</p></li><li><p>deleteQuietly：删除文件。</p></li><li><p>listFiles：列出指定目录下的所有文件。</p></li><li><p>openInputSteam：打开指定文件的输入流。</p></li><li><p>readFileToString：将文件内容作为字符串返回。</p></li><li><p>readlines方法：将文件内容按行返回到一个字符串数组中。</p></li><li><p>尺寸：返回文件或目录的大小。</p></li><li><p>写：将字符串内容直接写到文件中。</p></li><li><p>writeByteArrayToFile：将字节数组内容写到文件中。</p></li><li><p>writeLines：将容器中的元素的的toString方法返回的内容依次写入文件中。</p></li><li><p>writeStringToFile：将字符串内容写到文件中。</p></li></ul><h2 id="IOUtils的妙用"><a href="#IOUtils的妙用" class="headerlink" title="IOUtils的妙用"></a>IOUtils的妙用</h2><ol><li><p>buffer方法：将传入的流进行包装，变成缓冲流。并可以通过参数指定缓冲大小。</p></li><li><p>closeQueitly方法：关闭流。</p></li><li><p>contentEquals方法：比较两个流中的内容是否一致。</p></li><li><p>copy方法：将输入流中的内容拷贝到输出流中，并可以指定字符编码。</p></li><li><p>copyLarge方法：将输入流中的内容拷贝到输出流中，适合大于2G内容的拷贝。</p></li><li><p>lineIterator方法：返回可以迭代每一行内容的迭代器。</p></li><li><p>read方法：将输入流中的部分内容读入到字节数组中。</p></li><li><p>readFully方法：将输入流中的所有内容读入到字节数组中。</p></li><li><p>readLine方法：读入输入流内容中的一行。</p></li><li><p>toBufferedInputStream，toBufferedReader：将输入转为带缓存的输入流。</p></li><li><p>toByteArray，toCharArray：将输入流的内容转为字节数组、字符数组。</p></li><li><p>toString：将输入流或数组中的内容转化为字符串。</p></li><li><p>write方法：向流里面写入内容。</p></li><li><p>writeLine方法：向流里面写入一行内容。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;标签：常见 io 流总结&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;输入输出流&quot;&gt;&lt;a href=&quot;#输入输出流&quot; class=&quot;headerlink&quot; title=&quot;输入输出流&quot;&gt;&lt;/a&gt;输入输出流&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://sumulige-125714
      
    
    </summary>
    
    
    
      <category term="java学习笔记" scheme="http://www.sumulige.com/tags/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>hazel能为我们做什么</title>
    <link href="http://www.sumulige.com/2020/03/06/hazel%E8%83%BD%E4%B8%BA%E6%88%91%E4%BB%AC%E5%81%9A%E4%BB%80%E4%B9%88/"/>
    <id>http://www.sumulige.com/2020/03/06/hazel%E8%83%BD%E4%B8%BA%E6%88%91%E4%BB%AC%E5%81%9A%E4%BB%80%E4%B9%88/</id>
    <published>2020-03-05T18:12:41.000Z</published>
    <updated>2020-03-05T18:21:15.152Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址 <a href="https://sspai.com/post/35225" target="_blank" rel="noopener">https://sspai.com/post/35225</a></p><blockquote><p>让我们从实际需求出发，看看问题出在哪里，并在此基础上认识和学习使用 Hazel。</p></blockquote><p>电脑随着使用时间的增长，其中的文件也在疯狂的增长，时间长了也就会出现各种混乱：大量文件堆放在一起，旧文件很少清理，分不清哪些文件还有用，找不到需要的文件等等。</p><p>今天我们就以「下载」和「桌面」为例，聊一聊如何整理我们的电脑。</p><p><strong>Downloads</strong>：下载的文件很少处理，时间一长就各种堆积…… </p><p><img src="https://cdn.sspai.com/attachment/origin/2016/05/27/330232.png" alt=""></p><p><strong>Desktop</strong>：经常把临时文件存放在此，方便拖拽使用，但时间一长，就是各种凌乱……</p><p><img src="https://cdn.sspai.com/attachment/origin/2016/05/27/330233.png" alt=""></p><p>既然知道了问题所在，那么我们就来着手整理吧。</p><h3 id="理清整理思路"><a href="#理清整理思路" class="headerlink" title="理清整理思路"></a>理清整理思路</h3><p>首先是确定整理思路，比如如何界定一个文件是否还有用，如何界定它属于什么分类等，对应的操作一般是删除（比如不再需要的或重复的文件）或存档（学习资料或工作材料等分类存储），知道如何处理一个文件就很好办了，剩下的就都是体力活儿。</p><p>虽然这不是一件特别麻烦的事，但是我们也经常忘记或「懒得整理」。这有点类似于打扫房间，当我们没有时间或者经常忘记时，可以买一台扫地机器人帮助我们打扫，同样的，在 Mac 上也有这样一台「机器人」，它就是 Hazel。</p><h2 id="Hazel-是什么？"><a href="#Hazel-是什么？" class="headerlink" title="Hazel 是什么？"></a>Hazel 是什么？</h2><p>Hazel 是一款可以自动监控并整理文件夹的工具，其官网的介绍就是简单的一句话：Automated Organization for Your Mac。</p><p>它的使用有点类似于网络服务 IFTTT，你可以设定一个 if 条件，如果被监控的文件夹出现符合条件的项，那么对其执行 then 的操作（也可以通过邮箱的收件过滤规则来理解）。</p><p>Hazel 不是一款新工具，它已经有了很长的历史，其第一个版本在 2006 年底就已经发布，在今年 5 月 4 号，Hazel 发布了 4.0 版本，新增了规则同步（文末会有介绍）、规则搜索等一系列实用功能。</p><h2 id="Hazel-具体能做什么？"><a href="#Hazel-具体能做什么？" class="headerlink" title="Hazel 具体能做什么？"></a>Hazel 具体能做什么？</h2><p>先为大家简单罗列一些 Hazel 能做到的事情：</p><ul><li>根据文件创建的时间，自动将文件进行颜色标记（比如将最近的文件标记为蓝色）</li><li>自动的用特定软件打开某个特定文件（比如下载 BT 种子后，自动用迅雷打开下载）</li><li>自动删除已下载过的 BT 种子文件</li><li>根据文件的类型，自动转移到相应的文件夹中（比如图片移动到照片文件夹，电影移动到视频文件夹等）</li><li>自动删除某些特定文件（比如标题中含有固定内容且创建日期在很早以前的）</li><li>自动将压缩文件解压</li><li>自动帮你清理文件的缓存</li><li>自动帮你整理照片，可以按照「年 - 月」来分类存储到相应文件夹</li><li>自动把文件夹中的内容上传到 FTP 等网络服务中</li><li>自动将照片导入 Photos，自动将音乐导入 iTunes </li><li>……</li></ul><p>以上只是列举的一些场景能够实现的功能，再加上 Hazel 支持 AppleScript、JavaScript、Automator workflow 等代码指令，令其扩展性更上一层楼，可以做到的事情也可以说只剩下想象力这道门槛了。</p><p>介绍了不少，下面我们就从 Hazel 的安装和实际设置来为大家做一个简单的入门指南。</p><h2 id="Hazel-的安装"><a href="#Hazel-的安装" class="headerlink" title="Hazel 的安装"></a>Hazel 的安装</h2><p>前往<a href="https://www.noodlesoft.com/" target="_blank" rel="noopener">官网</a>下载最新版本，按照提示安装，完成后 Hazel 会出现在系统设置中（在应用程序中可找不到哦）。<br><img src="https://cdn.sspai.com/attachment/origin/2016/05/24/329535.png" alt="">Hazel 是一款收费软件，初次安装后可以免费试用 14 天，此时可以选择加载一些简单的默认规则以帮助你快速上手（当然看完这篇文章也就可以不用加载了）。</p><p>操作后 Hazel 会给我们弹出警告信息：在激活这些规则之前，一定要先检查它们。具体的方法下面会提及。</p><h2 id="Hazel-的界面和基础应用"><a href="#Hazel-的界面和基础应用" class="headerlink" title="Hazel 的界面和基础应用"></a>Hazel 的界面和基础应用</h2><p><strong>注：文末提供了文中所有 Hazel 规则的打包下载地址，如果你对文中介绍的规则感兴趣，可以直接下载使用。</strong></p><p>Hazel 的主界面包含三部分，分别是设置文件夹规则的 Folders 页面，设置垃圾箱规则的 Trash 页面和其他信息页（Info），今天主要给大家讲解文件夹规则设置页面。</p><p>在 Folders 中包含三部份：设置监控的文件夹（图中 1），设置该文件夹下的具体规则（图中 2），设置该文件夹的重复文件处理（图中 3），图 1 部分右侧的 icon 分别表示「暂停规则执行」和「同步」，建议尝试新规则的时候先暂停执行再进行调试。</p><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.sspai.com/attachment/origin/2016/05/30/330819.png" alt=""></h3><p>以整理「下载」文件夹为例，我个人的需求有如下几条：</p><ul><li>最近的下载文件用颜色标签提醒</li><li>超过 3 天的文件不再是新文件，去掉颜色标签</li><li>对存放超过 3 周的文件需进行处理，将满足此条件的文件用红色标记提醒</li><li>自动删除已使用的 .torrent 文件</li><li>将手机截屏的图片单独存放</li></ul><p>上面几条是梳理自己的整理需求后，选择的可以被 Hazel 自动执行的。此时回到 Hazel，我们点击左下角的加号新增「下载」文件夹，随后在右侧 Rules 区域点击加号新增规则。</p><h3 id="标记最新下载文件"><a href="#标记最新下载文件" class="headerlink" title="标记最新下载文件"></a>标记最新下载文件</h3><p>下图是规则设置界面，图 1 部分设置规则名称和注释；图 2 部分设置监控条件，此时设置的是文件添加时间在最后匹配时间之前（新文件添加后暂未被匹配，所以一定是早于匹配时间）；图 3 部分设置执行的动作，此时是将匹配出来的文件标记蓝色标签，并且同时可以被其他规则匹配。</p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://cdn.sspai.com/attachment/origin/2016/05/30/330822.png" alt=""></h3><h3 id="标记旧文件"><a href="#标记旧文件" class="headerlink" title="标记旧文件"></a>标记旧文件</h3><p>超过 3 天的文件，不再是我需要关注的内容，将其中的蓝色标签去掉：</p><p><img src="https://cdn.sspai.com/attachment/origin/2016/05/24/329544.png" alt=""></p><h3 id="标记待处理文件"><a href="#标记待处理文件" class="headerlink" title="标记待处理文件"></a>标记待处理文件</h3><p>对「下载」文件夹，我需要对超过 3 周未处理的文件进行处理，要么归档要么删除，需要进行人工判断的时候我使用红色标记来提醒自己：</p><p><img src="https://cdn.sspai.com/attachment/origin/2016/05/24/329545.png" alt=""></p><h3 id="删除-torrent-文件"><a href="#删除-torrent-文件" class="headerlink" title="删除 .torrent 文件"></a>删除 .torrent 文件</h3><p>在使用 BT 下载之后，留在文件夹的种子文件也就没有什么用了，为了防止误删设置了 5 天的期限，注意图中绿色符号，那是点击了 Preview 后的效果，建议设置规则的时候多使用 Preview 功能来检查条件设置是否正确，特别是那些复杂的符合条件。</p><p><img src="https://cdn.sspai.com/attachment/origin/2016/05/24/329546.png" alt=""></p><h3 id="自动移动手机截屏文件"><a href="#自动移动手机截屏文件" class="headerlink" title="自动移动手机截屏文件"></a>自动移动手机截屏文件</h3><p>工作关系，经常需要在手机上截屏上传到电脑使用（使用 AirDrop 上传到「下载」中），这类图片的处理一般是超过一周后移动到桌面文件夹中再进行集中处理：</p><p><img src="https://cdn.sspai.com/attachment/origin/2016/05/24/329549.png" alt="">上面介绍了「下载」文件夹的整理思路和执行；对于「桌面」文件夹的整理，我的思路一般是不轻易自动删除（防误删），而是统一到分类文件夹中集中处理。将文档存放于「文档」中，将图片存放于「图片」中等等，都是非常简单和基础的设置，就不做过多介绍；</p><p>下面说一下我对源文件的处理，这里涉及到条件的嵌套使用：</p><p><img src="https://cdn.sspai.com/attachment/origin/2016/05/24/329554.png" alt=""></p><p>图中使用了嵌套条件，具体的操作是鼠标长按右侧加号（也可按住 Option 后点击），即可增加嵌套条件组。</p><p>附上桌面整理后截图：</p><p><img src="https://cdn.sspai.com/attachment/origin/2016/06/16/333228.png" alt=""></p><h2 id="Hazel-中级应用"><a href="#Hazel-中级应用" class="headerlink" title="Hazel 中级应用"></a>Hazel 中级应用</h2><p>除了以上的基础使用，Hazel 还可作用于更加广泛的场景，下面以<strong>自动解压</strong>和<strong>自动清理缓存</strong>为例。</p><h3 id="自动解压"><a href="#自动解压" class="headerlink" title="自动解压"></a>自动解压</h3><p>下载压缩包后不用手动解压，Hazel 会自动创建文件夹（按照压缩包的名称命名），并将压缩包和解压后的文件存放于此：</p><p><img src="https://cdn.sspai.com/attachment/origin/2016/05/24/329550.png" alt=""></p><p>有三点需要为大家说明：</p><ul><li>设置标签是为了防止压缩文件有损坏而导致 Hazel 陷入循环执行中；</li><li>不能设置自动删除，因为 Hazel 会自动选中解压后的文件，此时的删除也只是把解压后的文件删掉；</li><li>使用默认的「Unarchive」操作也可解压，不过在解压 .zip 文件后会自动将压缩包删掉，所以我这里使用了第三方的免费解压软件 <a href="https://itunes.apple.com/hk/app/the-unarchiver/id425424353?mt=12" target="_blank" rel="noopener">The Unarchiver</a> 代替（注意：在第一次执行时需要权限设置）；不介意删除压缩包的同学使用默认的解压操作即可。</li></ul><p>此规则参考了 <a href="http://www.briankoponen.com/use-hazel-to-unzip-lots-of-zip-files/" target="_blank" rel="noopener">Brian Koponen</a> 的博客，特此感谢。</p><h3 id="自动清理缓存"><a href="#自动清理缓存" class="headerlink" title="自动清理缓存"></a>自动清理缓存</h3><p>以 QQ 为例，QQ 会把群消息中的图片自动保存到本地，时间一长这个文件夹就很容易达到几个 G 的大小，这时候 Hazel 又可以派上用处了。</p><p>首先找到你的 QQ 文件夹，可尝试如下路径（本人 Mac 系统 10.11）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;Users&#x2F;用户名&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ</span><br></pre></td></tr></table></figure><p>将路径中的「用户名」换成自己的，然后在 Finder 中按住「⌘ + Shift + G」，把路径粘贴到输入框中点击「前往」即可。</p><p><img src="https://cdn.sspai.com/attachment/origin/2016/05/24/329558.png" alt=""></p><p>如果路径没问题，就可以在 Hazel 中添加此文件夹了，点击添加按钮弹出选择文件夹界面后，使用上述快捷键和路径同样可以快速选定，添加后设置如下两条规则，第一条规则的作用是让所有子文件夹都可以适配规则并执行操作；第二条规则是把超过 500M 的子文件夹进行删除操作，且不会直接删除父文件夹。</p><p><img src="https://cdn.sspai.com/attachment/origin/2016/05/24/329567.png" alt=""> <img src="https://cdn.sspai.com/attachment/origin/2016/05/24/329568.png" alt=""></p><p>至此，QQ 缓存文件的自动清理就设置完成了，其他软件缓存也可以进行类似的规则设计，不过一定要注意确保这里面没有你需要的文件，否则一旦删除要找回也是颇为麻烦的。</p><h3 id="更多用法"><a href="#更多用法" class="headerlink" title="更多用法"></a>更多用法</h3><p>如前文所说，Hazel 能做到的不止这些场景，还有用户用它来整理照片，利用 AppleScript 执行更加复杂的工作流程等等，这里仅当作抛砖引玉，欢迎大家分享自己的用法，并且以后也会有更多关于 Hazel 使用技巧的文章。 </p><h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><h3 id="管理垃圾箱"><a href="#管理垃圾箱" class="headerlink" title="管理垃圾箱"></a>管理垃圾箱</h3><p>在 Hazel 的 Trash 页面，可以进行一些垃圾箱的设置，比如将其中超过一周的文件删除，保持垃圾箱大小控制在 2GB 左右，选择删除时是否使用安全删除功能，以及卸载应用时检测其附属文件夹等等；这方面的功能笔者并不常用，在此不做过多介绍。</p><p><img src="https://cdn.sspai.com/attachment/origin/2016/05/24/329561.png" alt=""></p><p>删除应用时检测相关文件，并可选择一并删除。作用类似于 <a href="../tag/CleanMyMac">CleanMyMac</a>。</p><p><img src="https://cdn.sspai.com/attachment/origin/2016/05/24/329562.png" alt=""></p><h3 id="同步规则"><a href="#同步规则" class="headerlink" title="同步规则"></a>同步规则</h3><p>同步功能在 4.0 终于推出，现在也可以方便的使用在多台电脑上了。点击左侧面板中的齿轮图标，选择 Rule Sync Options 即可打开同步界面（也可在文件夹上右键选择 Rule Sync Options）。</p><p><img src="https://cdn.sspai.com/attachment/origin/2016/05/24/329563.png" alt=""></p><p>同步需要配合第三方同步网盘使用，当前文件夹若是第一次使用同步，需要设置同步文件存放路径，点击 Set up new sync file 即可。如果要使用同步的文件，在界面中点击 Use existing sync file 即可。</p><h2 id="Hazel-的下载"><a href="#Hazel-的下载" class="headerlink" title="Hazel 的下载"></a>Hazel 的下载</h2><p>Hazel 是一款收费软件（<a href="https://www.noodlesoft.com/" target="_blank" rel="noopener">下载地址</a>），五月初的时候发布了 4.0 版本，单独购买是 $32，Family Pack $49，从 3.0 版本升级需要 $10。初次下载可以免费试用 14 天，建议大家先试用再购买。</p><p>最后给大家提供我自己的 Hazel 设置，你可以导入后调整为适合自己的规则再使用：<a href="https://pan.baidu.com/s/1SZRq_cuPjGqJLphm3Sjl8w" target="_blank" rel="noopener">百度云下载</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文地址 &lt;a href=&quot;https://sspai.com/post/35225&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://sspai.com/post/35225&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;让我们从实际需求出
      
    
    </summary>
    
    
    
      <category term="hazel" scheme="http://www.sumulige.com/tags/hazel/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记-二叉树、平衡二叉树(AVL)、红黑二叉树（十）</title>
    <link href="http://www.sumulige.com/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91(AVL)%E3%80%81%E7%BA%A2%E9%BB%91%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%8D%81%EF%BC%89/"/>
    <id>http://www.sumulige.com/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91(AVL)%E3%80%81%E7%BA%A2%E9%BB%91%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%8D%81%EF%BC%89/</id>
    <published>2020-03-05T18:12:41.000Z</published>
    <updated>2020-03-05T19:03:57.033Z</updated>
    
    <content type="html"><![CDATA[<p>标签：数据结构范畴</p><hr><h2 id="二叉树的定义："><a href="#二叉树的定义：" class="headerlink" title="二叉树的定义："></a>二叉树的定义：</h2><p>二叉树是树形结构的一个重要类型。 许多实际问题抽象出来的数据结构往往是二叉树的形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。</p><p>二叉树(BinaryTree)由一个节点及两棵互不相交的、分别称作这个根的左子树和右子树的二叉树组成。下图中展现了五种不同基本形态的二叉树。</p><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834279419662.jpg" alt=""></p><p>(a) 为空树。</p><p>(b) 为仅有一个结点的二叉树。</p><p>(c) 是仅有左子树而右子树为空的二叉树。</p><p>(d) 是仅有右子树而左子树为空的二叉树。</p><p>(e) 是左、右子树均非空的二叉树。</p><blockquote><p>二叉树的左子树和右子树是严格区分并且不能随意颠倒的，图 (c) 与图 (d) 就是两棵不同的二叉树。</p></blockquote><h2 id="排序二叉树特性如下："><a href="#排序二叉树特性如下：" class="headerlink" title="排序二叉树特性如下："></a>排序二叉树特性如下：</h2><p>(1) 左子树上所有节点的值均小于它的根节点的值。</p><p>(2) 右子树上所有节点的值均大于它的根节点的值。</p><p>比如：我们要将数据【14,12,23,4,16,13, 8,,3】存储到排序二叉树中，如下图所示：</p><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834279550921.jpg" alt=""></p><p>排序二叉树本身实现了排序功能，可以快速检索。但如果插入的节点集本身就是有序的，要么是由小到大排列，要么是由大到小排列，那么最后得到的排序二叉树将变成普通的链表，其检索效率就会很差。 比如上面的数据【14,12,23,4,16,13, 8,,3】，我们先进行排序变成：【3,4,8,12,13,14,16,23】，然后存储到排序二叉树中，显然就变成了链表，如下图所示：</p><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834279657885.jpg" alt=""></p><h2 id="平衡二叉树（AVL）："><a href="#平衡二叉树（AVL）：" class="headerlink" title="平衡二叉树（AVL）："></a>平衡二叉树（AVL）：</h2><p>为了避免出现上述一边倒的存储，科学家提出了“平衡二叉树”。</p><p>在平衡二叉树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。 增加和删除节点可能需要通过一次或多次树旋转来重新平衡这个树。</p><p>节点的平衡因子是它的左子树的高度减去它的右子树的高度(有时相反)。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。</p><p>比如，我们存储排好序的数据【3,4,8,12,13,14,16,23】，增加节点如果出现不平衡，则通过节点的左旋或右旋，重新平衡树结构，最终平衡二叉树如下图所示：</p><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834279758638.jpg" alt=""></p><p>平衡二叉树追求绝对平衡，实现起来比较麻烦，每次插入新节点需要做的旋转操作次数不能预知。</p><h2 id="红黑二叉树："><a href="#红黑二叉树：" class="headerlink" title="红黑二叉树："></a>红黑二叉树：</h2><p>红黑二叉树(简称：红黑树)，它首先是一棵二叉树，同时也是一棵自平衡的排序二叉树。</p><p>红黑树在原有的排序二叉树增加了如下几个要求：</p><ol><li><p>每个节点要么是红色，要么是黑色。</p></li><li><p>根节点永远是黑色的。</p></li><li><p>所有的叶节点都是空节点(即 null)，并且是黑色的。</p></li><li><p>每个红色节点的两个子节点都是黑色。(从每个叶子到根的路径上不会有两个连续的红色节点)</p></li><li><p>从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</p></li></ol><p>这些约束强化了红黑树的关键性质：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。这样就让树大致上是平衡的。</p><p>红黑树是一个更高效的检索二叉树，JDK 提供的集合类 TreeMap、TreeSet 本身就是一个红黑树的实现。</p><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834279864984.jpg" alt=""></p><p>红黑树的基本操作：插入、删除、左旋、右旋、着色。 每插入或者删除一个节点，可能会导致树不在符合红黑树的特征，需要进行修复，进行 “左旋、右旋、着色”操作，使树继续保持红黑树的特性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;标签：数据结构范畴&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;二叉树的定义：&quot;&gt;&lt;a href=&quot;#二叉树的定义：&quot; class=&quot;headerlink&quot; title=&quot;二叉树的定义：&quot;&gt;&lt;/a&gt;二叉树的定义：&lt;/h2&gt;&lt;p&gt;二叉树是树形结构的一个重要类型。 许多实际问题抽象出来的
      
    
    </summary>
    
    
    
      <category term="java学习笔记" scheme="http://www.sumulige.com/tags/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记-写在前面（一）</title>
    <link href="http://www.sumulige.com/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.sumulige.com/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-03-05T18:12:41.000Z</published>
    <updated>2020-03-05T19:24:32.649Z</updated>
    
    <content type="html"><![CDATA[<p>标签：语言介绍</p><hr><h2 id="各种语言了解"><a href="#各种语言了解" class="headerlink" title="各种语言了解"></a>各种语言了解</h2><ul><li>c语言</li><li>c++</li><li>java</li><li>php–网站（中小型网站）</li><li>Object C （oc）和swift</li><li>javascript（和java关系不大）— node.js做游戏开发</li><li>python 胶水语言</li><li>C#–微软（开发windows的应用软件）</li><li>basic语言</li><li>cobel</li><li>pascal</li></ul><h2 id="计算机发展史和未来方向"><a href="#计算机发展史和未来方向" class="headerlink" title="计算机发展史和未来方向"></a>计算机发展史和未来方向</h2><ol><li>人类活动范围的变化</li><li>算法是核心</li></ol><h2 id="语言阶段："><a href="#语言阶段：" class="headerlink" title="语言阶段："></a>语言阶段：</h2><ol><li>机器语言（数字：+12345678</li><li>汇编语言</li><li>高级语言</li></ol><h2 id="如何学习"><a href="#如何学习" class="headerlink" title="如何学习"></a>如何学习</h2><ol><li>重代码</li><li>重底层</li><li>重项目</li></ol><h2 id="价值观："><a href="#价值观：" class="headerlink" title="价值观："></a>价值观：</h2><ol><li>遇到一个点不会，不要纠结，达到这个阶段的时候在返回去看。</li><li>降维</li><li>知识体系</li></ol><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul><li>跨平台</li></ul><h2 id="java生态："><a href="#java生态：" class="headerlink" title="java生态："></a>java生态：</h2><ol><li>1991年出现，高司令</li><li>与互联网的发展类似</li><li>生态建好不易被取代</li></ol><h2 id="java-三大版本"><a href="#java-三大版本" class="headerlink" title="java 三大版本"></a>java 三大版本</h2><ol><li>java EE</li><li>java ME</li><li>java SE</li></ol><h3 id="三者关系："><a href="#三者关系：" class="headerlink" title="三者关系："></a>三者关系：</h3><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834280632960.jpg" alt=""></p><h2 id="java-程序运行机制"><a href="#java-程序运行机制" class="headerlink" title="java 程序运行机制"></a>java 程序运行机制</h2><ol><li>基于解释编译再到运行<blockquote><p>安全：每次加载的都会校验</p></blockquote></li><li></li></ol><h2 id="jdk-jre和JVM的作用和区别"><a href="#jdk-jre和JVM的作用和区别" class="headerlink" title="jdk. jre和JVM的作用和区别"></a>jdk. jre和JVM的作用和区别</h2><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834280721497.jpg" alt=""></p><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834281222493.jpg" alt=""></p><h2 id="jdk环境变量PATH配置classpath的问题"><a href="#jdk环境变量PATH配置classpath的问题" class="headerlink" title="jdk环境变量PATH配置classpath的问题"></a>jdk环境变量PATH配置classpath的问题</h2><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834281309703.jpg" alt=""></p><blockquote><p>小贴士：jdk1.5以后不需要配置classpath</p></blockquote><h2 id="写出第一个java应用程序"><a href="#写出第一个java应用程序" class="headerlink" title="写出第一个java应用程序"></a>写出第一个java应用程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstJava</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Welcome To Java"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最常用的dos命令"><a href="#最常用的dos命令" class="headerlink" title="最常用的dos命令"></a>最常用的dos命令</h2><ol><li>cd..</li><li>dir 查找本目录下的文件和子目录列表</li><li>cls清除屏幕</li><li>上下键</li><li>tab健 自动补齐</li></ol><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ol><li>记事本时代是一种无奈<br>而不是一种必须</li><li>idea</li><li>eclipse</li><li>vs</li></ol><h2 id="变量的本质"><a href="#变量的本质" class="headerlink" title="变量的本质"></a>变量的本质</h2><p>可操作的操作空间</p><p>不同的数据类型的常量会在内存中分配不同的操作空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>  salary;</span><br><span class="line"><span class="keyword">long</span>  earthPopulation;</span><br><span class="line"><span class="keyword">int</span>  age;</span><br></pre></td></tr></table></figure><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834281425529.jpg" alt=""></p><h2 id="变量的分类："><a href="#变量的分类：" class="headerlink" title="变量的分类："></a>变量的分类：</h2><p>局部变量：方法内部或块内：声明开始到方法调用结束<br>成员变量：类内部方法外部 从属于对象<br>静态变量：从属于类</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>基本数据类型：</p><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834281528946.jpg" alt=""></p><p>引用数据类型的字节统一为4个字节，记录对象的引用地址。</p><p>整型数据类型：</p><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834281794175.jpg" alt=""></p><h2 id="Java-语言整型常量的四种表示形式"><a href="#Java-语言整型常量的四种表示形式" class="headerlink" title="Java 语言整型常量的四种表示形式"></a>Java 语言整型常量的四种表示形式</h2><p>十进制整数，如：99, -500, 0</p><p>八进制整数，要求以 0 开头，如：015</p><p>十六进制数，要求 0x 或 0X 开头，如：0x15</p><p>二进制数，要求0b或0B开头，如：0b01110011</p><h2 id="浮点型变量-常量"><a href="#浮点型变量-常量" class="headerlink" title="浮点型变量/常量"></a>浮点型变量/常量</h2><p>Java浮点类型常量有两种表示形式</p><p>十进制数形式，例如:3.14       314.0      0.314 </p><p>科学记数法形式，如314e2      314E2      314E-2 </p><p>char 类型用来表示在Unicode编码表中的字符。Unicode编码被设计用来处理各种语言的文字，它占2个字节，可允许有65536个字符。</p><p>unicode表示从0-65535之间的编码，通常用从‘\u0000’—‘\uFFFF’之间的16进制表示</p><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834350589809.jpg" alt=""></p><h2 id="boolean变量和常量"><a href="#boolean变量和常量" class="headerlink" title="boolean变量和常量"></a>boolean变量和常量</h2><p>boolean类型有两个常量值，true和false，在内存中占一位（不是一个字节），不可以使用 0 或非 0 的整数替代 true 和 false ，这点和C语言不同。 boolean 类型用来判断逻辑条件，一般用于程序流程控制 。</p><p>Less is More！！请不要这样写：if ( flag == true )，只有新手才那么写。关键也很容易写错成if(flag=true)，这样就变成赋值flag 为true而不是判断！老鸟的写法是if ( flag )或者if ( !flag)</p><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><p>二元运算符的运算规则：</p><p>整数运算：</p><p>　1. 如果两个操作数有一个为Long, 则结果也为long。</p><p>　2. 没有long时，结果为int。即使操作数全为short，byte，结果也是int。</p><p>浮点运算：</p><p>　1. 如果两个操作数有一个为double，则结果为double。</p><p>　2. 只有两个操作数都是float，则结果才为float。</p><p>　　　　　　　　　　　　　　　　　</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;标签：语言介绍&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;各种语言了解&quot;&gt;&lt;a href=&quot;#各种语言了解&quot; class=&quot;headerlink&quot; title=&quot;各种语言了解&quot;&gt;&lt;/a&gt;各种语言了解&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;c语言&lt;/li&gt;
&lt;li&gt;c++&lt;/li&gt;
&lt;li&gt;ja
      
    
    </summary>
    
    
    
      <category term="java学习笔记" scheme="http://www.sumulige.com/tags/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记-写在前面（二）</title>
    <link href="http://www.sumulige.com/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://www.sumulige.com/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-03-05T18:12:41.000Z</published>
    <updated>2020-03-05T19:03:35.148Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834272689099.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834272689099.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="java学习笔记" scheme="http://www.sumulige.com/tags/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记-多线程（十一）</title>
    <link href="http://www.sumulige.com/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/"/>
    <id>http://www.sumulige.com/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/</id>
    <published>2020-03-05T18:12:41.000Z</published>
    <updated>2020-03-05T19:53:49.494Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>多线程是Java语言的重要特性，大量应用于网络编程、服务器端程序的开发，最常见的UI界面底层原理、操作系统底层原理都大量使用了多线程。</p><p>我们可以流畅的点击软件或者游戏中的各种按钮，其实，底层就是多线程的应用。UI界面的主线程绘制界面，如果有一个耗时的操作发生则启动新的线程，完全不影响主线程的工作。当这个线程工作完毕后，再更新到主界面上。</p><p>执行中的程序叫做进程(Process)，是一个动态的概念。现代的操作系统都可以同时启动多个进程。比如：我们在用酷狗听音乐，也可以使用eclipse写代码，也可以同时用浏览器查看网页。进程具有如下特点：</p><ol><li><p>进程是程序的一次动态执行过程， 占用特定的地址空间。</p></li><li><p>每个进程由3部分组成：cpu、data、code。每个进程都是独立的，保有自己的cpu时间，代码和数据，即便用同一份程序产生好几个进程，它们之间还是拥有自己的这3样东西，这样的缺点是：浪费内存，cpu的负担较重。</p></li><li><p>多任务(Multitasking)操作系统将CPU时间动态地划分给每个进程，操作系统同时执行多个进程，每个进程独立运行。以进程的观点来看，它会以为自己独占CPU的使用权。</p></li></ol><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>一个进程可以产生多个线程。同多个进程可以共享操作系统的某些资源一样，同一进程的多个线程也可以共享此进程的某些资源(比如：代码、数据)，所以线程又被称为轻量级进程(lightweight process)。</p><ol><li><p>一个进程内部的一个执行单元，它是程序中的一个单一的顺序控制流程。</p></li><li><p>一个进程可拥有多个并行的(concurrent)线程。</p></li><li><p>一个进程中的多个线程共享相同的内存单元/内存地址空间，可以访问相同的变量和对象，而且它们从同一堆中分配对象并进行通信、数据交换和同步操作。</p><ol><li><p>由于线程间的通信是在同一地址空间上进行的，所以不需要额外的通信机制，这就使得通信更简便而且信息传递的速度也更快。</p></li><li><p>线程的启动、中断、消亡，消耗的资源非常少。</p></li></ol></li></ol><p>  <img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834263138980.jpg" alt=""></p><h2 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h2><ol><li><p>每个进程都有独立的代码和数据空间(进程上下文)，进程间的切换会有较大的开销。</p></li><li><p>线程可以看成是轻量级的进程，属于同一进程的线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换的开销小。</p></li><li><p>线程和进程最根本的区别在于：进程是资源分配的单位，线程是调度和执行的单位。</p></li><li><p>多进程: 在操作系统中能同时运行多个任务(程序)。</p></li><li><p>多线程: 在同一应用程序中有多个顺序流同时执行。</p></li><li><p>线程是进程的一部分，所以线程有的时候被称为轻量级进程。</p></li><li><p>一个没有线程的进程是可以被看作单线程的，如果一个进程内拥有多个线程，进程的执行过程不是一条线(线程)的，而是多条线(线程)共同完成的。</p></li><li><p>系统在运行的时候会为每个进程分配不同的内存区域，但是不会为线程分配内存(线程所使用的资源是它所属的进程的资源)，线程组只能共享资源。那就是说，除了CPU之外(线程在运行的时候要占用CPU资源)，计算机内部的软硬件资源的分配与线程无关，线程只能共享它所属进程的资源。</p></li></ol><h2 id="进程与程序的区别"><a href="#进程与程序的区别" class="headerlink" title="进程与程序的区别"></a>进程与程序的区别</h2><p>程序是一组指令的集合，它是静态的实体，没有执行的含义。而进程是一个动态的实体，有自己的生命周期。一般说来，一个进程肯定与一个程序相对应，并且只有一个，但是一个程序可以有多个进程，或者一个进程都没有。除此之外，进程还有并发性和交往性。简单地说，进程是程序的一部分，程序运行的时候会产生进程。</p><h2 id="通过继承Thread类实现多线程"><a href="#通过继承Thread类实现多线程" class="headerlink" title="通过继承Thread类实现多线程"></a>通过继承Thread类实现多线程</h2><p>继承Thread类实现多线程的步骤：</p><ol><li><p>在Java中负责实现线程功能的类是java.lang.Thread 类。</p></li><li><p>可以通过创建 Thread的实例来创建新的线程。</p></li><li><p>每个线程都是通过某个特定的Thread对象所对应的方法run( )来完成其操作的，方法run( )称为线程体。</p></li><li><p>通过调用Thread类的start()方法来启动一个线程。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copyright (C), 2015-2019, 中信银行有限公司</span></span><br><span class="line"><span class="comment"> * FileName: TestThread</span></span><br><span class="line"><span class="comment"> * Author:   willem</span></span><br><span class="line"><span class="comment"> * Date:     2019-05-16 14:45</span></span><br><span class="line"><span class="comment"> * Description: 通过继承thread类实现多线程</span></span><br><span class="line"><span class="comment"> * History:</span></span><br><span class="line"><span class="comment"> * &lt;author&gt;          &lt;time&gt;          &lt;version&gt;          &lt;desc&gt;</span></span><br><span class="line"><span class="comment"> * 作者姓名           修改时间           版本号              描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.citic.java.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈一句话功能简述〉&lt;br&gt; </span></span><br><span class="line"><span class="comment"> * 〈通过继承thread类实现多线程〉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> willem</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-05-16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThread th = <span class="keyword">new</span> TestThread();</span><br><span class="line">        th.start();</span><br><span class="line"></span><br><span class="line">        TestThread th1 = <span class="keyword">new</span> TestThread();</span><br><span class="line">        th1.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过实现Runnable接口实现多线程"><a href="#通过实现Runnable接口实现多线程" class="headerlink" title="通过实现Runnable接口实现多线程"></a>通过实现Runnable接口实现多线程</h2><p><strong>在开发中，我们应用更多的是通过Runnable接口实现多线程。这种方式克服了11.2.1节中实现线程类的缺点，即在实现Runnable接口的同时还可以继承某个类。所以实现Runnable接口的方式要通用一些。</strong></p><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834263458794.jpg" alt=""></p><p>一个线程对象在它的生命周期内，需要经历5个状态。</p><ol><li><p>新生状态(New)<br>用new关键字建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态。</p></li><li><p>就绪状态(Runnable)<br>处于就绪状态的线程已经具备了运行条件，但是还没有被分配到CPU，处于“线程就绪队列”，等待系统为其分配CPU。就绪状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会进入执行状态。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。有4中原因会导致线程进入就绪状态：</p><ol><li>新建线程：调用start()方法，进入就绪状态;</li><li>阻塞线程：阻塞解除，进入就绪状态;</li><li>运行线程：调用yield()方法，直接进入就绪状态;</li><li>运行线程：JVM将CPU资源从本线程切换到其他线程。</li></ol></li><li><p>运行状态(Running)<br>在运行状态的线程执行自己run方法中的代码，直到调用其他方法而终止或等待某资源而阻塞或完成任务而死亡。如果在给定的时间片内没有执行结束，就会被系统给换下来回到就绪状态。也可能由于某些“导致阻塞的事件”而进入阻塞状态。</p></li><li><p>阻塞状态(Blocked)<br>阻塞指的是暂停一个线程的执行以等待某个条件发生(如某资源就绪)。有4种原因会导致阻塞：</p><ol><li>执行sleep(int millsecond)方法，使当前线程休眠，进入阻塞状态。当指定的时间到了后，线程进入就绪状态。</li><li>执行wait()方法，使当前线程进入阻塞状态。当使用nofity()方法唤醒这个线程后，它进入就绪状态。</li><li>线程运行时，某个操作进入阻塞状态，比如执行IO流操作(read()/write()方法本身就是阻塞的方法)。只有当引起该操作阻塞的原因消失后，线程进入就绪状态。</li><li>join()线程联合: 当某个线程等待另一个线程执行结束后，才能继续执行时，使用join()方法。</li></ol></li><li><p>死亡状态(Terminated)<br>死亡状态是线程生命周期中的最后一个阶段。线程死亡的原因有两个。一个是正常运行的线程完成了它run()方法内的全部工作; 另一个是线程被强制终止，如通过执行stop()或destroy()方法来终止一个线程(注：stop()/destroy()方法已经被JDK废弃，不推荐使用)。</p></li></ol><p>当一个线程进入死亡状态以后，就不能再回到其它状态了。</p><h2 id="线程终止的典型方式"><a href="#线程终止的典型方式" class="headerlink" title="线程终止的典型方式"></a>线程终止的典型方式</h2><p>终止线程我们一般不使用JDK提供的stop()/destroy()方法(它们本身也被JDK废弃了)。通常的做法是提供一个boolean型的终止变量，当这个变量置为false，则终止线程的运行。</p><p>【示例11-3】终止线程的典型方法(重要)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copyright (C), 2015-2019, 中信银行有限公司</span></span><br><span class="line"><span class="comment"> * FileName: TestThreadCiycle</span></span><br><span class="line"><span class="comment"> * Author:   willem</span></span><br><span class="line"><span class="comment"> * Date:     2019-05-16 15:34</span></span><br><span class="line"><span class="comment"> * Description: 终止线程的典型方法(重要)</span></span><br><span class="line"><span class="comment"> * History:</span></span><br><span class="line"><span class="comment"> * &lt;author&gt;          &lt;time&gt;          &lt;version&gt;          &lt;desc&gt;</span></span><br><span class="line"><span class="comment"> * 作者姓名           修改时间           版本号              描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.citic.java.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈一句话功能简述〉&lt;br&gt; </span></span><br><span class="line"><span class="comment"> * 〈终止线程的典型方法(重要)〉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> willem</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-05-16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadCiycle</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">//标记线程是否终止</span></span><br><span class="line">    <span class="keyword">boolean</span> live = <span class="keyword">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(live)&#123;</span><br><span class="line">            System.out.println(name+(i++));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">terminate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        live = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThreadCiycle ttc = <span class="keyword">new</span> TestThreadCiycle();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(ttc);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"主线程"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        ttc.terminate();</span><br><span class="line">        System.out.println(<span class="string">"tcc stop"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="暂停线程执行sleep-yield"><a href="#暂停线程执行sleep-yield" class="headerlink" title="暂停线程执行sleep/yield"></a>暂停线程执行sleep/yield</h2><p>暂停线程执行常用的方法有sleep()和yield()方法，这两个方法的区别是：</p><ol><li><p>sleep()方法：可以让正在运行的线程进入阻塞状态，直到休眠时间满了，进入就绪状态。</p></li><li><p>yield()方法：可以让正在运行的线程直接进入就绪状态，让出CPU的使用权。</p></li></ol><h2 id="线程的联合join"><a href="#线程的联合join" class="headerlink" title="线程的联合join()"></a>线程的联合join()</h2><p>线程A在运行期间，可以调用线程B的join()方法，让线程B和线程A联合。这样，线程A就必须等待线程B执行完毕后，才能继续执行。如下面示例中，“爸爸线程”要抽烟，于是联合了“儿子线程”去买烟，必须等待“儿子线程”买烟完毕，“爸爸线程”才能继续抽烟。</p><h2 id="获取线程基本信息的方法"><a href="#获取线程基本信息的方法" class="headerlink" title="获取线程基本信息的方法"></a>获取线程基本信息的方法</h2><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834263917681.jpg" alt=""></p><h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><ol><li><p>处于就绪状态的线程，会进入“就绪队列”等待JVM来挑选。</p></li><li><p>线程的优先级用数字表示，范围从1到10，一个线程的缺省优先级是    5。</p></li><li><p>使用下列方法获得或设置线程对象的优先级。</p><p> int getPriority();</p><p> void setPriority(int newPriority);</p></li></ol><blockquote><p>注意：优先级低只是意味着获得调度的概率低。并不是绝对先调用优先级高的线程后调用优先级低的线程。</p></blockquote><h2 id="线程同步的概念"><a href="#线程同步的概念" class="headerlink" title="线程同步的概念"></a>线程同步的概念</h2><p>处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象。 这时候，我们就需要用到“线程同步”。 线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面的线程使用完毕后，下一个线程再使用。</p><h2 id="实现线程同步"><a href="#实现线程同步" class="headerlink" title="实现线程同步"></a>实现线程同步</h2><p>由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突的问题。Java语言提供了专门机制以解决这种冲突，有效避免了同一个数据对象被多个线程同时访问造成的这种问题。</p><p>由于我们可以通过 private 关键字来保证数据对象只能被方法访问，所以我们只需针对方法提出一套机制，这套机制就是synchronized关键字，它包括两种用法：synchronized 方法和 synchronized 块。</p><ol><li>synchronized 方法</li></ol><p>通过在方法声明中加入 synchronized关键字来声明，语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">accessVal</span><span class="params">(<span class="keyword">int</span> newVal)</span></span>;</span><br></pre></td></tr></table></figure><p>synchronized 方法控制对“对象的类成员变量”的访问：每个对象对应一把锁，每个 synchronized 方法都必须获得调用该方法的对象的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。</p><ol start="2"><li>synchronized块</li></ol><p>synchronized 方法的缺陷：若将一个大的方法声明为synchronized 将会大大影响效率。</p><p>Java 为我们提供了更好的解决办法，那就是 synchronized 块。 块可以让我们精确地控制到具体的“成员变量”，缩小同步的范围，提高效率。</p><p>synchronized 块：通过 synchronized关键字来声明synchronized 块，语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(syncObject)</span><br><span class="line">　  &#123; </span><br><span class="line">　　 <span class="comment">//允许访问控制的代码 </span></span><br><span class="line">　  &#125;</span><br></pre></td></tr></table></figure><h2 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h2><p>“死锁”指的是：</p><p>多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能进行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。</p><p>因此，某一个同步块需要同时拥有“两个以上对象的锁”时，就可能会发生“死锁”的问题。下面案例中，“化妆线程”需要同时拥有“镜子对象”、“口红对象”才能运行同步块。那么，实际运行时，“小丫的化妆线程”拥有了“镜子对象”，“大丫的化妆线程”拥有了“口红对象”，都在互相等待对方释放资源，才能化妆。这样，两个线程就形成了互相等待，无法继续运行的“死锁状态”。</p><h2 id="死锁的解决方法"><a href="#死锁的解决方法" class="headerlink" title="死锁的解决方法"></a>死锁的解决方法</h2><p>死锁是由于“同步块需要同时持有多个对象锁造成”的，要解决这个问题，思路很简单，就是：同一个代码块，不要同时持有两个对象锁。</p><h2 id="线程并发协作-生产者-消费者模式"><a href="#线程并发协作-生产者-消费者模式" class="headerlink" title="线程并发协作(生产者/消费者模式)"></a>线程并发协作(生产者/消费者模式)</h2><p>多线程环境下，我们经常需要多个线程的并发和协作。这个时候，就需要了解一个重要的多线程并发协作模型“生产者/消费者模式”。</p><h3 id="什么是生产者"><a href="#什么是生产者" class="headerlink" title="什么是生产者?"></a>什么是生产者?</h3><p>生产者指的是负责生产数据的模块(这里模块可能是：方法、对象、线程、进程)。</p><h3 id="什么是消费者"><a href="#什么是消费者" class="headerlink" title="什么是消费者?"></a>什么是消费者?</h3><p>消费者指的是负责处理数据的模块(这里模块可能是：方法、对象、线程、进程)。</p><h3 id="什么是缓冲区"><a href="#什么是缓冲区" class="headerlink" title="什么是缓冲区?"></a>什么是缓冲区?</h3><p>消费者不能直接使用生产者的数据，它们之间有个“缓冲区”。生产者将生产好的数据放入“缓冲区”，消费者从“缓冲区”拿要处理的数据。</p><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834264127860.jpg" alt=""></p><h3 id="缓冲区是实现并发的核心，缓冲区的设置有3个好处："><a href="#缓冲区是实现并发的核心，缓冲区的设置有3个好处：" class="headerlink" title="缓冲区是实现并发的核心，缓冲区的设置有3个好处："></a>缓冲区是实现并发的核心，缓冲区的设置有3个好处：</h3><ol><li>实现线程的并发协作</li></ol><p>有了缓冲区以后，生产者线程只需要往缓冲区里面放置数据，而不需要管消费者消费的情况;同样，消费者只需要从缓冲区拿数据处理即可，也不需要管生产者生产的情况。 这样，就从逻辑上实现了“生产者线程”和“消费者线程”的分离。</p><ol start="2"><li>解耦了生产者和消费者</li></ol><p>生产者不需要和消费者直接打交道。</p><ol start="3"><li>解决忙闲不均，提高效率</li></ol><p>生产者生产数据慢时，缓冲区仍有数据，不影响消费者消费;消费者处理数据慢时，生产者仍然可以继续往缓冲区里面放置数据 。</p><h3 id="线程并发协作总结："><a href="#线程并发协作总结：" class="headerlink" title="线程并发协作总结："></a>线程并发协作总结：</h3><p>线程并发协作(也叫线程通信)，通常用于生产者/消费者模式，情景如下：</p><ol><li><p>生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件。</p></li><li><p>对于生产者，没有生产产品之前，消费者要进入等待状态。而生产了产品之后，又需要马上通知消费者消费。</p></li><li><p>对于消费者，在消费之后，要通知生产者已经消费结束，需要继续生产新产品以供消费。</p></li><li><p>在生产者消费者问题中，仅有synchronized是不够的。</p><ul><li><p>synchronized可阻止并发更新同一个共享资源，实现了同步;</p></li><li><p>synchronized不能用来实现不同线程之间的消息传递(通信)。</p></li></ul></li><li><p>那线程是通过哪些方法来进行消息传递(通信)的呢?见如下总结：<br><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834264259529.jpg" alt=""></p></li></ol><ol start="6"><li>以上方法均是java.lang.Object类的方法;</li></ol><p>都只能在同步方法或者同步代码块中使用，否则会抛出异常。</p><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>通过Timer和Timetask，我们可以实现定时启动某个线程。</p><ul><li>java.util.Timer</li></ul><p>在这种实现方式中，Timer类作用是类似闹钟的功能，也就是定时或者每隔一定时间触发一次线程。其实，Timer类本身实现的就是一个线程，只是这个线程是用来实现调用其它线程的。</p><ul><li>java.util.TimerTask</li></ul><p>TimerTask类是一个抽象类，该类实现了Runnable接口，所以该类具备多线程的能力。</p><p>在这种实现方式中，通过继承TimerTask使该类获得多线程的能力，将需要多线程执行的代码书写在run方法内部，然后通过Timer类启动线程的执行。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ol><li><p>程序：Java源程序和字节码文件被称为“程序(Program)”，是一个静态的概念。</p></li><li><p>进程：执行中的程序叫做进程(Process)，是一个动态的概念。每个进程由3部分组成：cpu、data、code。</p></li><li><p>线程：是进程中一个“单一的连续控制流程 (a single sequential flow of control)”。</p></li><li><p>在Java中实现多线程的方式：</p><p> ▪ 继承Thread类实现多线程</p><p> ▪ 实现Runnable接口实现多线程</p></li><li><p>线程的状态：</p><p>▪ 新生状态</p><p>▪ 就绪状态</p><p>▪ 运行状态</p><p>▪ 死亡状态</p><p>▪ 阻塞状态</p></li><li><p>暂停线程执行的方法:</p><p>▪ sleep()</p><p>▪ yield()</p><p>▪ join()</p></li><li><p>实现线程同步的两种方式：</p><p>▪ synchronized 方法 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">accessVal</span><span class="params">(<span class="keyword">int</span> newVal)</span></span>;</span><br></pre></td></tr></table></figure><p>▪ synchronized 块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(syncObject)</span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">//允许访问控制的代码 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同步解决问题的另一种典型方式：生产者/消费者模式。</p></li><li><p>线程通信的方法：</p><p>▪ wait()</p><p>▪  notify()</p><p>▪ notifyAll()</p><p>都是Object类的方法，只能在同步方法和同步代码块中使用。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h2&gt;&lt;p&gt;多线程是Java语言的重要特性，大量应用于网络编程、服务器端程序的开发，最常见的UI界面底层原理、操作系统底层原理都大量使用
      
    
    </summary>
    
    
    
      <category term="java学习笔记" scheme="http://www.sumulige.com/tags/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记-数组（三）</title>
    <link href="http://www.sumulige.com/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://www.sumulige.com/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2020-03-05T18:12:41.000Z</published>
    <updated>2020-03-05T19:00:25.718Z</updated>
    
    <content type="html"><![CDATA[<p>标签: 在计算机科学中，数组数据结构（英语：array data structure），简称数组（英语：Array），是由相同类型的元素（element）的集合所组成的数据结构，分配一块连续的内存来存储。利用元素的索引（index）可以计算出该元素对应的存储地址。</p><hr><h2 id="数组定义："><a href="#数组定义：" class="headerlink" title="数组定义："></a>数组定义：</h2><ul><li>Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组对象本身是在堆中存储的。</li></ul><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><ul><li>声明时并没有实例化任何对象，只有实例化数组对象时，jvm才分配内存</li><li>声明数组的时候并没有真正创建数组</li><li>构造指定长度</li></ul><h2 id="数组的初始化："><a href="#数组的初始化：" class="headerlink" title="数组的初始化："></a>数组的初始化：</h2><h3 id="i-静态初始化"><a href="#i-静态初始化" class="headerlink" title="i. 静态初始化"></a>i. 静态初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态初始化基本类型</span></span><br><span class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//静态初始化引用类型的数组初始化</span></span><br><span class="line"><span class="keyword">int</span> array2 = &#123;<span class="keyword">new</span> Man(<span class="number">1</span>,<span class="number">2</span>),<span class="keyword">new</span> Man(<span class="number">2</span>,<span class="number">3</span>)&#125;</span><br></pre></td></tr></table></figure><h3 id="ii-动态初始化"><a href="#ii-动态初始化" class="headerlink" title="ii. 动态初始化"></a>ii. 动态初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先分配空间</span></span><br><span class="line"><span class="keyword">int</span>[] array3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//再给数组元素赋值</span></span><br><span class="line"><span class="keyword">int</span>[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>[<span class="number">1</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h3 id="iii-默认初始化"><a href="#iii-默认初始化" class="headerlink" title="iii. 默认初始化"></a>iii. 默认初始化</h3><p>数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array4 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]<span class="comment">//默认0；</span></span><br><span class="line"><span class="keyword">boolean</span>[] b = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>];<span class="comment">//默认false</span></span><br><span class="line">String[] str = <span class="keyword">new</span> String[<span class="number">3</span>];<span class="comment">//默认为null</span></span><br></pre></td></tr></table></figure><h2 id="数组的foreach循环（注意事项）："><a href="#数组的foreach循环（注意事项）：" class="headerlink" title="数组的foreach循环（注意事项）："></a>数组的foreach循环（注意事项）：</h2><ul><li>增强for不能在遍历过程中修改元素的值</li><li>不涉及到数组元素的索引操作</li></ul><h2 id="数组的拷贝："><a href="#数组的拷贝：" class="headerlink" title="数组的拷贝："></a>数组的拷贝：</h2><p>System类里也包含了一个static void arraycopy(object src，int srcpos，object dest， int destpos，int length)方法，该方法可以将src数组里的元素值赋给dest数组的元素，其中srcpos指定从src数组的第几个元素开始赋值，length参数指定将src数组的多少个元素赋给dest数组的元素。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;标签: 在计算机科学中，数组数据结构（英语：array data structure），简称数组（英语：Array），是由相同类型的元素（element）的集合所组成的数据结构，分配一块连续的内存来存储。利用元素的索引（index）可以计算出该元素对应的存储地址。&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="java学习笔记" scheme="http://www.sumulige.com/tags/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记-基础算法（七）</title>
    <link href="http://www.sumulige.com/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <id>http://www.sumulige.com/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89/</id>
    <published>2020-03-05T18:12:41.000Z</published>
    <updated>2020-03-05T18:59:25.126Z</updated>
    
    <content type="html"><![CDATA[<p>标签：自己复习过程中先整理了遇到的，日后再补充。</p><hr><h2 id="冒泡排序（一）；"><a href="#冒泡排序（一）；" class="headerlink" title="冒泡排序（一）；"></a>冒泡排序（一）；</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleSort</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        doubleSort(ints);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doubleSort</span><span class="params">(<span class="keyword">int</span>[] vlaue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;value.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>;j&lt;value.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(value[j+<span class="number">1</span>]&lt;value[j])&#123;</span><br><span class="line">                    temp = value[j];</span><br><span class="line">                    value[j] = value[j+<span class="number">1</span>];</span><br><span class="line">                    value[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找："><a href="#二分查找：" class="headerlink" title="二分查找："></a>二分查找：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ints = &#123;<span class="number">9</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> searchWord = <span class="number">6</span>;</span><br><span class="line">        Arrays.sort(ints);</span><br><span class="line">        Arrays.toString(ints);</span><br><span class="line">        System.out.println(<span class="string">"查找元素的索引是："</span>+binarySearch(ints,searchWord));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> high = array.length-<span class="number">1</span>;</span><br><span class="line">        whille(low &gt;= high)&#123;</span><br><span class="line">            <span class="comment">//写成（low+high）/2会数组越界导致内存溢出</span></span><br><span class="line">            <span class="keyword">int</span> middle = low + (high -low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(value == array[middle])&#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(value &gt; array[middle])&#123;</span><br><span class="line">                low = middle +<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(value &lt; array[middle])&#123;</span><br><span class="line">                high = midddle -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组逆序："><a href="#数组逆序：" class="headerlink" title="数组逆序："></a>数组逆序：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints = &#123;<span class="number">0</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        Arrays.toString(ints);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)ints.length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = ints[i];</span><br><span class="line">            ints[ints.length-i-<span class="number">1</span>] = ints[i];</span><br><span class="line">            ints[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:ints)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用递归算法，以树状结构展示目录树"><a href="#使用递归算法，以树状结构展示目录树" class="headerlink" title="使用递归算法，以树状结构展示目录树"></a>使用递归算法，以树状结构展示目录树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">PrintFile</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//录入文件夹名称</span></span><br><span class="line">        File file = <span class="keyword">new</span> file(<span class="string">"willem"</span>)</span><br><span class="line">        <span class="comment">//调用遍历打印目录树的方法</span></span><br><span class="line">        printFile(file,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFile</span><span class="params">(File file,<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="comment">//遍历层次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;level;i++)&#123;</span><br><span class="line">            System.out.print(<span class="string">"-"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出文件名称</span></span><br><span class="line">        System.out.println(file.getName());</span><br><span class="line">        <span class="comment">//声明存放File[]</span></span><br><span class="line">        <span class="keyword">if</span>(file.isDirectory())&#123;</span><br><span class="line">            File[] file = file.listFiles();</span><br><span class="line">            <span class="keyword">for</span>(File file1 : file)&#123;</span><br><span class="line">                <span class="comment">///递归调用该方法：注意层级+1</span></span><br><span class="line">                printFile(file1,level+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;标签：自己复习过程中先整理了遇到的，日后再补充。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;冒泡排序（一）；&quot;&gt;&lt;a href=&quot;#冒泡排序（一）；&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序（一）；&quot;&gt;&lt;/a&gt;冒泡排序（一）；&lt;/h2&gt;&lt;figure clas
      
    
    </summary>
    
    
    
      <category term="java学习笔记" scheme="http://www.sumulige.com/tags/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记-常用类（四）</title>
    <link href="http://www.sumulige.com/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%B8%B8%E7%94%A8%E7%B1%BB%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://www.sumulige.com/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%B8%B8%E7%94%A8%E7%B1%BB%EF%BC%88%E5%9B%9B%EF%BC%89/</id>
    <published>2020-03-05T18:12:41.000Z</published>
    <updated>2020-03-05T19:54:50.113Z</updated>
    
    <content type="html"><![CDATA[<p>标签：方便以后更新</p><hr><h2 id="包装类型："><a href="#包装类型：" class="headerlink" title="包装类型："></a>包装类型：</h2><ul><li>在这八个类中，除了Character和Boolean以外，其他的都是“数字型”，“数字型”都是java.lang.Number的子类。</li><li>Number类是抽象类，因此它的抽象方法，所有子类都需要提供实现。Number类提供了抽象方法：intValue()、longValue()、floatValue()、doubleValue()，意味着所有的“数字型”包装类都可以互相转型。如图所示。<br><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834279026005.jpg" alt=""></li></ul><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834279117963.jpg" alt=""></p><h2 id="Stringbuffer和StringBuilder："><a href="#Stringbuffer和StringBuilder：" class="headerlink" title="Stringbuffer和StringBuilder："></a>Stringbuffer和StringBuilder：</h2><ul><li><p>方法 public StringBuilder reverse()</p><p><strong>用于将字符序列逆序，仍然返回自身对象。</strong></p></li></ul><h2 id="String和StringBuffer和StringBuilder"><a href="#String和StringBuffer和StringBuilder" class="headerlink" title="String和StringBuffer和StringBuilder"></a>String和StringBuffer和StringBuilder</h2><ol><li><p>String：不可变字符序列。</p></li><li><p>StringBuffer：可变字符序列，并且线程安全，但是效率低。</p></li><li><p>StringBuilder：可变字符序列，线程不安全，但是效率高(一般用它)。</p></li></ol><h2 id="这个“时刻数值”是所有时间类的核心值，年月日都是根据这个“数值”计算出来的。我们工作学习涉及的时间相关类有如下这些："><a href="#这个“时刻数值”是所有时间类的核心值，年月日都是根据这个“数值”计算出来的。我们工作学习涉及的时间相关类有如下这些：" class="headerlink" title="这个“时刻数值”是所有时间类的核心值，年月日都是根据这个“数值”计算出来的。我们工作学习涉及的时间相关类有如下这些："></a>这个“时刻数值”是所有时间类的核心值，年月日都是根据这个“数值”计算出来的。我们工作学习涉及的时间相关类有如下这些：</h2><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834279247456.jpg" alt=""></p><h2 id="Math类的常用方法："><a href="#Math类的常用方法：" class="headerlink" title="Math类的常用方法："></a>Math类的常用方法：</h2><ol><li><p>abs 绝对值</p></li><li><p>acos,asin,atan,cos,sin,tan 三角函数</p></li><li><p>sqrt 平方根</p></li><li><p>pow(double a, double b) a的b次幂</p></li><li><p>max(double a, double b) 取大值</p></li><li><p>min(double a, double b) 取小值</p></li><li><p>ceil(double a) 大于a的最小整数</p></li><li><p>floor(double a) 小于a的最大整数</p></li><li><p>random() 返回 0.0 到 1.0 的随机数</p></li><li><p>long round(double a) double型的数据a转换为long型(四舍五入)</p></li><li><p>toDegrees(double angrad) 弧度-&gt;角度</p></li><li><p>toRadians(double angdeg) 角度-&gt;弧度</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;标签：方便以后更新&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;包装类型：&quot;&gt;&lt;a href=&quot;#包装类型：&quot; class=&quot;headerlink&quot; title=&quot;包装类型：&quot;&gt;&lt;/a&gt;包装类型：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在这八个类中，除了Character和Boolean以外，其
      
    
    </summary>
    
    
    
      <category term="java学习笔记" scheme="http://www.sumulige.com/tags/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记-泛型（九）</title>
    <link href="http://www.sumulige.com/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%B3%9B%E5%9E%8B%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
    <id>http://www.sumulige.com/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%B3%9B%E5%9E%8B%EF%BC%88%E4%B9%9D%EF%BC%89/</id>
    <published>2020-03-05T18:12:41.000Z</published>
    <updated>2020-03-05T18:36:50.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h2><p>泛型是JDK1.5以后增加的，它可以帮助我们建立类型安全的集合。在使用了泛型的集合中，遍历时不必进行强制类型转换。JDK提供了支持泛型的编译器，将运行时的类型检查提前到了编译时执行，提高了代码可读性和安全性。</p><p>泛型的本质就是“数据类型的参数化”。 我们可以把“泛型”理解为数据类型的一个占位符(形式参数)，即告诉编译器，在调用泛型时必须传入实际类型。</p><h2 id="容器使用泛型"><a href="#容器使用泛型" class="headerlink" title="容器使用泛型"></a>容器使用泛型</h2><p>使用容器类时都要使用泛型。这样，在容器的存储数据、读取数据时都避免了大量的类型判断，非常便捷。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;优缺点：&quot;&gt;&lt;a href=&quot;#优缺点：&quot; class=&quot;headerlink&quot; title=&quot;优缺点：&quot;&gt;&lt;/a&gt;优缺点：&lt;/h2&gt;&lt;p&gt;泛型是JDK1.5以后增加的，它可以帮助我们建立类型安全的集合。在使用了泛型的集合中，遍历时不必进行强制类型转换。JDK提供
      
    
    </summary>
    
    
    
      <category term="java学习笔记" scheme="http://www.sumulige.com/tags/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记-网络编程（八）</title>
    <link href="http://www.sumulige.com/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E5%85%AB%EF%BC%89/"/>
    <id>http://www.sumulige.com/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E5%85%AB%EF%BC%89/</id>
    <published>2020-03-05T18:12:41.000Z</published>
    <updated>2020-03-05T19:55:53.060Z</updated>
    
    <content type="html"><![CDATA[<p>标签：学习各种网络协议的桥梁</p><hr><h2 id="什么是计算机网络"><a href="#什么是计算机网络" class="headerlink" title="什么是计算机网络"></a>什么是计算机网络</h2><ul><li><p>计算机网络的作用：资源共享和信息传递。</p></li><li><p>计算机网络的组成：</p><p>  a) 计算机硬件：计算机(大中小型服务器，台式机、笔记本等)、外部设备(路由器、交换机等)、通信线路(双绞线、光纤等)。</p><p>   b) 计算机软件：网络操作系统(Windows 2000 Server/Advance Server、Unix、Linux等)、网络管理软件(WorkWin、SugarNMS等)、网络通信协议(如TCP/IP协议栈等)。</p></li><li><p>计算机网络的多台计算机是具有独立功能的，而不是脱离网络就无法存在的。</p></li></ul><h2 id="什么是网络通信协议"><a href="#什么是网络通信协议" class="headerlink" title="什么是网络通信协议?"></a>什么是网络通信协议?</h2><ul><li><p>通过计算机网络可以实现不同计算机之间的连接与通信，但是计算机网络中实现通信必须有一些约定即通信协议，对速率、传输代码、代码结构、传输控制步骤、出错控制等制定标准。就像两个人想要顺利沟通就必须使用同一种语言一样，如果一个人只懂英语而另外一个人只懂中文，这样就会造成没有共同语言而无法沟通。</p></li><li><p>国际标准化组织(ISO，即International Organization for Standardization)定义了网络通信协议的基本框架，被称为OSI(Open System Interconnect，即开放系统互联)模型。要制定通讯规则，内容会很多，比如要考虑A电脑如何找到B电脑，A电脑在发送信息给B电脑时是否需要B电脑进行反馈，A电脑传送给B电脑的数据格式又是怎样的?内容太多太杂，所以OSI模型将这些通讯标准进行层次划分，每一层次解决一个类别的问题，这样就使得标准的制定没那么复杂。OSI模型制定的七层标准模型，分别是：应用层，表示层，会话层，传输层，网络层，数据链路层，物理层。</p></li><li><p>OSI七层协议模型如图12-1所示：<br><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834275891545.jpg" alt=""></p></li><li><p>虽然国际标准化组织制定了这样一个网络通信协议的模型，但是实际上互联网通讯使用最多的网络通信协议是TCP/IP网络通信协议。</p></li><li><p>TCP/IP 是一个协议族，也是按照层次划分，共四层：应用层，传输层，互连网络层，网络接口层(物理+数据链路层)。</p></li><li><p>那么TCP/IP协议和OSI模型有什么区别呢?OSI网络通信协议模型，是一个参考模型，而TCP/IP协议是事实上的标准。TCP/IP协议参考了OSI 模型，但是并没有严格按照OSI规定的七层标准去划分，而只划分了四层，这样会更简单点，当划分太多层次时，你很难区分某个协议是属于哪个层次的。TCP/IP协议和OSI模型也并不冲突，TCP/IP协议中的应用层协议，就对应于OSI中的应用层，表示层，会话层。就像以前有工业部和信息产业部，现在实行大部制后只有工业和信息化部一个部门，但是这个部门还是要做以前两个部门一样多的事情，本质上没有多大的差别。TCP/IP中有两个重要的协议，传输层的TCP协议和互连网络层的IP协议，因此就拿这两个协议做代表，来命名整个协议族了，再说TCP/IP协议时，是指整个协议族。</p></li></ul><p>3、网络协议的分层<br> 由于网络结点之间联系很复杂，在制定协议时，把复杂成份分解成一些简单的成份，再将它们复合起来。最常用的复合方式是层次方式，即同层间可以通信、上一层可以调用下一层，而与再下一层不发生关系。</p><p>把用户应用程序作为最高层，把物理通信线路作为最低层，将其间的协议处理分为若干层，规定每层处理的任务，也规定每层的接口标准。</p><p>ISO模型与TCP/IP模型的对应关系如图12-2所示。<br><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834276249790.jpg" alt=""></p><h2 id="数据封装与解封"><a href="#数据封装与解封" class="headerlink" title="数据封装与解封"></a>数据封装与解封</h2><ul><li><p>由于用户传输的数据一般都比较大，有的可以达到MB字节，一次性发送出去十分困难，于是就需要把数据分成许多片段，再按照一定的次序发送出去。这个过程就需要对数据进行封装。</p></li><li><p>数据封装(Data Encapsulation)是指将协议数据单元(PDU)封装在一组协议头和协议尾中的过程。在OSI七层参考模型中，每层主要负责与其它机器上的对等层进行通信。该过程是在协议数据单元(PDU)中实现的，其中每层的PDU一般由本层的协议头、协议尾和数据封装构成。</p></li></ul><p>1.数据发送处理过程</p><p>  (1). 应用层将数据交给传输层，传输层添加上TCP的控制信息(称为TCP头部)，这个数据单元称为段(Segment)，加入控制信息的过程称为封装。然后，将段交给网络层。</p><p>  (2). 网络层接收到段，再添加上IP头部，这个数据单元称为包(Packet)。然后，将包交给数据链路层。</p><p>  (3). 数据链路层接收到包，再添加上MAC头部和尾部，这个数据单元称为帧(Frame)。然后，将帧交给物理层。</p><p>  (4). 物理层将接收到的数据转化为比特流，然后在网线中传送。</p><p>2.数据接收处理过程</p><p> (1). 物理层接收到比特流，经过处理后将数据交给数据链路层。</p><p> (2).数据链路层将接收到的数据转化为数据帧，再除去MAC头部和尾部，这个除去控制信息的过程称为解封，然后将包交给网络层。</p><p> (3). 网络层接收到包，再除去IP头部，然后将段交给传输层。</p><p> (4). 传输层接收到段，再除去TCP头部，然后将数据交给应用层。</p><p>从以上传输过程中，可以总结出以下规则：</p><p><strong>(1)发送方数据处理的方式是从高层到底层，逐层进行数据封装。</strong><br><strong>(2)接收方数据处理的方式是从底层到高层，逐层进行数据解封装。</strong></p><ul><li><p>接收方的每一层只把对该层有意义的数据拿走，或者说每一层只能处理发送方同等层的数据，然后把其余的部分传递给上一层，这就是对等层通信的概念。</p></li><li><p>数据封装与解封如图12-3和图12-4所示：</p></li></ul><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834276356416.jpg" alt=""><br>![IMAGE](resources/37FFD7E71400C447445B917E6BEDDA67.jpg =597x337)</p><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834276429229.jpg" alt=""><br>![IMAGE](resources/4019FBA2E1345124776090871A55741E.jpg =597x321)</p><h2 id="IP地址："><a href="#IP地址：" class="headerlink" title="IP地址："></a>IP地址：</h2><ul><li><p>用来标识网络中的一个通信实体的地址。通信实体可以是计算机、路由器等。 比如互联网的每个服务器都要有自己的IP地址，而每个局域网的计算机要通信也要配置IP地址。路由器是连接两个或多个网络的网络设备。</p></li><li><p>目前主流使用的IP地址是IPV4，但是随着网络规模的不断扩大，IPV4面临着枯竭的危险，所以推出了IPV6。</p></li><li><p>IPV4：32位地址，并以8位为一个单位，分成四部分，以点分十进制表示，如192.168.0.1。因为8位二进制的计数范围是00000000—11111111，对应十进制的0-255，所以-4.278.4.1是错误的IPV4地址。</p></li><li><p>IPV6：128位(16个字节)写成8个16位的无符号整数，每个整数用四个十六进制位表示，每个数之间用冒号(：)分开，如：<br>3ffe:3201:1401:1280:c8ff:fe4d:db39:1984</p></li></ul><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><ul><li><p>IP地址用来标识一台计算机，但是一台计算机上可能提供多种网络应用程序，如何来区分这些不同的程序呢?这就要用到端口。</p></li><li><p>端口是虚拟的概念，并不是说在主机上真的有若干个端口。通过端口，可以在一个主机上运行多个网络应用程序。 端口的表示是一个16位的二进制整数，对应十进制的0-65535。</p></li><li><p>Oracle、MySQL、Tomcat、QQ、msn、迅雷、电驴、360等网络程序都有自己的端口。</p></li></ul><p>总结:</p><ol><li><p>IP地址好比每个人的地址(门牌号)，端口好比是房间号。必须同时指定IP地址和端口号才能够正确的发送数据。</p></li><li><p>IP地址好比为电话号码，而端口号就好比为分机号。</p></li></ol><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><ul><li><p>在www上，每一信息资源都有统一且唯一的地址，该地址就叫URL(Uniform Resource Locator)，它是www的统一资源定位符。URL由4部分组成：协议 、存放资源的主机域名、资源文件名和端口号。如果未指定该端口号，则使用协议默认的端口。例如http 协议的默认端口为 80。 在浏览器中访问网页时，地址栏显示的地址就是URL。</p></li><li><p>在java.net包中提供了URL类，该类封装了大量复杂的涉及从远程站点获取信息的细节。</p></li></ul><h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><ul><li><p>我们开发的网络应用程序位于应用层，TCP和UDP属于传输层协议，在应用层如何使用传输层的服务呢?在应用层和传输层之间，则是使用套接Socket来进行分离。</p></li><li><p>套接字就像是传输层为应用层开的一个小口，应用程序通过这个小口向远程发送数据，或者接收远程发来的数据;而这个小口以内，也就是数据进入这个口之后，或者数据从这个口出来之前，是不知道也不需要知道的，也不会关心它如何传输，这属于网络其它层次工作。</p></li><li><p>Socket实际是传输层供给应用层的编程接口。Socket就是应用层与传输层之间的桥梁。使用Socket编程可以开发客户机和服务器应用程序，可以在本地网络上进行通信，也可通过Internet在全球范围内通信。<br><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834276567842.jpg" alt=""><br>![IMAGE](resources/839E3920EF6819066074F4E53842DDA2.jpg =378x299)</p></li></ul><h2 id="TCP协议和UDP协议的联系和区别"><a href="#TCP协议和UDP协议的联系和区别" class="headerlink" title="TCP协议和UDP协议的联系和区别"></a>TCP协议和UDP协议的联系和区别</h2><ul><li><p>TCP协议和UDP协议是传输层的两种协议。Socket是传输层供给应用层的编程接口，所以Socket编程就分为TCP编程和UDP编程两类。</p></li><li><p>在网络通讯中，TCP方式就类似于拨打电话，使用该种方式进行网络通讯时，需要建立专门的虚拟连接，然后进行可靠的数据传输，如果数据发送失败，则客户端会自动重发该数据。而UDP方式就类似于发送短信，使用这种方式进行网络通讯时，不需要建立专门的虚拟连接，传输也不是很可靠，如果发送失败则客户端无法获得。</p></li><li><p>这两种传输方式都在实际的网络编程中使用，重要的数据一般使用TCP方式进行数据传输，而大量的非核心数据则可以通过UDP方式进行传递，在一些程序中甚至结合使用这两种方式进行数据传递。</p></li><li><p>由于TCP需要建立专用的虚拟连接以及确认传输是否正确，所以使用TCP方式的速度稍微慢一些，而且传输时产生的数据量要比UDP稍微大一些。</p></li></ul><p>总结</p><ol><li><p>TCP是面向连接的，传输数据安全，稳定，效率相对较低。</p></li><li><p>UDP是面向无连接的，传输数据不安全，效率较高。</p></li></ol><h2 id="Tcp协议"><a href="#Tcp协议" class="headerlink" title="Tcp协议"></a>Tcp协议</h2><p>TCP(Transfer Control Protocol)是面向连接的，所谓面向连接，就是当计算机双方通信时必需经过先建立连接，然后传送数据，最后拆除连接三个过程。</p><p>TCP在建立连接时又分三步走：</p><ul><li><p>第一步，是请求端(客户端)发送一个包含SYN即同步(Synchronize)标志的TCP报文，SYN同步报文会指明客户端使用的端口以及TCP连接的初始序号。</p></li><li><p>第二步，服务器在收到客户端的SYN报文后，将返回一个SYN+ACK的报文，表示客户端的请求被接受，同时TCP序号被加一，ACK即确认(Acknowledgement)。</p></li><li><p>第三步，客户端也返回一个确认报文ACK给服务器端，同样TCP序列号被加一，到此一个TCP连接完成。然后才开始通信的第二步：数据处理。</p></li></ul><p>这就是所说的TCP的三次握手(Three-way Handshake)。</p><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p>基于TCP协议可以建立稳定连接的点对点的通信。这种通信方式实时、快速、安全性高，但是很占用系统的资源。</p><p><strong>在网络传输方式上，还有另一种基于UDP协议的通信方式，称为数据报通信方式。在这种方式中，每个数据发送单元被统一封装成数据报包的方式，发送方将数据报包发送到网络中，数据报包在网络中去寻找它的目的地。</strong></p><h2 id="Java网络编程"><a href="#Java网络编程" class="headerlink" title="Java网络编程"></a>Java网络编程</h2><p>Java为了可移植性，不允许直接调用操作系统，而是由java.net包来提供网络功能。Java虚拟机负责提供与操作系统的实际连接。下面我们来介绍几个java.net包中的常用的类。</p><h2 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h2><p>作用：封装计算机的IP地址和DNS(没有端口信息)。</p><blockquote><p>注：DNS是Domain Name System，域名系统。</p></blockquote><ul><li>特点：这个类没有构造方法。如果要得到对象，只能通过静态方法：getLocalHost()、getByName()、 getAllByName()、 getAddress()、getHostName()。</li></ul><h2 id="InetSocketAddress"><a href="#InetSocketAddress" class="headerlink" title="InetSocketAddress"></a>InetSocketAddress</h2><p>作用：包含IP和端口信息，常用于Socket通信。此类实现 IP 套接字地址(IP 地址 + 端口号)，不依赖任何协议。</p><h2 id="URL-1"><a href="#URL-1" class="headerlink" title="URL"></a>URL</h2><ul><li><p>IP地址唯一标识了Internet上的计算机，而URL则标识了这些计算机上的资源。类 URL 代表一个统一资源定位符，它是指向互联网“资源”的指针。资源可以是简单的文件或目录，也可以是对更为复杂的对象的引用，例如对数据库或搜索引擎的查询。</p></li><li><p>为了方便程序员编程，JDK中提供了URL类，该类的全名是java.net.URL，有了这样一个类，就可以使用它的各种方法来对URL对象进行分割、合并等处理。</p></li></ul><h2 id="基于TCP协议的Socket编程和通信"><a href="#基于TCP协议的Socket编程和通信" class="headerlink" title="基于TCP协议的Socket编程和通信"></a>基于TCP协议的Socket编程和通信</h2><ul><li>在网络通讯中，第一次主动发起通讯的程序被称作客户端(Client)程序，简称客户端，而在第一次通讯中等待连接的程序被称作服务器端(Server)程序，简称服务器。一旦通讯建立，则客户端和服务器端完全一样，没有本质的区别。</li></ul><p>“请求-响应”模式：</p><ol><li><p>Socket类：发送TCP消息。</p></li><li><p>ServerSocket类：创建服务器。</p></li><li><p>套接字是一种进程间的数据交换机制。这些进程既可以在同一机器上，也可以在通过网络连接的不同机器上。换句话说，套接字起到通信端点的作用。单个套接字是一个端点，而一对套接字则构成一个双向通信信道，使非关联进程可以在本地或通过网络进行数据交换。一旦建立套接字连接，数据即可在相同或不同的系统中双向或单向发送，直到其中一个端点关闭连接。套接字与主机地址和端口地址相关联。主机地址就是客户端或服务器程序所在的主机的IP地址。端口地址是指客户端或服务器程序使用的主机的通信端口。</p></li></ol><ul><li><p>在客户端和服务器中，分别创建独立的Socket，并通过Socket的属性，将两个Socket进行连接，这样，客户端和服务器通过套接字所建立的连接使用输入输出流进行通信。</p></li><li><p>TCP/IP套接字是最可靠的双向流协议，使用TCP/IP可以发送任意数量的数据。</p></li><li><p>实际上，套接字只是计算机上已编号的端口。如果发送方和接收方计算机确定好端口，他们就可以通信了。</p></li><li><p>如图12-6所示为客户端与服务器端的通信关系图：<br><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834276781065.jpg" alt=""></p></li></ul><p>TCP/IP通信连接的简单过程：</p><ul><li><p>位于A计算机上的TCP/IP软件向B计算机发送包含端口号的消息，B计算机的TCP/IP软件接收该消息，并进行检查，查看是否有它知道的程序正在该端口上接收消息。如果有，他就将该消息交给这个程序。</p></li><li><p>要使程序有效地运行，就必须有一个客户端和一个服务器。<br>通过Socket的编程顺序：</p></li></ul><ol><li><p>创建服务器ServerSocket，在创建时，定义ServerSocket的监听端口(在这个端口接收客户端发来的消息)。</p></li><li><p>ServerSocket调用accept()方法，使之处于阻塞状态。</p></li><li><p>创建客户端Socket，并设置服务器的IP及端口。</p></li><li><p>客户端发出连接请求，建立连接。</p></li><li><p>分别取得服务器和客户端Socket的InputStream和OutputStream。</p></li><li><p>利用Socket和ServerSocket进行数据传输。</p></li><li><p>关闭流及Socket。</p></li></ol><p>TCP：单向通信Socket之服务器端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最简单的服务器端代码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicSocketServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        BufferedWriter bw = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 建立服务器端套接字：指定监听的接口</span></span><br><span class="line">            ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">            System.out.println(<span class="string">"服务端建立监听"</span>);</span><br><span class="line">            <span class="comment">// 监听，等待客户端请求，并愿意接收连接</span></span><br><span class="line">            socket = serverSocket.accept();</span><br><span class="line">            <span class="comment">// 获取socket的输出流，并使用缓冲流进行包装</span></span><br><span class="line">            bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span>     </span><br><span class="line">                                    OutputStreamWriter(socket.getOutputStream()));</span><br><span class="line">            <span class="comment">// 向客户端发送反馈信息</span></span><br><span class="line">            bw.write(<span class="string">"hhhh"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭流及socket连接</span></span><br><span class="line">            <span class="keyword">if</span> (bw != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bw.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TCP：单向通信Socket之客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最简单的Socket客户端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicSocketClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 创建Scoket对象：指定要连接的服务器的IP和端口而不是自己机器的</span></span><br><span class="line"><span class="comment">             * 端口。发送端口是随机的。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            socket = <span class="keyword">new</span> Socket(InetAddress.getLocalHost(), <span class="number">8888</span>);</span><br><span class="line">            <span class="comment">//获取scoket的输入流，并使用缓冲流进行包装</span></span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span>  </span><br><span class="line">                                   InputStreamReader(socket.getInputStream()));</span><br><span class="line">            <span class="comment">//接收服务器端发送的信息</span></span><br><span class="line">            System.out.println(br.readLine());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭流及socket连接</span></span><br><span class="line">            <span class="keyword">if</span> (br != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TCP：双向通信Socket之服务器端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader in = <span class="keyword">null</span>;</span><br><span class="line">        BufferedWriter out = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务器端套接字：指定监听端口</span></span><br><span class="line">            ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">            <span class="comment">//监听客户端的连接</span></span><br><span class="line">            socket = server.accept();</span><br><span class="line">            <span class="comment">//获取socket的输入输出流接收和发送信息</span></span><br><span class="line">            in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">            out = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> </span><br><span class="line">                                   OutputStreamWriter(socket.getOutputStream()));</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//接收客户端发送的信息</span></span><br><span class="line">                String str = in.readLine();</span><br><span class="line">                System.out.println(<span class="string">"客户端说："</span> + str);</span><br><span class="line">                String str2 = <span class="string">""</span>;</span><br><span class="line">                <span class="comment">//如果客户端发送的是“end”则终止连接 </span></span><br><span class="line">                <span class="keyword">if</span> (str.equals(<span class="string">"end"</span>))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//否则，发送反馈信息</span></span><br><span class="line">                str2 = br.readLine(); <span class="comment">// 读到\n为止，因此一定要输入换行符！</span></span><br><span class="line">                out.write(str2 + <span class="string">"\n"</span>);</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭资源</span></span><br><span class="line">            <span class="keyword">if</span>(in != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(out != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(br != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TCP：双向通信Socket之客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader in = <span class="keyword">null</span>;</span><br><span class="line">        BufferedWriter out = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader wt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建Socket对象，指定服务器端的IP与端口</span></span><br><span class="line">            socket = <span class="keyword">new</span> Socket(InetAddress.getLocalHost(), <span class="number">8888</span>);</span><br><span class="line">            <span class="comment">//获取scoket的输入输出流接收和发送信息</span></span><br><span class="line">            in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">            out = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> </span><br><span class="line">                                   OutputStreamWriter(socket.getOutputStream()));</span><br><span class="line">            wt = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//发送信息</span></span><br><span class="line">                String str = wt.readLine();</span><br><span class="line">                out.write(str + <span class="string">"\n"</span>);</span><br><span class="line">                out.flush();</span><br><span class="line">                <span class="comment">//如果输入的信息为“end”则终止连接</span></span><br><span class="line">                <span class="keyword">if</span> (str.equals(<span class="string">"end"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//否则，接收并输出服务器端信息</span></span><br><span class="line">                System.out.println(<span class="string">"服务器端说："</span> + in.readLine());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭资源</span></span><br><span class="line">            <span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (wt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wt.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UDP通讯的实现"><a href="#UDP通讯的实现" class="headerlink" title="UDP通讯的实现"></a>UDP通讯的实现</h2><ul><li><p>DatagramSocket：用于发送或接收数据报包<br>当服务器要向客户端发送数据时，需要在服务器端产生一个DatagramSocket对象，在客户端产生一个DatagramSocket对象。服务器端的DatagramSocket将DatagramPacket发送到网络上，然后被客户端的DatagramSocket接收。</p></li><li><p>DatagramSocket有两种常用的构造函数。一种是无需任何参数的，常用于客户端;另一种需要指定端口，常用于服务器端。如下所示：</p></li><li><p>DatagramSocket() ：构造数据报套接字并将其绑定到本地主机上任何可用的端口。</p></li><li><p>DatagramSocket(int port) ：创建数据报套接字并将其绑定到本地主机上的指定端口。<br>常用方法：</p></li><li><p>send(DatagramPacket p) ：从此套接字发送数据报包。</p></li></ul><p>Ø receive(DatagramPacket p) ：从此套接字接收数据报包。</p><p>Ø close() ：关闭此数据报套接字。</p><p>▪ DatagramPacket：数据容器(封包)的作用<br> 此类表示数据报包。 数据报包用来实现封包的功能。<br>常用方法：</p><p>  Ø DatagramPacket(byte[] buf, int length) ：构造数据报包，用来接收长度为 length 的数据包。</p><p>  Ø DatagramPacket(byte[] buf, int length, InetAddress address, int port) ：构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。</p><p>  Ø getAddress() ：获取发送或接收方计算机的IP地址，此数据报将要发往该机器或者是从该机器接收到的。</p><p>  Ø getData() ：获取发送或接收的数据。</p><p>  Ø setData(byte[] buf) ：设置发送的数据。</p><p>UDP通信编程基本步骤：</p><p>1.创建客户端的DatagramSocket，创建时，定义客户端的监听端口。</p><ol start="2"><li><p>创建服务器端的DatagramSocket，创建时，定义服务器端的监听端口。</p></li><li><p>在服务器端定义DatagramPacket对象，封装待发送的数据包。</p></li><li><p>客户端将数据报包发送出去。</p></li><li><p>服务器端接收数据报包。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>端口是虚拟的概念，并不是说在主机上真的有若干个端口。</p></li><li><p>在www上，每一信息资源都有统一且唯一的地址，该地址就叫URL(Uniform Resource Locator)，它是www的统一资源定位符。</p></li><li><p>TCP与UDP的区别</p><p>   1）TCP是面向连接的，传输数据安全，稳定，效率相对较低。</p><p>   2）UDP是面向无连接的，传输数据不安全，效率较高。</p></li><li><p>Socket通信是一种基于TCP协议，建立稳定连接的点对点的通信。</p></li><li><p>网络编程是由java.net包来提供网络功能。</p><p>   1）InetAddress：封装计算机的IP地址和DNS(没有端口信息!)。</p><p>   2）InetSocketAddress：包含IP和端口，常用于Socket通信。</p><p>   3）URL：以使用它的各种方法来对URL对象进行分割、合并等处理。</p></li><li><p>基于TCP协议的Socket编程和通信</p><p>   1）“请求-响应”模式：</p><p>   –Socket类：发送TCP消息。</p><p>   –ServerSocket类：创建服务器。</p></li><li><p>UDP通讯的实现</p><p>   1）DatagramSocket：用于发送或接收数据报包。</p><p>   2）常用方法：send()、receive()、 close()。</p></li><li><p>DatagramPacket：数据容器(封包)的作用</p><p>   1）常用方法：构造方法、getAddrress(获取发送或接收方计算机的IP地址)、getData(获取发送或接收的数据)、setData(设置发送的数据)。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;标签：学习各种网络协议的桥梁&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;什么是计算机网络&quot;&gt;&lt;a href=&quot;#什么是计算机网络&quot; class=&quot;headerlink&quot; title=&quot;什么是计算机网络&quot;&gt;&lt;/a&gt;什么是计算机网络&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;计算机网络的作用：资
      
    
    </summary>
    
    
    
      <category term="java学习笔记" scheme="http://www.sumulige.com/tags/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记-集合（五）</title>
    <link href="http://www.sumulige.com/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%9B%86%E5%90%88%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://www.sumulige.com/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%9B%86%E5%90%88%EF%BC%88%E4%BA%94%EF%BC%89/</id>
    <published>2020-03-05T18:12:41.000Z</published>
    <updated>2020-03-05T19:00:25.723Z</updated>
    
    <content type="html"><![CDATA[<p>标签：javase 核心容器，面试必问。</p><hr><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ul><li>底层实现是数组，查询快，增删慢，线程不安全。</li><li>我们知道，数组长度是有限的，而ArrayList是可以存放任意数量的对象，长度不受限制，那么它是怎么实现的呢?<br>1、本质上就是通过定义新的更大的数组，将旧数组中的内容拷贝到新数组，来实现扩容。<br>2、ArrayList的Object数组初始化长度为如果我们存储满了这个数组，需要存储第11个对象，就会定义新的长度更大的数组，并将原数组内容和新的元素一起加入到新数组中，源码如下：<br><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834265374205.jpg" alt=""></li></ul><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><ul><li>底层采用双向链表实现，增删块，查询慢，线程不安全<br><strong>双向链表也叫双链表，是链表的一种，它的每个数据节点中都有两个指针，分别指向前一个节点和后一个节点。 所以，从双向链表中的任意一个节点开始，都可以很方便地找到所有节点。</strong></li></ul><blockquote><p>注意事项：entry在英文中表示“进入、词条、条目”的意思。在计算机英语中一般表示“项、条目”的含义。</p></blockquote><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="HashTable和Hashmap区别"><a href="#HashTable和Hashmap区别" class="headerlink" title="HashTable和Hashmap区别"></a>HashTable和Hashmap区别</h3><ul><li>1、hashMap，线程不安全，效率高。允许k v为null</li><li>2、hashTable，线程安全，效率低，不允许k v为null</li></ul><h3 id="HashMap底层实现"><a href="#HashMap底层实现" class="headerlink" title="HashMap底层实现"></a>HashMap底层实现</h3><ul><li>底层实现是hash表</li><li>数据结构中以数组和链表实现存储<br>1、数组：占用空间连续。寻址容易，查询速度快。但是，增删速度慢。<br>2、链表：占用空间不连续。寻址困难，查询速度慢。但是，增删速度快。</li></ul><blockquote><p><strong>结合数组和链表的优点（增删快，查询块）—答案就是哈希表（哈希表的本质就是”数组”+”链表”）</strong></p></blockquote><h3 id="HashMap基本结构："><a href="#HashMap基本结构：" class="headerlink" title="HashMap基本结构："></a>HashMap基本结构：</h3><ul><li>我们打开HashMap源码，发现有如下两个核心内容：<br><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834265532460.jpg" alt=""></li></ul><ul><li>其中Entry[] table 就是hashmap核心的数组结构，也称之为”位桶数组”,其源码如下：<br><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834265670492.jpg" alt=""></li></ul><p>一个Entry对象存储了：<br> 1、hash：健对象的hash值<br> 2、key：健对象；value：值对象<br> 3、next：下一个节点的引用</p><ul><li>显然每一个entry对象都是一个单向链表结构，如下</li></ul><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834265822357.jpg" alt=""></p><ul><li>然后我们画出Entry[] 数组结构（也是HashMap结构）</li></ul><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834265956014.jpg" alt=""></p><h3 id="HashMap存储数据过程put-key-value-："><a href="#HashMap存储数据过程put-key-value-：" class="headerlink" title="HashMap存储数据过程put(key , value)："></a>HashMap存储数据过程put(key , value)：</h3><ul><li>核心是如何产生hash值，该值用来对应数组的存储位置。</li></ul><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834266082842.jpg" alt=""></p><ul><li><p>我们的目地是将”key-value”两个对象成对存放到HashMap的Entry[]数组中<br>1、获得key对象的hashcode<br>  调用key对象的hashcode(),生成hashcode<br>2、根据hashcode计算hash值（要求[0,数组长度-1)）<br>  hashcode是一个整数，我们需要将他转化为[0,数组长度-1)，要求转化后hash值尽量均匀的分布在[0,数组长度-1)这个区间，避免hash冲突。</p><ul><li><p>i. 一种极端简单和低下的算法是：<br>1、hash值 = hashcode/hashcode;<br>2、也就是说，hash值总是1。意味着，键值对对象都会存储到数组索引1位置，这样就形成一个非常长的链表。相当于每存储一个对象都会发生“hash冲突”，HashMap也退化成了一个“链表”。</p></li><li><p>ii. 一种简单和常用的算法是(相除取余算法)：<br>1、hash值 = hashcode%数组长度<br>2、这种算法可以让hash值均匀的分布在[0,数组长度-1]的区间。 早期的HashTable就是采用这种算法。但是，这种算法由于使用了“除法”，效率低下。JDK后来改进了算法。首先约定数组长度必须为2的整数幂，这样采用位运算即可实现取余的效果：hash值 = hashcode&amp;(数组长度-1)。</p></li><li><p>iii. 如下为我们自己测试简单的hash算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">25860399</span>;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">16</span>;<span class="comment">//length为2的整数次幂,则h&amp;(length-1)相当于对length取模</span></span><br><span class="line">        myHash(h, length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h  任意整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 长度必须为2的整数幂</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">myHash</span><span class="params">(<span class="keyword">int</span> h,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        System.out.println(h&amp;(length-<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//length为2的整数幂情况下，和取余的值一样</span></span><br><span class="line">        System.out.println(h%length);<span class="comment">//取余数</span></span><br><span class="line">        <span class="keyword">return</span> h&amp;(length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行如上程序，我们就能发现直接取余(h%length)和位运算(h&amp;(length-1))结果是一致的。事实上，为了获得更好的散列效果，JDK对hashcode进行了两次散列处理(核心目标就是为了分布更散更均匀)，源码如下：</p></li></ul><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834266386341.jpg" alt=""></p></li></ul><ul><li>3、生成Entry对象<br>  如上所述，一个Entry对象包括4部分：hash值、key对象、value对象、next（指向下一个Entry对象的引用）</li><li>4、将Entry对象放到table数组中<br>  如果本Entry对象对应的数组索引位置还没有放Entry对象，泽直接将Entry对象放入数组；如果对应索引位置已经有Entry对象，则将已有的Entry对象的next指向本Entry对象，形成链表。</li></ul><p>总结如下过程：</p><p><strong>当添加一个元素（key,value）时，首先计算key的hash值，依此确定插入数组中的位置，但是已经存在统一hash值的元素已经被放入数组同一位置了，这时就添加到同一hash值元素的后面，他们在数组的同一位置就形成了链表，同一个链表上的hash值是相同的，所以说数组存放的是链表。JDK8中，当链表长度大于8时，链表转化为红黑树，这样大大提高了查找效率。</strong></p><ul><li>HashMap取数据过程get(key)<br>1、我们需要通过key对象获取”健值对”对象，进而返回value对象。明白了存储数据过程，取数据比较简单了。<br>2、获得key的hashcode，通过hash散列算法得到hash值，进而定位到数组的位置。<br>3、在链表上挨个比较key对象。调用equals()方法，将key对象和链表上的所有节点的key对象进行比较，直到碰到返回true节点对象为止。<br>4、返回equals()为true的节点对象value对象<br>明白了存取cunqu数据的过程，我们再来看一下hashcode()和equals()的关系<br> <strong>Java中规定，两个内容相同(equals()为true)的对象必须具有相等的hashCode。因为如果equals()为true而两个对象的hashcode不同;那在整个存储过程中就发生了悖论。</strong></li></ul><h3 id="扩容问题："><a href="#扩容问题：" class="headerlink" title="扩容问题："></a>扩容问题：</h3><p>hashmap的位桶数组，初始大小为1&lt;&lt;4(16)。实际使用时，虽然大小可变。如果位桶数组中的元素达到（0.75* 数组length）就重新调整数组大小变为原来的两倍大小。</p><blockquote><p><strong>扩容很耗时。扩容的本质是定义新的更大数组，并将旧数组内容内容挨个拷贝到新数组中。</strong></p></blockquote><h3 id="JDk8将链表在大于8的情况下变为红黑树（红黑二叉树）"><a href="#JDk8将链表在大于8的情况下变为红黑树（红黑二叉树）" class="headerlink" title="JDk8将链表在大于8的情况下变为红黑树（红黑二叉树）"></a>JDk8将链表在大于8的情况下变为红黑树（红黑二叉树）</h3><p>JDK8中，HashMap在存储一个元素时，当对应链表长度大于8时，链表就转换为红黑树，这样又大大提高了查找的效率。</p><h3 id="TreeMap的使用和底层实现"><a href="#TreeMap的使用和底层实现" class="headerlink" title="TreeMap的使用和底层实现"></a>TreeMap的使用和底层实现</h3><ul><li>TreeMap是红黑二叉树的典型实现。我们打开TreeMap的源码，发现里面有一行核心代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li><li>root用来存储整个树的根节点。我们继续跟踪Entry(是TreeMap的内部类)的代码：<br><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834266793424.jpg" alt=""></li></ul><ul><li>可以看到里面存储了本身数据、左节点、右节点、父节点、以及节点颜色。 TreeMap的put()/remove()方法大量使用了红黑树的理论。本书限于篇幅，不再展开。需要了解更深入的，可以参考专门的数据结构书籍。<br>1、TreeMap和HashMap实现了同样的接口Map，因此，用法对于调用者来说没有区别。<br>2、HashMap效率高于TreeMap;<br>3、在需要排序的Map时才选用TreeMap。</li></ul><h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><ul><li><p>Set接口继承自Collection，Set接口中没有新增方法，方法和Collection保持完全一致。我们在前面通过List学习的方法，在Set中仍然适用。因此，学习Set的使用将没有任何难度。</p></li><li><p>Set容器特点：无序、不可重复。无序指Set中的元素没有索引，我们只能遍历查找;不可重复指不允许加入重复的元素。更确切地讲，新元素如果和Set中某个元素通过equals()方法对比为true，则不能加入;甚至，Set中也只能放入一个null元素，不能多个。</p></li><li><p>Set常用的实现类有：HashSet、TreeSet等，我们一般使用HashSet。</p></li></ul><h3 id="HashSet基本使用"><a href="#HashSet基本使用" class="headerlink" title="HashSet基本使用"></a>HashSet基本使用</h3><p>重点体会“设置是无序，不可重复”的核心要点。</p><h3 id="HashSet底层实现"><a href="#HashSet底层实现" class="headerlink" title="HashSet底层实现"></a>HashSet底层实现</h3><ul><li>HashSet是采用哈希算法实现，底层实际是用HashMap实现的(HashSet本质就是一个简化版的HashMap)，因此，查询效率和增删效率都比较高。我们来看一下HashSet的源码：<br><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834266950971.jpg" alt=""></li></ul><ul><li><p>我们发现里面有个map属性，这就是HashSet的核心秘密。我们再看add()方法，发现增加一个元素说白了就是在map中增加一个键值对，键对象就是这个元素，值对象是名为PRESENT的Object对象。说白了，就是“往set中加入元素，本质就是把这个元素作为key加入到了内部的map中”。</p></li><li><p>由于map中key都是不可重复的，因此，Set天然具有“不可重复”的特性。</p></li></ul><h3 id="TreeSet使用和底层实现"><a href="#TreeSet使用和底层实现" class="headerlink" title="TreeSet使用和底层实现"></a>TreeSet使用和底层实现</h3><ul><li><p>TreeSet底层实际是TreeMap实现的，内部维持了一个简化版的Treemap,通过key来存储Set元素。TreeSet内部实现元素排序，需要实现Comparable接口。这样，才能根据compareTo()方法比较对象之间的大小，才能进行内部类排序。</p></li><li><p>使用TreeSet要点：<br>(1) 由于是二叉树，需要对元素做内部排序。 如果要放入TreeSet中的类没有实现Comparable接口，则会抛出异常：java.lang.ClassCastException。<br>(2) TreeSet中不能放入null元素。</p></li></ul><h3 id="使用Iterator迭代器遍历容器元素-List-Set-Map-–如果遇到遍历容器时，判断删除元素的情况，使用迭代器遍历"><a href="#使用Iterator迭代器遍历容器元素-List-Set-Map-–如果遇到遍历容器时，判断删除元素的情况，使用迭代器遍历" class="headerlink" title="使用Iterator迭代器遍历容器元素(List/Set/Map)–如果遇到遍历容器时，判断删除元素的情况，使用迭代器遍历!"></a>使用Iterator迭代器遍历容器元素(List/Set/Map)–如果遇到遍历容器时，判断删除元素的情况，使用迭代器遍历!</h3><ul><li>迭代器遍历List<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIterator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            list.add(<span class="string">"ad"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//使用迭代器进行遍历</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hahNext())&#123;</span><br><span class="line">            String next = it.next();</span><br><span class="line">            <span class="keyword">if</span>(next.endWith(<span class="string">"3"</span>))&#123;</span><br><span class="line">                list.remove()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Man&gt; maps = <span class="keyword">new</span> HashMap&lt;Integer, Man&gt;();</span><br><span class="line">Set&lt;Integer&gt;  keySet =  maps.keySet();</span><br><span class="line"><span class="keyword">for</span>(Integer id : keySet)&#123;</span><br><span class="line">System.out.println(maps.get(id).name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Entry&lt;Integer, Man&gt;&gt;  ss = maps.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Iterator iterator = ss.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">    Entry e = (Entry) iterator.next(); </span><br><span class="line">    System.out.println(e.getKey()+<span class="string">"--"</span>+e.getValue());</span><br></pre></td></tr></table></figure><h3 id="如下情况，可能需要我们重写equals-hashCode方法："><a href="#如下情况，可能需要我们重写equals-hashCode方法：" class="headerlink" title="如下情况，可能需要我们重写equals/hashCode方法："></a>如下情况，可能需要我们重写equals/hashCode方法：</h3><p>1) 要将我们自定义的对象放入HashSet中处理。</p><p>2) 要将我们自定义的对象作为HashMap的key处理。</p><p>3) 放入Collection容器中的自定义对象后，可能会调用remove、contains等方法时。</p><h3 id="JDK1-5以后增加了泛型。泛型的好处："><a href="#JDK1-5以后增加了泛型。泛型的好处：" class="headerlink" title="JDK1.5以后增加了泛型。泛型的好处："></a>JDK1.5以后增加了泛型。泛型的好处：</h3><p>1) 向集合添加数据时保证数据安全。</p><p>2) 遍历集合元素时不需要强制转换。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;标签：javase 核心容器，面试必问。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;List&quot;&gt;&lt;a href=&quot;#List&quot; class=&quot;headerlink&quot; title=&quot;List&quot;&gt;&lt;/a&gt;List&lt;/h2&gt;&lt;h3 id=&quot;ArrayList&quot;&gt;&lt;a href=&quot;#Arr
      
    
    </summary>
    
    
    
      <category term="java学习笔记" scheme="http://www.sumulige.com/tags/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记-面向对象总结（二）</title>
    <link href="http://www.sumulige.com/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://www.sumulige.com/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-03-05T18:12:41.000Z</published>
    <updated>2020-03-05T19:03:57.042Z</updated>
    
    <content type="html"><![CDATA[<p>标签：核心总结</p><hr><blockquote><p>本人学习总结</p></blockquote><h2 id="this-本质"><a href="#this-本质" class="headerlink" title="this 本质"></a>this 本质</h2><ul><li>this的本质就是“创建好的对象的地址”! this不能用于static方法中。</li></ul><h2 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h2><ul><li>构造方法的作用是为创建对象进行初始化工作，比如给成员变量赋值</li><li>构造方法与类同名，不能书写返回值类型</li><li>构造方法的第一条语句如果是super()，则可以省略，该语句作用是调用父类无参数的构造方法</li><li>调用顺序：<ol><li>先向上追溯到Object，然后在依次向下执行类的初始化和构造方法，直到当前子类为止；</li><li>静态初始化块与上述相同；</li></ol></li></ul><h2 id="类方法："><a href="#类方法：" class="headerlink" title="类方法："></a>类方法：</h2><ul><li>在类方法中调用本类的类方法时可直接调用</li></ul><h2 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h2><ul><li>子类继承父类全部的属性和方法（除了父类的构造方法），但不见的子类可以访问父类的私有属性和方法。</li></ul><h2 id="重写："><a href="#重写：" class="headerlink" title="重写："></a>重写：</h2><ul><li>方法的重写：<br>1、“==” 同名同参<br>2、“&lt;=”返回值类型，声明异常，子类的要小于父类<br>3、”&gt;=”访问权限子类大于父等于父类</li></ul><h2 id="高内聚低耦合"><a href="#高内聚低耦合" class="headerlink" title="高内聚低耦合"></a>高内聚低耦合</h2><p>高内聚：类的内部操作细节自己完成，不允许外部干涉</p><p>低耦合：尽量避免暴露少的方法细节给外部使用，尽量方便外部调用</p><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834280014289.jpg" alt=""></p><h2 id="对象的转型"><a href="#对象的转型" class="headerlink" title="对象的转型"></a>对象的转型</h2><p>向上：（自动转型）</p><h2 id="fianl关键字作用："><a href="#fianl关键字作用：" class="headerlink" title="fianl关键字作用："></a>fianl关键字作用：</h2><ul><li>修饰变量不可修改</li><li>修饰方法不能重写，可以重载</li><li>修饰类，类不可以被继承</li></ul><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul><li>抽象类可以包括属性、方法、构造方法</li><li>抽象类只能被继承</li><li>必须被子类实现</li></ul><h2 id="为什么需要接口，接口和抽象类的区别"><a href="#为什么需要接口，接口和抽象类的区别" class="headerlink" title="为什么需要接口，接口和抽象类的区别"></a>为什么需要接口，接口和抽象类的区别</h2><ul><li><p>接口就是比“抽象类”还“抽象”的“抽象类”，可以更加规范的对子类进行约束。全面地专业地实现了：规范和具体实现的分离。</p></li><li><p>抽象类还提供某些具体实现，接口不提供任何实现，接口中所有方法都是抽象方法。接口是完全面向规范的，规定了一批类具有的公共方法规范。</p></li><li><p>从接口的实现者角度看，接口定义了可以向外部提供的服务。</p></li><li><p>接口是两个模块之间通信的标准，通信的规范。如果能把你要设计的模块之间的接口定义好，就相当于完成了系统的设计大纲，剩下的就是添砖加瓦的具体实现了。大家在工作以后，做系统时往往就是使用“面向接口”的思想来设计系统。</p></li><li><p>接口和实现类不是父子关系，是实现规则的关系。比如：我定义一个接口Runnable，Car实现它就能在地上跑，Train实现它也能在地上跑，飞机实现它也能在地上跑。就是说，如果它是交通工具，就一定能跑，但是一定要实现Runnable接口。</p></li></ul><h2 id="接口的本质："><a href="#接口的本质：" class="headerlink" title="接口的本质："></a>接口的本质：</h2><ul><li><p>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是…则必须能…”的思想。如果你是天使，则必须能飞。如果你是汽车，则必须能跑。如果你是好人，则必须能干掉坏人;如果你是坏人，则必须欺负好人。</p></li><li><p>接口的本质是契约，就像我们人间的法律一样。制定好后大家都遵守。</p></li><li><p>面向对象的精髓，是对对象的抽象，最能体现这一点的就是接口。为什么我们讨论设计模式都只针对具备了抽象能力的语言(比如C++、Java、C#等)，就是因为设计模式所研究的，实际上就是如何合理的去抽象。</p></li><li><p>接口和抽象类区别：<br>1、普通类：具体实现<br>2、抽象类：具体实现，规范（抽象方法）<br>3、接口：规范（契约）</p></li></ul><h2 id="定义接口的详细说明："><a href="#定义接口的详细说明：" class="headerlink" title="定义接口的详细说明："></a>定义接口的详细说明：</h2><ul><li>只能是public或者默认。</li><li>接口名：和类同级。</li><li>extends：可以多继承</li><li>常量：接口中的属性只能是常量，总之是public static final 修饰，不写也是。</li><li>方法：接口中的方法只能是public abstract，省略的话，也是public abstract。</li></ul><h2 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h2><ol><li><p>子类通过implements来实现接口中的规范。</p></li><li><p>接口不能创建实例，但是可用于声明引用变量类型。</p></li><li><p>一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是public的。</p></li><li><p>JDK1.7之前，接口中只能包含静态常量、抽象方法，不能有普通属性、构造方法、普通方法。</p></li><li><p>JDK1.8后，接口中包含普通的静态方法。</p></li></ol><h2 id="内部类："><a href="#内部类：" class="headerlink" title="内部类："></a>内部类：</h2><ul><li>内部类可以使用public、default、protected 、private以及static修饰。而<strong>外部顶级类(我们以前接触的类)只能使用public和default修饰。</strong></li></ul><blockquote><p>注意：内部类是一个编译时的概念，一蛋编译成功，就会成为两个完全不同的两个类。对于一个名为Outer的外部类和其内部定义的名为Inner的内部类。编译完成后会出现Outer.class和Outer$Inner.class两个类的字节码文件。所以内部类是相对独立的一种存在，其成员变量/方法名可以和外部类的相同。</p></blockquote><blockquote><p><strong>内部类中可以声明与外部类同名的属性与方法</strong></p></blockquote><h2 id="内部类的作用："><a href="#内部类的作用：" class="headerlink" title="内部类的作用："></a>内部类的作用：</h2><ol><li>内部类提供了更好的封装，只让外部类直接访问，不允许同一个包中的其他类访问。</li><li>内部类可以直接访问外部类的私有属性，内部类被当成其外部类的成员，外部类不能访问内部类的属性。</li><li>接口只是解决了多重继承的问题，而内部类使得多重继承更加完整</li></ol><h2 id="内部类的使用场合："><a href="#内部类的使用场合：" class="headerlink" title="内部类的使用场合："></a>内部类的使用场合：</h2><ol><li>由于内部类提供了更好的封装特性，并且可以很方便的访问外部类的属性。所以，在只为外部类提供服务的情况下可以优先考虑使用内部类。</li><li>使用内部类间接实现多继承：每个内部类都能独立地继承一个类或者实现某些接口，所以无论外部类是否已经继承了某个类或者实现了某些接口，对于内部类没有任何影响。</li></ol><h2 id="内部类的分类："><a href="#内部类的分类：" class="headerlink" title="内部类的分类："></a>内部类的分类：</h2><ul><li><p>在Java中内部类主要分为成员内部类(非静态内部类、静态内部类)、匿名内部类、局部内部类。</p></li><li><p>成员内部类(可以使用private、default、protected、public任意进行修饰。 类文件：外部类$内部类.class)</p></li><li><p>非静态内部类(外部类里使用非静态内部类和平时使用其他类没什么不同)</p><ol><li>非静态内部类必须寄存在一个外部类对象里。因此，如果有一个非静态内部类对象那么一定存在对应的外部类对象。非静态内部类对象单独属于外部类的某个对象。</li><li>非静态内部类可以直接访问外部类的成员，但是外部类不能直接访问非静态内部类成员。</li><li>非静态内部类不能有静态方法、静态属性和静态初始化块。</li><li>外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例。</li><li>成员变量访问要点：</li><li><ol><li>内部类里方法的局部变量：变量名。</li></ol></li><li><ol start="2"><li>内部类属性：this.变量名。</li></ol></li><li>外部类属性：外部类名.this.变量名。</li></ol></li><li><p>静态内部类：</p><ol><li>定义方式：static class Inner{}</li><li><strong>当一个内部类对象存在，并不能保证外部类对象存在。因此静态内部类的实例对象并不能访问外部类的实例方法</strong></li></ol></li></ul><h2 id="内部类的访问："><a href="#内部类的访问：" class="headerlink" title="内部类的访问："></a>内部类的访问：</h2><ol><li>外部类定义内部类 new Inner();</li><li>外部类以外的地方引用内部类：(先创建外部类实例，然后使用该外部类实例创建内部类实例)</li></ol><p><strong>Outer.Inner inner = new Outer().new Inner();</strong></p><h2 id="匿名内部类："><a href="#匿名内部类：" class="headerlink" title="匿名内部类："></a>匿名内部类：</h2><p>注意：</p><blockquote><p>匿名内部类没有修饰符<br>匿名内部类没有构造方法，因为他连名字都没有何来构造方法。</p></blockquote><h2 id="局部内部类："><a href="#局部内部类：" class="headerlink" title="局部内部类："></a>局部内部类：</h2><ul><li><p>定义在方法内部的，作用域只限于本方法，称为局部内部类。</p></li><li><p>局部内部类的的使用主要是用来解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类。局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法中被使用，出了该方法就会失效。</p></li><li><p>局部内部类在实际开发中应用很少。</p></li></ul><h2 id="编译运行如下Java代码，输出结果是-D-–上转型对象无法使用对象的新增方法-只能使用继承或重写的方法"><a href="#编译运行如下Java代码，输出结果是-D-–上转型对象无法使用对象的新增方法-只能使用继承或重写的方法" class="headerlink" title="编译运行如下Java代码，输出结果是(D )–上转型对象无法使用对象的新增方法,只能使用继承或重写的方法"></a>编译运行如下Java代码，输出结果是(D )–上转型对象无法使用对象的新增方法,只能使用继承或重写的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print (<span class="string">"Base method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print (<span class="string">"Child methodB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Base base= <span class="keyword">new</span> Child();</span><br><span class="line">        base.methodB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.Base method</span><br><span class="line"></span><br><span class="line">B.Child methodB</span><br><span class="line"></span><br><span class="line">C.hild methodB</span><br><span class="line"></span><br><span class="line">D.编译错误</span><br></pre></td></tr></table></figure><h2 id="继承条件下子类构造方法的执行过程。"><a href="#继承条件下子类构造方法的执行过程。" class="headerlink" title="继承条件下子类构造方法的执行过程。"></a>继承条件下子类构造方法的执行过程。</h2><p>（1）如果子类的构造方法中没有通过super显式调用父类的有参构造方法，也没有通过this显式调用自身的其他构造方法，则系统会默认先调用父类的无参构造方法。在这种情况下，写不写“super();”语句，效果是一样的；</p><p>（2）如果子类的构造方法中通过super显式调用父类的有参构造方法，那将执行父类相应构造方法，而不执行父类无参构造方法；</p><p>（3）如果子类的构造方法中通过this显式调用自身的其他构造方法，在相应构造方法中应用以上两条规则；</p><p>（4）特别注意的是，如果存在多级继承关系，在创建一个子类对象时，以上规则会多次向更高一级父类应用，一直到执行顶级父类Object类的无参构造方法为止；</p><h2 id="Error和Exception区别："><a href="#Error和Exception区别：" class="headerlink" title="Error和Exception区别："></a>Error和Exception区别：</h2><ul><li>1、你开车遇到一只猪，你刹车，这叫exception。</li><li>2、你开车，车坏了，这叫error</li></ul><h2 id="NumberFormatException异常"><a href="#NumberFormatException异常" class="headerlink" title="NumberFormatException异常"></a>NumberFormatException异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"1234abcf"</span>;</span><br><span class="line">        System.out.println(Integer.parseInt(str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如图6-8所示：</p><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834280275315.jpg" alt=""></p><p> 数字格式化异常的解决，可以引入正则表达式判断是否为数字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"1234abcf"</span>;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">"^\\d+$"</span>);</span><br><span class="line">        Matcher m = p.matcher(str);</span><br><span class="line">        <span class="keyword">if</span> (m.matches()) &#123; <span class="comment">// 如果str匹配代表数字的正则表达式,才会转换</span></span><br><span class="line">            System.out.println(Integer.parseInt(str));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="已核查的异常CheckedException"><a href="#已核查的异常CheckedException" class="headerlink" title="已核查的异常CheckedException"></a>已核查的异常CheckedException</h2><ul><li>所有不是RuntimeException的异常，统称为Checked Exception，又被称为“已检查异常”，如IOException、SQLException等以及用户自定义的Exception异常。 这类异常在编译时就必须做出处理，否则无法通过编译。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;标签：核心总结&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;本人学习总结&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;this-本质&quot;&gt;&lt;a href=&quot;#this-本质&quot; class=&quot;headerlink&quot; title=&quot;this 本质&quot;&gt;&lt;/a&gt;this
      
    
    </summary>
    
    
    
      <category term="java学习笔记" scheme="http://www.sumulige.com/tags/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java常见面试题及答案（二）</title>
    <link href="http://www.sumulige.com/2020/03/06/java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://www.sumulige.com/2020/03/06/java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-03-05T18:12:41.000Z</published>
    <updated>2020-03-05T18:34:24.916Z</updated>
    
    <content type="html"><![CDATA[<p>1、jvm分区<br><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834259261258.jpg" alt=""></p><h2 id="2、mysql-使用的引擎"><a href="#2、mysql-使用的引擎" class="headerlink" title="2、mysql 使用的引擎?"></a>2、mysql 使用的引擎?</h2><p>1)MyIsam 不支持事务，适用于选择密集型，插入密集型，mysql 默认的引擎<br>2)innodb 使用于更新密集型，支持事务，自动灾难恢复，行级锁，外键约束 3)memory 出发点是速度 采用的逻辑存储介质是内存<br>4)merge 一组 myisam 表的组合</p><h2 id="3、并行和并发"><a href="#3、并行和并发" class="headerlink" title="3、并行和并发"></a>3、并行和并发</h2><p><img src="https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834259759910.jpg" alt=""></p><p>并行线程同时被（多个线程）cpu执行，并发是线程被（一个cpu）轮流切换着执行</p><h2 id="4、线程池ThreadPoolExcutor"><a href="#4、线程池ThreadPoolExcutor" class="headerlink" title="4、线程池ThreadPoolExcutor"></a>4、线程池ThreadPoolExcutor</h2><ul><li>corepoolsize 默认情况下，创建线程池后，此时线程池中默认是0，当任务执行来之后，就会创建一个任务去执行任务，当线程池中任务达到corepoolsize后，就把任务存放在任务缓存队列中</li><li>maximumpoolsize线程池中最多创建的线程数</li><li>keeplivetime：线程中没有任务执行时，最多保存多久终止，默认情况下，当线程池中线程数&gt;corepoolsize时，keeplivetime起作用，直到线程数不大于corepoolsize</li><li>workqueue阻塞队列，用来存放被执行任务</li><li>threadFactory线程工厂，用来创建线程线程</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、jvm分区&lt;br&gt;&lt;img src=&quot;https://sumulige-1257145452.cos.ap-beijing.myqcloud.com/MWeb/2020/03/06/15834259261258.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;2、my
      
    
    </summary>
    
    
    
      <category term="java常见面试题及答案" scheme="http://www.sumulige.com/tags/java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>vue学习笔记-初识（一）</title>
    <link href="http://www.sumulige.com/2020/03/06/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%9D%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.sumulige.com/2020/03/06/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%9D%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-03-05T18:12:41.000Z</published>
    <updated>2020-03-05T18:27:29.740Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue-渐进式框架"><a href="#vue-渐进式框架" class="headerlink" title="vue 渐进式框架"></a>vue 渐进式框架</h3><p>慢慢嵌入项目当中</p><h3 id="vue高级功能"><a href="#vue高级功能" class="headerlink" title="vue高级功能"></a>vue高级功能</h3><ul><li>解耦视图和数据</li><li>可复用组件</li><li>前端路由</li><li>状态管理</li><li>虚拟DOM</li></ul><h3 id="编程范式？"><a href="#编程范式？" class="headerlink" title="编程范式？"></a>编程范式？</h3><h3 id="vue-js安装"><a href="#vue-js安装" class="headerlink" title="vue.js安装"></a>vue.js安装</h3><ul><li><p>cdn引入</p></li><li><p>npm安装</p></li></ul><h3 id="mvvm"><a href="#mvvm" class="headerlink" title="mvvm"></a>mvvm</h3><p>view vue modle</p><h3 id="tab键"><a href="#tab键" class="headerlink" title="tab键"></a>tab键</h3><p>例如div#app+tab=<div id="app"></div></p><h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><p>‘v-on:click=”a”‘=@click</p><h3 id="快速写出console-log"><a href="#快速写出console-log" class="headerlink" title="快速写出console.log()"></a>快速写出console.log()</h3><p>‘add被执行’.log+enter=console.log(‘add被执行’)</p><h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3><p>表示不随绑定数据改变而改变</p><h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><p>用来返回解析html <h3 v-html="url"></h3></p><h3 id="wangxinwen-不如双括号语法好-前者会覆盖掉，wangxinwen-后者不会"><a href="#wangxinwen-不如双括号语法好-前者会覆盖掉，wangxinwen-后者不会" class="headerlink" title="wangxinwen 不如双括号语法好 前者会覆盖掉，wangxinwen 后者不会"></a><h2 v-text="message">wangxinwen </h2>不如双括号语法好 前者会覆盖掉，wangxinwen 后者不会</h3><h3 id="v-cloak-斗篷"><a href="#v-cloak-斗篷" class="headerlink" title="v-cloak(斗篷)"></a>v-cloak(斗篷)</h3><h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><ul><li>动态绑定a标签</li><li>动态绑定img的src路径<h3 id="方法和函数的区别"><a href="#方法和函数的区别" class="headerlink" title="方法和函数的区别"></a>方法和函数的区别</h3>开发时候什么时候称之为函数 什么时候称之为方法</li></ul><p>方法1.一般定义在类里 和实例挂钩<br>函数 function</p><h3 id="版本区别"><a href="#版本区别" class="headerlink" title="版本区别"></a>版本区别</h3><p>开发完成 打一个tag tag的版本就是发布的版本<br>release已经测试过</p><h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><p>mounted安装好的</p><h3 id="插值操作"><a href="#插值操作" class="headerlink" title="插值操作"></a>插值操作</h3><p>｛｛｝｝mustache 语法双大括号 单词翻译叫胡须</p><hr><p><a href="https://github.com/sumulige/VueStudy" target="_blank" rel="noopener">github项目所在地</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;vue-渐进式框架&quot;&gt;&lt;a href=&quot;#vue-渐进式框架&quot; class=&quot;headerlink&quot; title=&quot;vue 渐进式框架&quot;&gt;&lt;/a&gt;vue 渐进式框架&lt;/h3&gt;&lt;p&gt;慢慢嵌入项目当中&lt;/p&gt;
&lt;h3 id=&quot;vue高级功能&quot;&gt;&lt;a href=&quot;#vu
      
    
    </summary>
    
    
    
      <category term="vue学习笔记" scheme="http://www.sumulige.com/tags/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java常见面试题及答案（一）</title>
    <link href="http://www.sumulige.com/2020/03/06/java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.sumulige.com/2020/03/06/java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-03-05T18:12:41.000Z</published>
    <updated>2020-03-05T18:29:27.096Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="考查点"><a href="#考查点" class="headerlink" title="考查点"></a>考查点</h4><ol><li>了解基本数据结构以及特点</li><li>表、栈、队列、树需要熟练掌握，深刻理解使用场景</li><li>了解常用的字符串处置算法</li><li>能够分析算法实现的复杂度</li><li>了解常用算法分类，解决问题的思路和解决那类问题</li></ol><h4 id="加分项"><a href="#加分项" class="headerlink" title="加分项"></a>加分项</h4><ol><li>能够将数据结构与实际使用场景结合</li><li>不同算法在业务场景中的应用</li><li>面对模糊题目能够沟通确认条件和边界</li><li>书写算法代码前，先讲一下解题思路</li><li>能够发现解答中的一些问题，给出改进思路</li></ol><p>####　真题汇总</p><ol><li>各种排序算法实现和复杂度、稳定性</li><li>二叉树的前、中、后序遍历</li><li>翻转句子中单词的顺序</li><li>用栈模拟队列</li><li>对10个亿数进行排序，限制内存1G</li><li>去掉两个数组中重复的数字</li><li>将一颗二叉树转换成其镜像</li><li>确定一个字符串中的括号是否匹配</li><li>给定一个开始词，一个结束词，一个字典，如何找到从开始词到结束词最短单词接龙路劲</li><li>如何查找两个二叉树节点得到最近公共祖先</li></ol><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ol><li>深入理解JVM内存模型</li><li>了解类加载机制</li><li>了解内存可见性</li><li>了解常用的GC算法实现和适用场景</li><li>能够根据业务场景适合JVM参数和GC算法</li></ol><p>加分项：</p><ol><li>编译器优化</li><li>问题排查经验和思路</li><li>JVM调优和调优思路</li><li>了解最新的技术趋势(ZGC、Graalvm)</li></ol><h4 id="真题汇总"><a href="#真题汇总" class="headerlink" title="真题汇总"></a>真题汇总</h4><ol><li>简单描述一下JVM内存模型?比较一下JVM内存结构、内存模型、对象模型的区别?</li></ol><p><strong>内存模型：</strong></p><p><code>Java内存模型（JMM）并不像JVM结构一样真实存在的，它只是一个抽象的概念。JMM是和多线程相关的，它描述了一组抽象的规则和规范，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。 简单总结，Java的多线程之间是通过共享内存进行通信的，而由于采用共享内存进行通信，在通信过程中会存在一系列如可见性、原子性、顺序一致性等问题，而JMM就是围绕多线程通信以及其相关的一系列特性建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。</code></p><p><img src="D:%5Ctools%5Cwork%5C%E5%85%B6%E4%BB%96%5C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%5Cimages%5CJMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt=""></p><p><a href="http://www.hollischuang.com/archives/2550" target="_blank" rel="noopener">http://www.hollischuang.com/archives/2550</a></p><p><strong>Java对象模型：</strong></p><p><code>Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。</code></p><p><code>HotSpot虚拟机中，设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。</code></p><p><code>每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个</code>instanceKlass<code>，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个</code>instanceOopDesc<code>对象，这个对象中包含了对象头以及实例数据。</code></p><p>   <img src="D:%5Ctools%5Cwork%5C%E5%85%B6%E4%BB%96%5C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%5Cimages%5CJava%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.png" alt=""></p><p>   这就是一个简单的Java对象的OOP-Klass模型，即Java对象模型。</p><p>   <strong>Java内存结构：</strong></p><p>   Java代码是运行在虚拟机上的，而虚拟机在执行Java程序的过程中把所管理的内存划分为若干个不同的数据区域，这些区域各有自己的用途。某些区域随着虚拟机进程的存在而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁。</p><p>   <img src="D:%5Ctools%5Cwork%5C%E5%85%B6%E4%BB%96%5C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%5Cimages%5CJVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt=""></p><p>   <strong>内存结构注意点：</strong></p><ul><li><p>以上是Java虚拟机规范，不同的虚拟机实现会各有不同，但是一般会遵守规范。</p></li><li><p>规范中定义的方法区，只是一种概念上的区域，并说明了其应该具有什么功能。但是并没有规定这个区域到底应该处于何处。所以，对于不同的虚拟机实现来说，是由一定的自由度的。</p></li><li><p>不同版本的方法区所处位置不同，上图中划分的是逻辑区域，并不是绝对意义上的物理区域。因为某些版本的JDK中方法区其实是在堆中实现的。</p></li><li><p>运行时常量池用于存放编译期生成的各种字面量和符号应用。但是，Java语言并不要求常量只有在编译期才能产生。比如在运行期，String.intern也会把新的常量放入池中。</p></li><li><p>除了以上介绍的JVM运行时内存外，还有一块内存区域可供使用，那就是直接内存。Java虚拟机规范并没有定义这块内存区域，所以他并不由JVM管理，是利用本地方法库直接在堆外申请的内存区域。</p></li><li><p>堆和栈的数据划分也不是绝对的，如HotSpot的JIT会针对对象分配做相应的优化。</p></li></ul><p>   <strong>内存模型是如何解决缓存一致性问题的？</strong></p><ul><li><p>通过在总线加<code>LOCK#</code>锁的方式；</p></li><li><p>通过缓存一致性协议（Cache Coherence Protocol）；</p><p> <strong>三者区别：</strong></p><ul><li><p>JVM结构：和java虚拟机的运行时区域有关；</p></li><li><p>Java内存模型：和Java并发有关系；</p></li><li><p>Java对象模型：和java对象在虚拟机中的表现形式有关</p><p><a href="http://www.hollischuang.com/archives/2509" target="_blank" rel="noopener">http://www.hollischuang.com/archives/2509</a>      </p></li></ul></li></ul><ol start="2"><li><p>什么情况下会触发FullGC? </p><p><strong>概念：</strong> <code>从年轻代空间(Eden和Survivor)回收内存被称为**Minor GC**，对老年代GC称为Major GC，而Full GC是对整个堆来说的，在最近几个版本的JDK默认对永生代即方法区的回收，出现FullGC的时候经常伴随着Minor GC，Major GC的速度一般会比Minor GC慢10倍以上。</code></p><p><strong>FullGC：</strong></p><ul><li>System.gc()方法的调用</li></ul><p><code>此方法的调用是建议JVM进行FullGC，虽然只是建议而非一定，但很多情况下它会触发FullGc，从而增加FullGC的频率，强烈建议能不使用此方法就不使用，让虚拟机自己去管理，可通过通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。</code></p><ul><li>老年代空间不足</li></ul><p><code>老年代空间只有在新生代对象传入以及创建为大对象、大数组才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：**java.lang.OutOfMemoryError: Java heap space** 。为避免以上两种状况引起的Full GC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</code></p><ul><li><p>永生代空间不足</p><p><code>JVM规范中运行时数据区域中的方法区，在HostSpot虚拟机又被称为永生代或者永生区，Permanent Generation中存放的为一些class信息、常量、静态变量等数据，当系统要加载类、反射的类、调用的方法比较多的时候，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：**ava.lang.OutOfMemoryError: PermGen space** 。为避免Perm Gen占满造成FullGC现象，可采用的方法为增大Perm Gen空间转为使用CMS GC。</code></p></li><li><p>CMS时出现promotion failed和concurrent mode failure</p></li><li><p>堆中分配了很大的对象</p><p><code>所谓大对象，是指需要大量连续内存空间的Java对象，例如很长的数组，此种对象会直接进入老年代，而老年代虽然有很大的剩余空间，但是无法找到足够大的连续空间来分配给当前对象，此种情况就会触发JVM进行FullGC。为了解决这个问题，CMS垃圾收集器提供了一个可配置的参数，即XX:+UseCMSCompactAtFullCollection开关参数，用于在“享受”完Full GC服务之后额外免费赠送一个碎片整理的过程，内存整理的过程无法并发的，空间碎片问题没有了，但提顿时间不得不变长了，JVM设计者们还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction,这个参数用于设置在执行多少次不压缩的Full GC后,跟着来一次带压缩的。</code></p></li></ul><p><a href="https://blog.csdn.net/chenleixing/article/details/46706039/" target="_blank" rel="noopener">https://blog.csdn.net/chenleixing/article/details/46706039/</a></p></li><li><p>java类加载器有几种？关系是怎样的？</p><p><code>每个编写的‘.java’扩展类文件都存储着需要执行的程序逻辑，这些java文件经过java编译器编译成扩展名为“.class”的文件，“.class”文件中保存着Java代码经过转换后的虚拟机指令，当需要使用某个类的时候，虚拟机将会加载它的class文件，并创建对应的class对象，将class文件加载到虚拟机的内存，这个过程叫做类加载过程。</code></p><p><img src="D:%5Ctools%5Cwork%5C%E5%85%B6%E4%BB%96%5C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%5Cimages%5C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt=""></p><ul><li>加载，类加载的过程一个阶段：通过一个类的完全限定查找此类字节码文件，并利用字节码文件创建一个class对象</li><li>验证，目的在于确保class文件的字节流包含信息符合当前虚拟机的要求，不会危害虚拟机自生安全。主要包含四种验证：文件格式验证、元数据验证、字节码验证、符合引用验证。</li><li>准备，为类变量(即static修饰的字段变量)分配内存并且设置该类变量的初始值为0。(如果static int i=5;这里只将i初始化为0，至于5的值将在初始化的时候赋值)，这里不包含用final修饰的static，因为final在编译的时候就分配了，注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是随着对象一起分配到堆中。</li><li>解析，主要将常量池中的符号引用替换为直接引用的过程。符号引用就是一组符号来描述目标，可以是任何字面量，而直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li><li>初始化，类加载到最后阶段，若该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化成员变量。</li></ul><p>类加载分为5个过程，而类加载的任务是根据一个类的全限定名来读取二进制字节流到JVM中，然后转换为一个与目标类对应的java.lang.class对象实例，在虚拟机提供了三种类加载器启动（Bootstrap）类加载器、扩展（Extension）类加载器、系统（System）类加载器（也称应用类加载器）。</p><p><strong>类加载：</strong></p><ul><li><p>启动(Bootstrap)类加载器</p><p>启动类加载器主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，是虚拟机自身的一部分，它负责将<code>&lt;JAVA_HOME&gt;/lib</code> 路径下的核心库或者 -xbootclasspath参数指定的路径下的jar包加载到内存中，注意必由于虚拟机是按照文件名识别加载jar包的，如rt.jar，如果文件名不被虚拟机识别，即使把jar包丢到lib目录下也是没有作用的（出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类）</p></li><li><p>扩展(Extension)类加载器</p><p>扩展类加载器是指Sun公司实现的<strong>sun.misc.Launcher$ExtClassLoader</strong>类，由Java实现，是Launcher的静态内部类，它负责加载<code>&lt;JAVA_HOME&gt;/lib/ext</code>目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用标准扩展类加载器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ExtClassLoader类中获取路径的代码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> File[] getExtDirs() &#123;</span><br><span class="line">     <span class="comment">//加载&lt;JAVA_HOME&gt;/lib/ext目录中的类库</span></span><br><span class="line">     String s = System.getProperty(<span class="string">"java.ext.dirs"</span>);</span><br><span class="line">     File[] dirs;</span><br><span class="line">     <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">         StringTokenizer st =</span><br><span class="line">             <span class="keyword">new</span> StringTokenizer(s, File.pathSeparator);</span><br><span class="line">         <span class="keyword">int</span> count = st.countTokens();</span><br><span class="line">         dirs = <span class="keyword">new</span> File[count];</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">             dirs[i] = <span class="keyword">new</span> File(st.nextToken());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         dirs = <span class="keyword">new</span> File[<span class="number">0</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> dirs;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>系统(System)类加载器</p><p>也称应用程序加载器是指 Sun公司实现的<code>sun.misc.Launcher$AppClassLoader</code>。它负责加载系统类路径 java - classpath或者-D java.class.path指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统加载器，一般情况下该类加载是程序默认的加载器，通过ClassLoader#getSystemClassLoader方法可以获取到该类加载器。</p></li></ul><p><strong>类加载器间的关系：</strong></p><ul><li>启动类加载器，由C++实现，没有父类</li><li>扩展类加载器（ExtClassLoader），由Java实现，父类加载器为Null</li><li>系统类加载器（AppClassLoader），由Java实现，父类加载器为ExtClassLoader</li><li>自定义加载器，父类加载器肯定是AppClassLoader</li></ul><p><strong>双亲委派流程：</strong></p><p>双亲委派模式是在java1.2后引入的，如果一个类加载器收到了类加载请求，它不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终到达顶层的启动类加载器，如果父类加载器可以完成加载任务，就成功返回，倘若父类加载器无法完成此类加载任务，子加载器才会尝试自己去加载，这就是双亲委派，即使每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我干不了，儿子才会自己想办法去完成。</p><p><strong>双亲委派优势：</strong></p><p>采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委派模式传递到启动类加载器，而启动类加载器在核心API发现这个名字的类，发现该类已经被加载，并不会重新加载网络传递过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。</p><p><strong>双亲委派破坏者：</strong></p><p>线程上下文类加载器。</p><p><a href="https://blog.csdn.net/javazejian/article/details/73413292" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/73413292</a></p></li><li><p>1.8为什么用Metaspace（元空间）替换掉PermGen（永久代）?Metaspace保存在哪？</p><p><strong>替换原因：</strong></p><ul><li>字符串在永久代中，很容易出现性能问题和内存溢出</li><li>类和方法的信息等比较难确定其大小，因此对永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出</li><li>永久代会为GC带来不必要的复杂度，并且回收率低</li><li>Oracle可能将HotSpot与JRockit合二为一</li></ul><p><strong>元空间保存不在虚拟机中，而是本地内存</strong></p><p><a href="https://www.cnblogs.com/paddix/p/5309550.html" target="_blank" rel="noopener">https://www.cnblogs.com/paddix/p/5309550.html</a></p><p><a href="http://www.cnblogs.com/duanxz/p/3520829.html" target="_blank" rel="noopener">http://www.cnblogs.com/duanxz/p/3520829.html</a></p></li><li><p>编译器会对指令做哪些优化？（简单描述编译器指令重排）</p><p><strong>优化：</strong></p><ul><li>程序顺序原则：一个线程内保证了语义的串行性</li><li>volatile规则：volatile变量的写，先发生于读，保证了volatile变量的可见性</li><li>锁规则：解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前</li><li>传递性：A先与B，B先于C，那么A必须先于C</li><li>线程的start方法先于他的每一个动作</li><li>线程的所有操作先于线程的终结（Thread.join()）</li><li>线程的中断（interrupt()）先于被中断线程的代码</li><li>对象的构造函数执行结束先于finalize()方法</li></ul><!--有疑问--></li><li><p>简单介绍一下volatile可以解决那些问题？如何做到？</p><p><strong>volatile：</strong></p><ul><li>内存可见性</li></ul><p>当写一个volatile变量时，JMM会把该线程对应的工作内存中的共享变量值刷新到主内存，当读取一个volatile变量时，JMM会把该线程对应的工作内存置为无效，那么该线程将只能从主内存中重新读取共享变量。</p><ul><li>指令重排序</li></ul><p>内存屏障，又称为内存栅栏，是一个CPU的指令，它的作用有两个，一个是保证特定操作的执行顺序，二是保证某些变量的内存可见性。由于编译器和处理器的都能执行指令重排序，如果在指令之间插入一条内存屏障则会告诉编译器和CPU，不管什么指令都不能和这条内存屏障指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序的优化。内存屏障的另一个作用就是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。总之，volatile变量正是通过内存屏障实现其在内存中的语义，即可见性和禁止重排优化。</p><p>非常典型的<strong>禁止重排优化</strong>的例子DCL：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DoubleCheckLock instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckLock</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckLock <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一次检测</span></span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckLock<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//多线程环境下可能会出现问题的地方</span></span><br><span class="line">                    instance = <span class="keyword">new</span> DoubleCheckLock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/javazejiarticle/details/72772461#volatile%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89" target="_blank" rel="noopener">https://blog.csdn.net/javazejiarticle/details/72772461#volatile%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89</a></p></li><li><p>简单描述一下GC的分代回收？</p><p><strong>为什么要分代？</strong></p><p><code>不同的对象生命周期是不一样的。因此，不同生命周期的对象可以采用不同的收集方式，以便提高回收效率。在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会 长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有 效果的，因为可能进行了很多次遍历，但是他们依旧存在。因此，分代垃圾回收采用分治的思想，进行代的划 分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。</code></p><p>垃圾回收器创建基于以下两个假设：</p><ul><li>大多数对象很快就会变得不可达</li><li>只有极少数情况会出现旧对象持有新对象的引用</li></ul><p>这两条假设被称为”<strong>弱分代假设</strong>“。为了证明此假设，在HotSpot VM中物理内存空间被划分为两部分：<strong>新生代(young generate)</strong>和<strong>老年代(old generation)</strong>。</p><p><strong>GC分代回收：</strong></p><p>虚拟机中共划分为三个代：年轻代、老年代、永久代</p><p><strong>新生代：</strong></p><p>大部分的新创建对象分配在新生代。因为大部分对象很快就会变得不可达，所以它们被分配在新生代，然后消失不再。当对象从新生代移除时，我们称之为”<strong>minor GC</strong>“。</p><p><strong>新生代的结构：</strong></p><ul><li>一个Eden区</li><li>两个Survivor区</li></ul><ol><li>大多数新生对象都被分配到Eden区</li><li>第一次GC过后Eden还存活的对象被移动到其中一个Survivor区</li><li>再次GC过程中，Eden还存活的对象会被移动到之前已经移入对象的Survivor区</li><li>一旦该Survivor区域无空间可用的时候，还存活的对象会从当前Survivor区移动到另外一个空的Survivor区。而当前Survivor区就会再次置为空状态</li><li>经过数次在两个Survivor区域移动后还存活的对象最后被移动到老年代。</li></ol><p><strong>两个Survivor区域在任何时候必定有一个保持空白。如果同时有数据存在于两个Survivor区或者两个区域的的使用量都是0，则意味着你的系统可能出现了运行错误。</strong></p><p><strong>老年代：</strong></p><p>存活在新生代中但未变为不可达的对象会被复制到老年代。一般来说老年代的内存空间比新生代大，所以在老年代GC发生的频率较新生代低一些。当对象从老年代被移除时，我们称之为”<strong>major GC</strong>“(或者<strong>full GC</strong>)。</p><p><strong>老年代垃圾回收：</strong></p><ul><li><p>Serial GC(-XX:+UseSerialGC)</p><p>在老年代，则使用了一种称之为”<strong>mark-sweep-compact</strong>“的算法。</p></li></ul><ol><li>首先该算法需要在老年代中标记出存活着的对象</li><li>然后从前到后检查堆空间中存活的对象，并保持位置不变</li><li>最后，把存活的对象移动到堆空间的前面部分以保持使用的堆空间的连续性，从而把堆空间分为两个部分：有对象和无对象(称为空间压缩)</li></ol><p>Serial GC适用于CPU核数较少且使用的内存空间较小的场景。</p><p>其中<strong>Serial GC务必不要在生产环境的服务器上使用</strong>，这种GC是为单核CPU上的桌面应用设计的。使用Serial GC会明显的损耗应用的性能。</p><ul><li>Paraller GC(-XX:+UseParallelGC)</li></ul><p>Serial GC使用单一线程执行GC，而parallel GC则使用多个线程并发执行，因此parallel GC 较serial GC具有更快的速度。Parallel GC适用于多核CPU且使用了较大内存空间的场景。Parallel GC又被称为”<strong>高吞吐GC(throughput GC)</strong>“</p><ul><li>Paraller Old GC(-XX:+UseParallelOldGC)</li></ul><p>在JDK 5中被引入，与Paraller GC相比唯一的区别在于Paraller的GC算法是为老年代设计的。它的执行过程分为三步：标记（Mark）-总结（Summary）-压缩(Commpaction)。其中summary步骤会会分别为存活的对象在已执行过GC的空间上标出位置，因此与mark-sweep-compact算法中的sweep步骤有所区别，并需要一些复杂步骤才能完成。</p><ul><li>CMS(-XX:+UseConcMarkSweepGC)</li></ul><p>​     从图上可看出并发标记-清理(Concurrent Mark-Sweep) GC比以后上其他GC都要复杂。开始时的初始标记(initial mark)比较简单，只有靠近类加载器的存活对象会被标记，因此停顿时间(stop-the-world)比较短暂。在并发标记(concurrent mark)阶段，由刚被确认和标记过的存活对象所关联的对象将被会跟踪和检测存活状态。此步骤的不同之处在于有多个线程并行处理此过程。在重标记(remark)阶段，由并发标记所关联的新增或中止的对象瘵被会检测。在最后的并发清理(concurrent sweep)阶段，垃圾回收过程被真正执行。在垃圾回收执行过程中，其他线程依然在执行。得益于CMS GC的执行方式，在GC期间系统中断时间非常短暂。CMS GC也被称为低延迟GC，适用于所有<strong>应用对响应时间要求比较严格的场景</strong>。</p><p>​       <strong>CMS缺点：</strong></p><p>​           1.与其他GC相比，CMS GC要求更多的内存空间和CPU资源</p><p>​           2.CMS GC默认不提供内存压缩</p><ul><li>G1</li></ul><p>每当一个区域分配满对象后，新创建的对象就会分配到另外一个区域，并开始执行GC。在这种GC中不会出现其他GC中的对象在新生代和老生代三区域中移动的现象。G1是为了取代在长期使用中暴露出大量问题且饱受抱怨的CMS GC。</p><p><a href="https://segmentfault.com/a/1190000004233812" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004233812</a></p><p><a href="https://blog.csdn.net/wangtaomtk/article/details/52263908" target="_blank" rel="noopener">https://blog.csdn.net/wangtaomtk/article/details/52263908</a></p></li><li><p>G1垃圾回收算法和CMS的区别有哪些？</p><p><strong>区别：</strong></p><ul><li>分代收集</li></ul><p>这个是现在垃圾收集器的标配，G1和CMS也不例外。但是G1同时回收老年代和年轻代，而CMS只能回收老年代，需要配合一个年轻代收集器。另外G1的分代更多是逻辑上的概念，G1将内存分成多个等大小的region，<code>Eden</code>/ <code>Survivor</code>/<code>Old</code>分别是一部分region的逻辑集合，物理上内存地址并不连续。</p><p>CMS在old GC的时候会回收整个Old区，对G1来说没有old gc概念，而是区分<code>Fully young gc</code>和<code>Mixed gc</code>，</p><p>前者对应年轻代的垃圾回收，后者混合了年轻代和部分老年代的收集，因此每次收集肯定会回收年轻代，老年代根据内存情况可以不回收或者回收部分或者全部。</p><ul><li>如何处理跨代引用</li><li>如何处理并发过程中的对象变化</li><li>Write Barrier</li><li>Full GC</li></ul><p><a href="https://www.jianshu.com/p/bdd6f03923d1" target="_blank" rel="noopener">https://www.jianshu.com/p/bdd6f03923d1</a></p></li><li><p>对象引用有哪些方式？有什么特点？</p></li></ol><p><strong>对象引用：</strong></p><ul><li><p>强引用</p></li><li><p>弱引用</p></li><li><p>软引用</p></li><li><p>虚引用</p></li></ul><p><a href="https://www.jianshu.com/p/6d264d02e992" target="_blank" rel="noopener">https://www.jianshu.com/p/6d264d02e992</a></p><ol start="10"><li>使用过那些JVM调优工具？主要分析那些内容？</li></ol><p><a href="https://www.cnblogs.com/warehouse/p/9479104.html" target="_blank" rel="noopener">https://www.cnblogs.com/warehouse/p/9479104.html</a></p><ol start="11"><li>JVM常见面试题：</li></ol><p>链接：</p><ul><li><a href="https://www.cnblogs.com/alsf/p/9398951.html" target="_blank" rel="noopener">https://www.cnblogs.com/alsf/p/9398951.html</a></li><li><a href="https://www.liangzl.com/get-article-detail-15614.html" target="_blank" rel="noopener">https://www.liangzl.com/get-article-detail-15614.html</a></li><li><a href="https://blog.csdn.net/sun1021873926/article/details/78002118" target="_blank" rel="noopener">https://blog.csdn.net/sun1021873926/article/details/78002118</a></li></ul><ol start="12"><li><p>从实际案例中聊聊Java应用的GC优化</p><p><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html" target="_blank" rel="noopener">https://tech.meituan.com/2017/12/29/jvm-optimize.html</a></p></li><li><p>Java Hotspot G1 GC 的一些关键技术,</p><p><a href="https://tech.meituan.com/2016/09/23/g1.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/09/23/g1.html</a></p></li><li><p>常见性能优化策略的总结</p></li></ol><p><a href="https://tech.meituan.com/2016/12/02/performance-tunning.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/12/02/performance-tunning.html</a></p><ol start="15"><li>性能优化模式</li></ol><p><a href="https://tech.meituan.com/2015/12/10/performance-tuning-pattern.html" target="_blank" rel="noopener">https://tech.meituan.com/2015/12/10/performance-tuning-pattern.html</a></p><h3 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h3><h4 id="常用设计模式与应用场景"><a href="#常用设计模式与应用场景" class="headerlink" title="常用设计模式与应用场景"></a>常用设计模式与应用场景</h4><p><strong>设计模式分为三个类：创建类模式、结构类模式、行为类模式；</strong></p><p><strong>创建类模式：</strong></p><ul><li>工厂方式模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类，使一个类的实例化延迟到其子类；</li><li>建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示；</li><li>抽象工厂模式：为创建一组相关或者相互依赖的对象提供一个接口，而且无须指定他们的具体类；</li><li>单例模式：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例；</li><li>原型模式：通过对象复制来实现的模式就叫做原型模式，用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象；</li></ul><p><strong>结构模式：</strong></p><ul><li>适配器模式：将一个类的接口变换成客户端所期待的另一种接口，从而使原本因不匹配而无法在一起工作的两个类能够在一起工作；</li><li>桥梁模式：将抽象与实现解耦，使得两者可以独立变换；</li><li>组合模式：将对象组合成树形结构以表示<strong>部分-整体</strong>的场次结构，使得用户对单个对象组合对象的使用具有一致性；</li><li>装饰模式：动态的给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活；</li><li>门面模式：要求一个子系统的外部与其内部通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使的子系统更易于使用；</li><li>享元模式：是池技术的重要实现方式，使得共享对象可有效地支持大量的细粒度的对象。</li><li>代理模式：为其对象提供一种代理以控制对这个对象的访问；</li></ul><p><strong>行为模式：</strong></p><ul><li>责任链模式：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系，将这些对象连 成一条链，并沿着这条链传递该请求，直到有对象处理它为止；</li><li>命令模式：这是一个高内聚的模式，将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能；</li><li>解释器模式：是一个种按照规定语法进行解析的方案；定义为：给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示业解释语言中的句子。</li><li>迭代模式：它提供一种方法访问一个容器对象中各个对象，而又不需要暴露该对象的内部细节。</li><li>中介者模式：用一个中介对象封装一系列对象的交互，中介者使各个对象不需要显示的相互作用，从而使其耦合松散，而且可以独立的改变他们之间的交互；</li><li>备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将对象恢复到原先保存的状态。通俗地讲，备忘录模式就是一个对象的备份模式，提供了一种程序数据的备份方法；</li><li>观察者模式：也叫做发布订阅模式，定义对象之间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新；</li><li>状态模式：状态模式是封装，状态的变更引起了行为变更。当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类；</li><li>策略模式：定义一组算法，将每个算法封装起来，并且使他们之间可以互换；</li><li>模板方法模式：定义一个操作中的算法框架，而将一些步骤延迟到子类中；使得子类可以不改变一个算法结构即可重定义该算法的某些框架；</li><li>访问者模式：封装一些作用于某种数据结构中的各个元素的操作，他可以在不改变数据结构的前提下定义作用这些元素的新操作；</li></ul><p><strong>常用设计模式：</strong></p><ul><li>单例模式</li></ul><p>基本概念：保证一个类仅有一个实例，并提供一个访问它的全局访问点；</p><p>常见写法：</p><p><strong>懒汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">/**持有私有静态实例，防止被引用，此处赋值为Null，目的是实现延迟加载**/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**私有构造方法，防止被实例化**/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**1.懒汉式，静态工程方法，创建实例**/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：延迟加载(需要的时候才去加载)，适合单线程操作；</p><p>缺点：线程不安全，在多线程很容易出现不同步的情况，如在数据库对象进行频繁的读写操作；</p><p><strong>双重线程检查模式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInner</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonInner sInst = <span class="keyword">null</span>; &lt;&lt;&lt; 这里添加了<span class="keyword">volatile</span></span><br><span class="line">    <span class="comment">/**私有的构造函数**/</span></span><br><span class="line">    <span class="keyword">private</span> SingletonInner&#123;&#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonInner <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SingletonInner inst = sInst;  &lt;&lt;&lt; 在这里创建了临时变量</span><br><span class="line">            <span class="keyword">if</span>(inst == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (SingletonInner<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                    inst = sInst;</span><br><span class="line">                    <span class="keyword">if</span>(inst == <span class="keyword">null</span>)&#123;</span><br><span class="line">                        inst = <span class="keyword">new</span> SingletonInner();</span><br><span class="line">                        sInst = inst;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;    </span><br><span class="line">          <span class="keyword">return</span> inst; &lt;&lt;&lt; 注意这里返回的是临时变量</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：延迟加载，线程安全</p><p>缺点：写法复杂，不简洁</p><p><strong>内部类的实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInner</span> </span>&#123;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 内部类实现单例模式 </span></span><br><span class="line"><span class="comment">     * 延迟加载，减少内存开销   </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> SingletonInner instance = <span class="keyword">new</span> SingletonInner();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 私有的构造函数 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonInner</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonInner <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"SingletonInner"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>工厂模式</li></ul><p>基本概念：为创建提供过渡接口，以便将创建对象的具体过程屏蔽起来，达到提高灵活性的目的；</p><p>分为三类：</p><ol><li>简单工厂模式：不利于产生系列产品；</li><li>工厂方法模式：又称为多型性工厂；</li><li>抽象工厂模式：又称为工具箱，产生产品族，但不利于产生新的产品；</li></ol><ul><li><p>建造模式</p><p>基本概念：是一种概念构建的设计模式，它可以将复杂对象的构建过程抽象出来，使这个抽象过程的不同实现方法可以构建出不同表现的对象。Builder模式生是一步一步创建一个复杂的对象，它允许用户可以指定复杂对象的类型和内容就可以构建他们。用户不知道内部的具体构建细节。Builder模式是非常类似抽象工厂模式，细微的区别大概只有在反复使用中才能体会到。</p><p>为何使用：</p><p>是为了将构建复杂对象的过程和它的部件解耦。注意：是解耦过程和部件。<br>因为一个复杂的对象，不但有很多大量组成部分，如汽车，有很多部件：车轮、方向盘、发动机，还有各种小零件等等，部件很多，但远不止这些，如何将这些部件装配成一辆汽车，这个装配过程也很复杂(需要很好的组装技术)，Builder模式就是为了将部件和组装过程分开。</p></li></ul><p><strong>Builder模式的应用</strong></p><p>在Java实际使用中，我们经常用到”池”(Pool)的概念，当资源提供者无法提供足够的资源，并且这些资源需要被很多用户反复共享时，就需要使用池。”池”实际是一段内存，当池中有一些复杂的资源的”断肢”(比如数据库的连接池，也许有时一个连接会中断)，如果循环再利用这些”断肢”，将提高内存使用效率，提高池的性能。修改Builder模式中Director类使之能诊断”断肢”断在哪个部件上，再修复这个部件。</p><ul><li>观察者模式</li></ul><p>基本概念：观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。观察者模式又叫发布-订阅(Publish/Subscribe)模式。</p><p><img src="D:%5Ctools%5Cwork%5C%E5%85%B6%E4%BB%96%5C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%5Cimages%5C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt=""></p><p>图是Observer 模式的结构图,让我们可以进行更方便的描述:</p><p>   Subject类：它把所有对观察者对象的引用保存在一个聚集里，每个主题都可以有任何数量的观察着。抽象主题提供一个接口，可以增加和删除观察着对象。</p><p>​    Observer类：抽象观察者，为所有的具体观察者定义一个接口，在得到主题的通知时更新自己</p><p>   ConcreteSubject类：具体主题，将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。</p><p>​    ConcreteObserver类：具体观察者，实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。</p><ul><li>代理模式</li></ul><p>基本概念：为其他对象提供一种代理以控制对这个对象的访问。也可以说，在出发点到目的地之间有一道中间层，意为代理。</p><p>为什么要使用：</p><ol><li>授权机制不同级别的用户对同一对象拥有不同的访问权利，如在论坛系统中，就使用Proxy进行授权机制，访问论坛有两种人：注册用户和游客，论坛通过类似ForumProxy这样的代理来控制这两种用户对论坛的访问权限</li><li>某个客户端不能直接操作某个对象，但又必须和那个对象有所互动。</li></ol><p><a href="https://www.cnblogs.com/cr330326/p/5627658.html" target="_blank" rel="noopener">https://www.cnblogs.com/cr330326/p/5627658.html</a></p><p><a href="https://www.hollischuang.com/archives/category/%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">https://www.hollischuang.com/archives/category/%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F</a></p><h4 id="Java语言特性"><a href="#Java语言特性" class="headerlink" title="Java语言特性"></a>Java语言特性</h4><ol><li><p>JUC：ConcurrentXXX、原子类、Executor、Caller&amp;&amp;Future、Queue、Locks</p></li><li><p>常用集合: <strong>HashMap、ConcurrentHashMap</strong>、ArrayList&amp;LinkedList、hashSet、TreeMap</p><p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：</p><p><img src="D:%5Ctools%5Cwork%5C%E5%85%B6%E4%BB%96%5C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%5Cimages%5CMap%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt=""></p><p>下面针对各个实现类的特点做一些说明：</p><p>（1）HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因为具有很快的访问速度，但遍历顺序却是不确定的。HashMap最多只允许一条记录的键为Null，运行多条记录的值为null。HashMap非线程安全，即任意时刻可以有多个线程同时写HashMap，可能会导致数据不一致。如果需要满足线程安全，可以用Collections的SynchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p><p>（2）HashTable：HashTable是遗留类，很多映射的常用功能和HashMap类似，不同的是它继承Distionary类，并且是线程安全的，任一时间只有一个线程能写HashTable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。HashTable不建议在新代码中使用，不需要线程安全的场合可以使用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p><p>（3）LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，再用Iterator遍历LinkedHashMap时，先得到记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p><p>（4）TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</p><p><strong>HashMap:</strong></p><p><strong>基本概念</strong></p><p>它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因为具有很快的访问速度，但遍历顺序却是不确定的。HashMap最多只允许一条记录的键为Null，运行多条记录的值为null。HashMap非线程安全，即任意时刻可以有多个线程同时写HashMap，可能会导致数据不一致。如果需要满足线程安全，可以用Collections的SynchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p><p><strong>存储结构</strong></p><p>HashMap结构图：</p><p>1.7 </p><p>![](D:\tools\work\其他\面试总结\images\1.7 HashMap结构图.png)</p></li></ol><p>   1.8 </p><p>   <img src="D:%5Ctools%5Cwork%5C%E5%85%B6%E4%BB%96%5C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%5Cimages%5C1.8HashMap%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt=""></p><p>   <strong>JDK8核心方法优化：</strong></p><p>   <strong>put方法</strong></p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line"> <span class="number">3</span>     <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"> <span class="number">4</span> &#125;</span><br><span class="line"> <span class="number">5</span> </span><br><span class="line"> <span class="number">6</span> <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">7</span>                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line"> <span class="number">8</span>     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"> <span class="number">9</span>     <span class="comment">// 步骤①：tab为空则创建</span></span><br><span class="line"><span class="number">10</span>     <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line"><span class="number">11</span>         n = (tab = resize()).length;</span><br><span class="line"><span class="number">12</span>     <span class="comment">// 步骤②：计算index，并对null做处理 </span></span><br><span class="line"><span class="number">13</span>     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) </span><br><span class="line"><span class="number">14</span>         tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="number">15</span>     <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">16</span>         Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="number">17</span>         <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></span><br><span class="line"><span class="number">18</span>         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line"><span class="number">19</span>             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="number">20</span>             e = p;</span><br><span class="line"><span class="number">21</span>         <span class="comment">// 步骤④：判断该链为红黑树</span></span><br><span class="line"><span class="number">22</span>         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line"><span class="number">23</span>             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="number">24</span>         <span class="comment">// 步骤⑤：该链为链表</span></span><br><span class="line"><span class="number">25</span>         <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">26</span>             <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line"><span class="number">27</span>                 <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">28</span>                     p.next = newNode(hash, key,value,<span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//链表长度大于8转换为红黑树进行处理</span></span><br><span class="line"><span class="number">29</span>                     <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st  </span></span><br><span class="line"><span class="number">30</span>                         treeifyBin(tab, hash);</span><br><span class="line"><span class="number">31</span>                     <span class="keyword">break</span>;</span><br><span class="line"><span class="number">32</span>                 &#125;</span><br><span class="line">                    <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line"><span class="number">33</span>                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line"><span class="number">34</span>                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) </span><br><span class="line"><span class="number">35</span><span class="keyword">break</span>;</span><br><span class="line"><span class="number">36</span>                 p = e;</span><br><span class="line"><span class="number">37</span>             &#125;</span><br><span class="line"><span class="number">38</span>         &#125;</span><br><span class="line"><span class="number">39</span>         </span><br><span class="line"><span class="number">40</span>         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line"><span class="number">41</span>             V oldValue = e.value;</span><br><span class="line"><span class="number">42</span>             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">43</span>                 e.value = value;</span><br><span class="line"><span class="number">44</span>             afterNodeAccess(e);</span><br><span class="line"><span class="number">45</span>             <span class="keyword">return</span> oldValue;</span><br><span class="line"><span class="number">46</span>         &#125;</span><br><span class="line"><span class="number">47</span>     &#125;</span><br><span class="line"><span class="number">48</span>     ++modCount;</span><br><span class="line"><span class="number">49</span>     <span class="comment">// 步骤⑥：超过最大容量 就扩容</span></span><br><span class="line"><span class="number">50</span>     <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line"><span class="number">51</span>         resize();</span><br><span class="line"><span class="number">52</span>     afterNodeInsertion(evict);</span><br><span class="line"><span class="number">53</span>     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="number">54</span> &#125;</span><br></pre></td></tr></table></figure>   <!--Put方法分解--><pre><code>1. 判断当前桶是否为空，空的话就初始化2. 根据当前key的hashcode定位到具体的桶中并判断是否为空，为空表明没有Hash冲突就直接在当前位置创建一个新桶3. 如果当前桶有值（冲突），那么就要比较当前桶中的key、value的Hashcode与写入的key是否相等，相等就直接覆盖value4. 如果当前桶为红黑树，那就要按照红黑树的方式写入数据5. 如果是个链表，就需要将当前的key、value封装成一个新节点写入到当前桶的后面(形成链表)6. 接着判断当前链表的大小是否大于设置的阈值，大于时就转换为红黑树7. 如果在遍历过程中找到 key 相同时直接退出遍历。8. 如果 `e != null` 就相当于存在相同的 key,那就需要将值覆盖。9. 最后判断是否需要进行扩容。</code></pre><p>   <strong>get方法</strong></p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先将 key hash 之后取得所定位的桶。</p></li><li><p>如果桶为空则直接返回 null 。</p></li><li><p>否则判断桶的第一个位置(有可能是链表、红黑树)的 key 是否为查询的 key，是就直接返回 value。</p></li><li><p>如果第一个不匹配，则判断它的下一个是红黑树还是链表。</p></li><li><p>红黑树就按照树的查找方式返回值。</p></li><li><p>不然就按照链表的方式遍历匹配返回值。</p></li><li><p><strong>jdk1.8做了哪些优化？</strong></p><p>当 Hash 冲突严重时，在桶上形成的链表会变的越来越长，这样在查询时的效率就会越来越低；时间复杂度为 <code>O(N)</code>。在JDk1.8重点优化了这个查询效率。主要体现在两个核心方法（get/put）可以看出1.8对大链表做了优化，修改为红黑数之后查询效率直接提高到了O(logn)；</p><p>修改了几个重要的参数：</p></li></ul><ol><li>TREEIFY_THRESHOLD：用于判断是否需要将链表转换为红黑树的阈值</li><li>HashEntry修改为Node，Node 的核心组成其实也是和 1.7 中的 HashEntry 一样，存放的都是 <strong><code>key value hashcode next</code></strong> 等数据。</li></ol><ul><li><p>是线程安全的吗？</p><p>不是，在并发场景下，会出现死循环。HashMap 扩容的时候会调用 <code>resize()</code> 方法，就是这里的并发操作容易在一个桶上形成环形链表；这样当获取一个不存在的 key 时，计算出的 index 正好是环形链表的下标就会出现死循环。</p></li><li><p>JDK1.7和JDK1.8HashMap区别？</p></li></ul><p>   <strong>1.7</strong></p><p>   使用一个Entry数组来存储数据，用key的hashcode取模来决定key会被放到数组里的位置，如果hashcode相同，或者hashcode取模后的结果相同，那么这些key会被定位到Entry数组的同一个格子里，这些key会形成一个链表；在hash函数特别差的情况下，比如说所有key的hashcode都相同，这个链表可能会很长，那么put/get操作都可能需要遍历这个链表，也就是最差情况下时间复杂度为O（n）。<br>   <strong>1.8</strong></p><p>   使用一个node数组来存储数据，但是这个Node可能是链表结构，也可能是红黑树结构；如果插入的元素key的hashcode相同，那么这些key也会被定为到Node数组的同一个格子里，如果不超过8个使用链表存储，超过8个，会调用treeifyBin函数，将链表转为红黑树。那么即使所有key的hashcode完全相同，由于红黑树的特点，查找某个特定元素，也只需要O（logn）的开销。</p><p>   <strong>红黑树特性：</strong></p><ol><li>每个节点不是红的就是黑的；</li><li>根节点都是黑色，叶子节点指的是为空的节点</li><li>如果一个节点是红色的，那么它 的子节点一定是黑色的</li><li>从一个节点到该节点的子孙节点所有路径上包含相同数据的黑节点</li></ol><ul><li><p>如何解决？有没有线程安全的并发容器？</p><p>在不替换HashMap的情况下可以使用Collections.SynchronizedMap来保证Map的线程安全。第二个就是可以用ConcurrentHashMap。</p></li><li><p>如果两个键的hashcode相同，你如何获取对象？</p><p>当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket（散列桶）位置，找到bucket位置后，会调用key.equals()方法去找到链表中正确的节点，最终找到要找的值对象。</p></li><li><p>什么原因导致HashMap冲突的？</p><p>在HashMap中，哈希桶数组table的长度length大小必须是2的N次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设置为素数，相对来说素数导致冲突的概率要小于合数，Hashtable初始化桶大小是11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规的设计，主要是为了在取模和扩容的时候做优化，同时为了减少冲突，HashMap的定位哈希桶索引位置时，也加入了高位参与运算的过程。</p></li><li><p>有什么方法可以减少碰撞？</p></li></ul><p>   <strong>好的Hash算算法和扩容机制。</strong></p><p>  <strong>使用不可变的、声明为final对象，并且采用合适的hashCode()和equals()方法，将会减少碰撞</strong></p><p>   如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞。</p><p>   这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。</p><ul><li><p>为什么String、Integer这样的适合作为键？</p><p>因为String是final，而且已经重写了hashCode()和equals()方法了。不可变性是必要的，因为为了要计算HashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的 hashcode 的话，那么就不能从 HashMap 中找到你想要的对象。</p><p><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/06/24/java-hashmap.html</a></p><p><a href="https://segmentfault.com/a/1190000012926722?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012926722?utm_source=tag-newest</a></p><p><a href="http://www.importnew.com/31278.html" target="_blank" rel="noopener">http://www.importnew.com/31278.html</a></p><p><a href="http://www.codeceo.com/article/java-hashmap-concurrenthashmap.html" target="_blank" rel="noopener">http://www.codeceo.com/article/java-hashmap-concurrenthashmap.html</a></p></li></ul><p>   <strong>ConcurrentHashMap:</strong></p><p>   <strong>JDK1.7和JDK1.8的区别？</strong> </p><p>   （JDK1.7）</p><p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p><p>   put实现：当执行put方法插入数据的时候，先通过hash值在segment中找到对应的位置，然后如果相应位置的segment还未初始化，则通过CAS进行赋值，接着执行segment对象的put方法通过加锁机制插入数据。</p><p>  get实现：因为concurrenthashmap是可以并发插入数据的，所以准确计算元素时有一定的难度，所以是先采用不加锁的方式，连续计算元素的个数，最多计算3次，如果前后两次计算结果相同，那么说明元素个数是准确的；如果前后两次计算结果都不相同，则给每个segment加锁，再计算一次元素的个数。</p><p> （JDK1.8）</p><pre><code>ConcurrentHashMap抛弃了原有的Segment分段锁，采用了CAS+synchronized来保证并发安全性，其中的value 、next都用了volatile修饰，保证了可见性。</code></pre><p>最大特性是引入了CAS，借助unsafe来实现native code。CAS有三个操作数，内存值V、旧的预期值A、要修改的值B。当前仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。unsafe借助了CPU指令cmpxchg来实现的。</p><p>CAS出现的问题：ABA；解决：对变量增加一个版本号，每次修改版本号加1，比较的时候比较版本号。</p><p><strong>put实现：</strong></p><ul><li><p>如果Node还未初始化，那么通过CAS插入相应的数据；</p></li><li><p>如果Node不为空，且当前该节点不处于移动状态，那么对该节点加synchronized锁，如果该节点hash不小于0，则遍历链表更新节点或者插入新节点；</p></li><li><p>如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；</p></li><li><p>如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</p></li><li><p>如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</p></li></ul><p><strong>size实现：</strong> 1.8中使用一个volatile类型的变量baseCount记录元素的个数，当插入新数据或则删除数据时，会通过addCount()方法更新baseCount。因为元素个数保存baseCount中，部分元素的变化个数保存在CounterCell数组中，通过累加baseCount和CounterCell数组中的数量，即可得到元素的总个数。</p><p>   <a href="https://blog.csdn.net/majinggogogo/article/details/80042096" target="_blank" rel="noopener">https://blog.csdn.net/majinggogogo/article/details/80042096</a></p><p>   <a href="http://ifeve.com/concurrenthashmap/" target="_blank" rel="noopener">http://ifeve.com/concurrenthashmap/</a></p><p>   <a href="http://www.cnblogs.com/huangjuncong/p/9478505.html" target="_blank" rel="noopener">http://www.cnblogs.com/huangjuncong/p/9478505.html</a></p><p>   <a href="https://blog.csdn.net/bill_xiang_/article/details/81122044" target="_blank" rel="noopener">https://blog.csdn.net/bill_xiang_/article/details/81122044</a></p><p>   <a href="http://www.cnblogs.com/huangjuncong/p/9478505.html" target="_blank" rel="noopener">http://www.cnblogs.com/huangjuncong/p/9478505.html</a></p><p>   <a href="https://blog.csdn.net/woaiwym/article/details/80675789" target="_blank" rel="noopener">https://blog.csdn.net/woaiwym/article/details/80675789</a></p><ol start="3"><li><p>动态代理与反射</p><p><strong>动态代理：</strong></p><p>大道理上讲代理是一种软件设计模式，目的地希望能做到代码重用。</p></li></ol><p>​    JDK动态代理：在java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。</p><p>​    CGLIB动态代理：通过cglib的jar包实现动态代理,该方法只需要对目标对象继承即可 </p><p>   <strong>反射：</strong></p><p>   <a href="https://blog.csdn.net/javazejian/article/details/70768369" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/70768369</a></p><ol start="4"><li><p>数据类型：空间占用、基本数据结构、自动转型与强制转型、封装与拆箱 <!--（暂无总结）--></p></li><li><p>Java版本特性：1.8 Lambda表达式、Stream API、方法引用  <!--（暂无总结）--></p></li></ol><h4 id="真题汇总-1"><a href="#真题汇总-1" class="headerlink" title="真题汇总"></a>真题汇总</h4><ol><li><p>进程和线程的区别与联系</p><p><code>在过去没有线程的操作系统中，资源的分配和执行都是由进程完成的。随着技术的发展，为了减少由于进程切换带来的开销，提升并发能力，操作系统中引入线程。把原本属于进程的工作一分为二，进程还是负责资源的分配，而线程负责执行。</code></p><p><strong>进程是资源分配的基本单位，而线程是调度的基本单位。</strong></p><p><strong>开销方面：</strong>每个进程都有独立的代码和数据空间，程序之间的切换会有较大的开销；线程可以看作轻量级的进程，同一类线程共享代码和数据空间，每个线程都有独立的运行栈和程序计数器，线程之间的切换开销小；</p><p><strong>所处环境：</strong>在操作系统中能同时运行多个进程；而在同一个进程中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行 ）；分时操作系统把CPU的时间划分长短基本相同的时间区间，也就是时间片，通过操作时间管理，把这些时间片依次轮流地分配给各个用户 使用；</p><p><strong>内存分配方面：</strong>系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU，系统不会为线程分配内存，线程之间共享内存；</p></li><li><p>简单介绍一下进程的切换过程 <!--(暂无总结)--></p></li><li><p>你经常使用那些Linux 命令，主要用来解决那些问题</p><p>文件常用命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd + 文件路径、 ls：查看当前文件下所有文件 、 pwd:查看当前所在路径、rm -rf 文件名：删除文件</span><br></pre></td></tr></table></figure><ul><li>top:查看cpu占有率</li><li>ps -ef |grep tomcat 查看tomcat是否启动</li><li>kill -9 进程号 杀死进程</li><li>tail -n 10 -f filename 查看文件filename最后十行并动态刷新</li><li>su root：从一般用户切换到root用户</li></ul></li><li><p>为什么TCP建连三次握手而断连需要四次？ <!--(暂无总结)--></p></li><li><p>为什么TCP关闭链接时需要Time_Wait状态？为什么要等2MSL? <!--(暂无总结)--></p></li><li><p>一次完整的Http请求过程是怎么样的？ <!--(暂无总结)--></p></li><li><p>Http2和Http的区别有哪些？</p><p><strong>二进制传输</strong></p><p>http2采用二进制传输，相较于文本传输的http1来说更加可靠</p><p><strong>多路复用</strong></p><p>http1一个连接只能提交一个请求；而http2可以同时处理无数个请求，可以降低连接的占用数量，进一步提升网络的吞吐量</p><p><strong>头部压缩</strong></p><p>http2通过gzip与compress对头部进行压缩，并且在客户端与服务端各维护了一份头部索引表，只需要根据索引id就可以进行头部信息的传输，缩小了头部容量，间接提升了传输效率。</p></li><li><p>在你的项目中使用过那些设计模式？主要用来解决什么问题？</p></li><li><p>final,finally,finalize的区别和使用场景？</p><ul><li>final：可以作为修饰符修饰变量、方法和类，被final修饰的变量只能一次赋值；被final修饰的方法不能在子类中被重写；被final修饰的类不能被继承；</li><li>finally：用在异常处理中定义总是执行的代码，无论try中的代码块是否引起了异常，finally中的代码总会执行；</li><li>finalize：此方法是Object类中定义的方法，当垃圾回收器将无用对象从内存中清除的时候，该对象的finalize方法被调用。</li></ul></li><li><p>简单描述一下java的异常机制？</p><p>Java把异常作为一种类，当做对象来处理。所有异常类的基类是Throwable类，两大子类分别是Error和Exception。这些异常类可以分为三种类型：系统错误、异常和运行时异常。系统错误由Java虚拟机抛出，用Error类表示。Error类描述的是内部系统错误，例如Java虚拟机崩溃。这种情况仅凭程序自身是无法处理的，在程序中也不会对Error异常进行捕捉和抛出。</p><p>异常（Exception）又分为RuntimeException(运行时异常)和CheckedException(检查异常)，两者区别如下：</p><ul><li>RuntimeException：程序运行过程中出现错误，才会被检查的异常。例如：类型错误转换，数组下标访问越界，空指针异常、找不到指定类等等。</li><li>CheckedException：来自于Exception且非运行时异常都是检查异常，编译器会强制检查并通过try-catch块来对其捕获，或者在方法头声明该异常，交给调用者处理。</li></ul><p>两种异常的处理方式：<strong>若是运行时异常，则表明程序出错，应该找到错误并修改，而不是对其捕获。若是检查异常，遵循该原则：谁知情谁处理，谁负责谁处理，谁导致谁处理。处理就是对其捕获并处理。</strong></p></li><li><p>美团酒店实时数据规则引擎应用实践</p></li></ol><p><a href="https://tech.meituan.com/2018/04/19/hb-rt-operation.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/04/19/hb-rt-operation.html</a></p><ol start="14"><li>序列化和反序列化</li></ol><p><a href="https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html" target="_blank" rel="noopener">https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html</a></p><ol start="15"><li>如何防止CSRF攻击？</li></ol><p><a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/10/11/fe-security-csrf.html</a></p><ol start="17"><li>红黑树深入分析Java实现</li></ol><p><a href="https://tech.meituan.com/2016/12/02/redblack-tree.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/12/02/redblack-tree.html</a></p><ol start="18"><li>Ajax 跨域问题如何解决？</li></ol><p><strong>JSONP</strong></p><p>JSONP的弊端有哪些？服务器需要改动代码支持、只支持get请求、发送的不是xhr请求</p><p>被调用方解决跨域，服务端如何实现：</p><ol><li><p>filter解决方法,添加拦截器，拦截所有请求。并设置允许那个域和什么请求可以访问到。如果设置所有域和方法就设置成*号。<br>简单请求和非简单请求：OPTIONS预检命令、OPTIONS预检命令缓存</p></li><li><p>Spring框架：加注解@CrossOrigin</p></li></ol><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h4><ol><li>理解线程的同步和互斥的原理</li><li>掌握线程安全相关机制</li><li>了解JUC工具的使用场景和实现原理</li><li>属性线程池的原理、使用场景、常用配置</li><li>理解线程的同步与异步、阻塞与非阻塞</li></ol><h4 id="加分项-1"><a href="#加分项-1" class="headerlink" title="加分项"></a>加分项</h4><ol><li><p>结合实际项目经验或者案例介绍原理</p></li><li><p>解决多线程问题排查思路和经验</p></li><li><p>熟悉常用的线程分析工具和方法</p></li><li><p>了解java8对JUC的增强</p><p><strong>并发工具方面：</strong></p><p>  新的类和接口：</p><ul><li>ConcurrentHashMap.keySetView&lt;K,V&gt;类：ConcurrentHashMap的键集合视图。</li><li>CompletionException:异常类</li></ul><p><strong>ConcurrentHashMap增加了新方法</strong></p><p>增加了30多个方法，包括foreach系列、reduce系列，增加后的concurrentHashMap更适合做缓存了。</p><p><strong>java.util.concurrent.atomic包改进</strong></p><p>增加了四个类：DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder</p><p><strong>增加StampedLock类</strong></p><p>stampedLock是一种新的锁实现，很可能在大多数场景都可以替换ReentrantReadWirteLock。它为读写锁提供了三种模式：Writing、ReadingOptimistic、Reading</p><p><a href="http://ifeve.com/java-se-8-concurrent-tool-enhance/" target="_blank" rel="noopener">http://ifeve.com/java-se-8-concurrent-tool-enhance/</a></p></li><li><p>了解Reactive异步编程思路 <strong>(暂无总结)</strong></p></li></ol><h4 id="真题汇总-2"><a href="#真题汇总-2" class="headerlink" title="真题汇总"></a>真题汇总</h4><ol><li><p><strong>如何实现生产和消费者模型？（锁、信号量、线程通信、阻塞队列等）</strong></p><p><a href="http://www.importnew.com/27063.html" target="_blank" rel="noopener">http://www.importnew.com/27063.html</a></p></li><li><p><strong>如何理解同步和异步、阻塞和非阻塞</strong>                                                 </p><p>IO : <a href="http://www.pig66.com/news/a/2018/0905/35468.html" target="_blank" rel="noopener">http://www.pig66.com/news/a/2018/0905/35468.html</a></p><p>回答：</p><p>（1）同步和异步关注的是<strong>消息通信机制</strong>。所谓同步就是在发出一个调用时，在没有得到结果之前，该调用就不会返回，但一旦调用返回，调用者就得到返回值了。简单的可以说：调用者主动等待这个调用结果。异步：调用在发出之后，这个调用就会直接返回了。所以没有返回结果。简单说：调用者不会立即得到结果，而是在调用发出后，被调用者用过状态、通知来通知调用者，或者通过回调函数处理这个调用。</p><p><strong>同步和异步举例</strong>：你打电话书店老板有没有《分布式系统》这本书，通过同步通信机制，书店老板会说，你稍微我查一下。等查好了告诉你结果。异步通信机制，书店老板会说，我查好 了给你打电话。然后查好了他会主动给你打电话。在这里老板通过“回电”这种方式来回调。</p><p>（2）阻塞和非阻塞关注的是<strong>程序在等待调用结果时候的状态</strong></p><p>   阻塞调用的是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。可以线程可以干其他事情。</p><p><strong>阻塞和非阻塞例子</strong>：你你打电话书店老板有没有《分布式系统》这本书，你如果是阻塞调用，你会一直把自己挂起，直到得到了这本书有没有结果，如果是非阻塞调用，你不管老板有没有告诉你，你自己先一边玩了，当然你也要偶尔问问老板有没有返回结果。</p></li><li><p><strong>线程池处理任务的流程是什么？</strong></p><p><strong>什么是线程池？</strong>帮我们重复管理线程，避免创建大量的线程增加开销，提高响应速度。</p><p>一个对象创建需要经过以下几步：</p><ul><li>检查对应的类是否已经被加载、解析和初始化</li><li>类加载后，为新生对象分配内存</li><li>将分配的内存空间初始为0</li><li>对对象进行关键信息的设置，比如对象的哈希码等</li><li>然后执行Init方法初始化对象</li></ul><p><strong>线程池的处理流程主要分为3步</strong></p><ul><li>提交任务后，线程池先判断线程数是否达到核心线程数(corePoolSize)。如果未达到线程数，则创建核心线程处理任务；否则就执行下一步；</li><li>接着线程池判断任务队列是否满了。如果没满，则将任务添加到任务队列中；否则，就执行下一步；</li><li>接着因为任务队列满了，线程池就判断线程数是否达到了最大线程数。如果未达到，则创建非核心线程处理任务；否则就执行饱和策略，默认会抛出RejectedExecutionException异常。</li></ul><p><strong>饱和策略：RejectedExecutionHandler</strong></p><p>当任务队列和线程池都满了采用的是应对策略，默认是AbordPolicy，表示无法处理新任务，并抛出RejectedExecutionException异常。此外还有3中策略：</p><ul><li>CallerRunsPolicy：用调用者所在的线程处理任务。此策略提供简单的反馈机制，能够减缓新任务的提交速度。</li><li>DiscardPolicy：不能执行任务，并将任务删除。</li><li>DiscardOldestPolicy：丢弃队列最近的任务，并执行当前的任务。</li></ul><p><strong>常见的四种线程池：</strong></p><ul><li><p><strong>CachedThreadPool</strong> 用于并发执行大量短期的小任务，或者是负载较轻的服务器。</p></li><li><p><strong>FixedThreadPool</strong> 用于负载比较重的服务器，为了资源的合理利用，需要限制当前线程数量。</p></li><li><p><strong>SingleThreadExecutor</strong> 用于串行执行任务的场景，每个任务必须按顺序执行，不需要并发执行。</p></li><li><p>*<em>ScheduledThreadPoolExecutor *</em>用于需要多个后台线程执行周期任务，同时需要限制线程数量的场景。</p><p>之前提供了四种线程池，在<strong>jdk8</strong>加入了newWorkStealingPool，变成了五种线程池，这是一个经常被人忽略的线程池。</p></li></ul><p><strong>考点分析：</strong></p><ul><li>掌握Executor框架的主要内容，至少了解组成与职责，掌握基本开发用例中的使用。</li><li>对线程池和相关开发工具类型的理解，甚至是源码层面的掌握。</li><li>实践中有哪些常见问题，基本的诊断思路是怎样的。 </li><li>如何根据自身应用特点合理使用线程池。</li></ul><p>链接：<a href="https://blog.csdn.net/u011240877/article/details/73440993" target="_blank" rel="noopener">https://blog.csdn.net/u011240877/article/details/73440993</a></p><p>​       <a href="http://www.cnblogs.com/superfj/p/7544971.html" target="_blank" rel="noopener">http://www.cnblogs.com/superfj/p/7544971.html</a></p></li><li><p><strong>wait和sleep有什么不同？</strong></p><p><strong>区别：</strong> </p><ul><li>sleep可以在任何地方使用；wait方法只能在同步方法和同步代码块中使用；</li><li>sleep是线程Thread类的方法，调用会暂停此线程指定的时间，但监控依然保持，不会释放对象锁，到时间自动恢复；wait()方法是object的方法，调用会放弃锁，进入到等待队列，待调用notify()/notifyAll()唤醒指定的线程或者所有线程，才会进入锁池，再次获得对象锁才会进入运行状态；</li></ul><p>链接： <a href="https://www.cnblogs.com/lyx210019/p/9427146.html" target="_blank" rel="noopener">https://www.cnblogs.com/lyx210019/p/9427146.html</a></p></li><li><p><strong>Synchronized和ReentrantLock有什么不同？</strong></p><p> <strong>不同：</strong></p><ul><li><p>功能区别：</p><p>synchronized是基于jvm底层实现的数据同步，lock是基于Java编写，主要通过硬件依赖CPU指令实现数据同步。</p><p>synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁。</p><p>出现异常的话，synchronized会自动释放锁。而ReenTrantLock需要手工释放锁，否则会出现造成死锁。</p><p>synchronized可重入，不可中断，默认是公平锁。ReenTrantLock可中断，可以设置锁是公平锁和非公平锁。</p></li><li><p>性能区别：在synchronized优化之前，它的性能比ReenTrantLock差很多，但是自从1.6 synchronized引入了偏向锁、轻量级锁、适应自旋锁后，两者的性能就差不多了，在两种情况都可用的情况下，官方建议使用synchronized。其实synchronized的优化我感觉借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。</p></li></ul><p>区别：<a href="https://www.cnblogs.com/jiangds/p/6476293.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiangds/p/6476293.html</a></p><p>两种锁的实现：<a href="https://blog.csdn.net/zxd8080666/article/details/83214089" target="_blank" rel="noopener">https://blog.csdn.net/zxd8080666/article/details/83214089</a></p></li><li><p><strong>读写锁适用于什么场景？ReentrantReadWriteLock是如何实现的？</strong></p><p><strong>应用场景：</strong>一些业务场景中，大部分只是读数据，写数据很少，如果仅仅是读数据的话并不会影响数据正确性（出现脏读），而如果在这种业务场景下，依然使用独占锁的话，很显然这将是出现性能瓶颈的地方。针对这种读多写少的情况，java还提供了另外一个实现Lock接口的ReentrantReadWriteLock(读写锁)</p><p><strong>如何实现：</strong></p><p>链接：<a href="https://www.jianshu.com/p/4a624281235e" target="_blank" rel="noopener">https://www.jianshu.com/p/4a624281235e</a></p><p><a href="https://blog.csdn.net/qq_19431333/article/details/70568478" target="_blank" rel="noopener">https://blog.csdn.net/qq_19431333/article/details/70568478</a></p><p><a href="https://www.cnblogs.com/xiaoxi/p/9140541.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoxi/p/9140541.html</a></p></li><li><p><strong>线程间是如何通信的？</strong></p><p><strong>如何通信：</strong></p><ul><li><p>等待通知机制</p></li><li><p>使用join方法，从源码中可以看出，join也是利用等待通知机制；</p></li><li><p>volatile共享内存，主要修饰为了内存可见性。</p></li><li><p>CountDownLatch工具，可以实现 join 相同的功能，但是更加的灵活；</p></li><li><p>CyclicBarrier并发工具</p></li><li><p>线程响应中断，调用了thread.interrput()方法，其实就是将thread中的一个标志属性设置为了true。</p></li><li><p>管道通信</p><p>答案链接：<a href="https://segmentfault.com/a/1190000013842437" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013842437</a></p></li></ul></li><li><p><strong>保证线程安全的方法有哪些？</strong></p><p><strong>保证线程安全的方法</strong></p><ul><li>synchronized</li><li>Lock</li></ul><p><strong>线程安全概念：</strong>能够正确的处理多个线程之间的共享变量，使程序功能正确的完成。</p><p>把线程安全拆解，可以总结出是<strong>并发、多线程、共享变量</strong>导致出现的线程安全问题。</p><p><strong>什么是并发：</strong>在操作系统中，指同一时间段中有几个程序都处于运行状态，且这几个程序都是在同一个处理机上运行。</p><p><strong>操作系统如何实现这种并发呢？</strong></p><p>现在我们用的操作系统，无论是Windows、Linux都是多用户多任务分时操作系统。使用这些操作系统用户是可以”同时“干很多事。但是实际上，对单CPU计算机来说，在CPU中，同一时间只能干一件事。</p><p>为了看起来像是同时干多件事，操作系统把CPU的时间划分成长短基本相同的时间区间，可以称为<strong>时间片</strong>，通过操作系统的管理，把这些时间片依次轮流的分配给各个用户使用。</p><p>如果某个作业在时间片结束之前，整个任务还有没有完成，那么该作业就会被暂停下来，放弃CPU，等待下一次再继续做。此时CPU又分配给另一个作业去使用。</p><p>由于计算器处理器速度很快，就算一个用户作业用完时间片到获得到下一个CPU时间片，中间有所停顿，但是用户察觉不出来，好像整个系统全由它独占一样。</p><p>所以，在CPU的计算机中，我们看起来同时干很多事，其实都是通过时间片技术并发来完成的。</p><p><strong>并发和并行之间的关系</strong></p><p>并行，当系统有一个以上CPU时，一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源。可以同时进行，这种方式我们称为并行。</p><p><strong>多线程和进程</strong></p><p>在多任务处理系统中，CPU需要处理所有程序的操作，当用户来回切换它们时，需要记录这些程序执行到哪里。在操作系统中，CPU切换到另一个进程需要保存当前进程的状态并恢复另一个进程的状态：当前运行任务转为就绪（或者挂起、删除）状态，另一个被选定的就绪任务成为当前任务。<strong>上下文切换</strong>就是这样一个过程，他允许CPU记录并恢复各种正在运行程序的状态，使它能够完成切换操作。</p><p><strong>共享变量</strong> 指的是多个线程都可以操作的变量。</p><p>在JVM中，java堆和方法区的区域是多个线程共享的数据区域。也就是说保存在堆和方法区中的变量就是Java共享变量。</p></li><li><p><strong>ThreadLocal用来解决什么？ThreadLocal是如何实现的？</strong></p><p>ThreadLocals是一个解决线程并发问题的一个类，用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用 同步技术。但是当我们不想使用同步技术的时候，我们可以使用ThreadLocal变量。</p><p>每个线程都会拥有它们自己的Thread变量，它们可以使用get/set方法去获取它们默认值或者线程内部改变它们的值。ThreadLocal实例通常是希望它们同线程状态关联起来。</p><p>底层实现主要是存有一个map,以线程为key,泛型作为value,可以理解为线程级别的缓存。每一个线程都获得一个单独的map.</p></li><li><p><strong>死锁的产生条件？如何分析是否有线程死锁？</strong></p><p>死锁是一种特定的状态，在实体之间，由于循环依赖导致彼此一直处于等待之中，没有任何个体可以继续前进。死锁不仅仅实在线程之间会发生，存在资源独占的线程之间同样也可能出现死锁。通常来说，我们大多数聚焦在多线程场景中的死锁，指两个线程或多个线程之间，由于相互持有对方需要的锁，而永久处于阻塞状态。</p><p><strong>如何定位：</strong>定位死锁最常见的方法就是利用jstack等工具获取线程栈，然后定位互相之间的依赖关系，进而找到死锁。如果有明显的死锁，往往jstack就能直接定位，类似JConsole甚至可以在图形界面进行有效的死锁检测。如果程序发生了死锁，绝大多数情况下都是无法在线解决的，只能重启，修正程序本身，所以在开发阶段互相审查，或者利用工具进行预防排查，就会显得很重要。</p><p>  <strong>死锁的发生：</strong><br>   1.互斥条件，类似Java中Monitor都是独占的，要么是我用，要么是你用。<br>   2.互斥条件是长期持有的，在使用结束之前，自己不会释放，也不能被其他线程抢占。<br>   3.循环依赖关系，两个或者多个个体之间出现了锁条环。<br>   <strong>编码预防死锁</strong>：<br>   1.尽可能避免使用多个锁，并且只有需要时才持有锁。<br>   2.如果必须使用多个锁，尽量设计好锁的获取顺序。<br>   3.使用带有超时的方法，为程序带来可控性。 </p></li><li><p><strong>在实际工作中遇到过什么并发问题？如何发现排查并解决的？</strong></p></li><li><p><strong>并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？</strong></p></li><li><p><strong>AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？</strong></p><p>AtomicInteger是对int类型的一个封装，提供原子性的访问和更新操作，其原子性操作实现是基于CAS技术。 所谓CAS，表征的是一些列操作的集合，获取当前数值，进行一些运算，利用CAS指令试图进行更新。如果当前数值未变，代表其他线程没有进行并发修改，则成功更新。否则，可能出现不同<br>的选择，要么进行重试，要么返回一个成功或者失败的结果。</p></li><li><p><strong>synchronized底层如何实现？什么是锁的升级和降级？</strong></p><p><strong>底层实现：</strong>synchronized代码块是由一对monitorenter/monitorexit指令实现的，Monitor对象是同步的基本实现单元。在java6之前，Monitor的实现完全依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级的操作。现在的jdk中，jvm对此进行了改进，提供了三种不同的Montior实现，也就是常说的三种不同的锁：偏向锁、轻量级锁、重量级锁，大大改进了其性能。<br><strong>锁的升级和降级：</strong>就是jvm优化synchronized运行的机制，当jvm检测到不同的竞争状态时，会自动切换到合适的锁实现，这种切换就是锁的升级和降级。<br>​      当没有竞争出现时候，默认时候的是偏向锁。JVM会利用CAS操作，在对象头上的mark word 部分设置线程ID,以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于很有应用场景中，大部分对象生命周期最多会被一个线程锁定，使用偏向锁可以降低无竞争开销。如果有其他线程试图锁定某个已经被偏向过的对象，JVM就需要撤销偏向锁，并切换到轻量级锁实现。轻量级锁依靠CAS操作Mark Word来试图获取锁，如果重试成功，就会使用普通的轻量级锁，否则，就会使用重量级锁。当JVM进入到安全点的时候，会检查 是否有闲置的Monitor，然后试图降级。</p><p><strong>其他锁，为什么我们需要读写锁等其他锁呢？</strong><br>   因为他们行为上有一定的局限性，要么不占，要么独占。实际应用场景中，有的时候不需要大量竞争写操作，而是以并发读取为主，为了进一步优化并发操作的粒度，并发包提供了读写锁等扩展锁的能力，它锁基于的原理就是多个读操作是不需要互斥的，因为读操作并不会更改数据，所以不存在互相干扰。而写操作则会导致并发一致性的问题，所以线程之间、读写线程之间、需要精心设置互斥逻辑。坏处是读写锁需要比较大的开销。</p><p> <strong>思考题，自旋锁是做什么的?它的使用场景是什么？</strong><br>   竞争锁失败的线程，并不会真实的在操作系统层面挂起等待，而是JVM会让线程做几个空循环，在经过若干次循环后，如果可以获取锁，那么就进入临界区，如果还不能获取锁，才会真实的将线程在操作系统层面挂起。在单核cpu上，自选锁是无用的，因为自旋锁尝试获取锁不成功会一直尝试，这会一直占用cpu，其他线程不可能执行，由于其他线程无法执行，所以当前无法释放锁。</p><p><strong>使用场景：</strong><br>​     自旋锁可以减少线程的开销，这对于线程竞争不激烈，且占用锁时间非常短的代码块来说，有较大的提升。因为自选的消耗会小于线程阻塞挂起操作的消耗。<br>​     如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步代码块，那么就不适用自旋锁了，因为自旋锁在获取锁前一直是占用cpu做无用功，线程自选的消耗大于线程阻塞挂起操作的消耗，造成cpu的浪费。</p><p>   自选锁在锁竞争中起到了什么作用？ 可以认为不是一种锁，而是针对短期等待的性能优化技术。</p></li><li><p>一个线程两次调用start()方法会出现什么情况？谈谈线程的生命周期和状态转移？</p><p><strong>出现情况：</strong> java的线程是不允许启动两次的，第二次调用会抛出IllegalThreadStateException,这是一种运行时异常，多次调用start被认为是编程错误。</p><p><strong>生命周期：</strong>关于线程生命周期的不同状态，在java5以后，线程状态被明确定义在其公共内部枚举类型java.lang.Thread.State 中，分别是：</p><ul><li>新建(NEW),表示线程被创建出来还没真正启动的状态，可以认为它是个Java内部状态。</li><li>就绪(RUNNABLE)，表示该线程已经在JVM中执行，当前由于执行需要计算资源，它可能正在运行，也可能还在等待系统分配给它CPU片，在就绪队列里面排队。 在其他一些分析中，会额外区分一种状态RUNNING，但是从javaAPI的角度，并不能表示出来。</li><li>.阻塞(BLOCKED),阻塞表示线程正在Monitor lock.比如，线程试图通过synchronized去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。</li><li>等待(WAITING),表示正在等待其他线程采取某些操作。一个常见的场景类似于生产者和消费者模式，发现任务条件尚未满足，就让当前消费者线程等待(wait),另外的生产者线程去准备任务数据，然后通过类似notify等动作，通知消费者可以继续工作。Thread.join()也会令线程进入到等待状态。计时等待(TIMED_WAIT)，其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如wait和join等方法的指定超时版本。</li><li>终止（TERMINATED），不管是意外退出还是正常执行结束，线程已经完成使命，终止运行，也有人把这个状态叫做死亡。</li></ul><ol start="17"><li>不可不说的<strong>JAVA锁</strong>事</li></ol><p><a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/11/15/java-lock.html</a></p><ol start="18"><li>高性能队列：Disruptor</li></ol><p><a href="https://tech.meituan.com/2016/11/18/disruptor.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/11/18/disruptor.html</a></p></li></ol><h3 id="常用工具集"><a href="#常用工具集" class="headerlink" title="常用工具集"></a>常用工具集</h3><h4 id="考查点-1"><a href="#考查点-1" class="headerlink" title="考查点"></a>考查点</h4><ol><li>了解常用的JVM分析工具</li><li>掌握git常用操作和工作流</li><li>了解Linux下常用的分析工具</li></ol><h4 id="真题汇总-3"><a href="#真题汇总-3" class="headerlink" title="真题汇总"></a>真题汇总</h4><ol><li><p>排查JVM问题有哪些常用工具？</p><ul><li>jps，显示系统内所有的JVM进程；</li><li>jstat，可以收集jvm相关的运行数据；</li><li>jinfo，显示jvm配置信息；</li><li>jhat，用于分析heapddump文件，他可以建立一个http/html服务，使用者可以在浏览器上查看分析结果；</li><li>jmap，用于生成jvm内存快照</li><li>jstack，显示jvm线程快照；</li></ul><p><a href="https://www.jianshu.com/p/4d13a09844bd" target="_blank" rel="noopener">https://www.jianshu.com/p/4d13a09844bd</a></p></li><li><p>git合并代码有哪两种方法？有什么区别？</p><p>git Merge：这种合并是将两个分支的历史合并到一起，现有的分支并不会被更改,它会比对双方不同的文件缓存下来，生成一个commit,去push</p><p>git Rebase：这种合并通常称之为“衍合”，他是修改提交历史，比对双方的commit，然后找出不同的去缓存，然后在去push，修改你的commit历史。</p></li><li><p>Git和svn的区别？</p><p>1.git是分布式的scm,svn是集中式的。(最核心)</p><p>2.git是每个历史版本都存储完整的文件,便于恢复,svn是存储差异文件,历史版本不可恢复。(核心)</p><p>3.git可离线完成大部分操作,svn则不能。</p><p>4.git有着更优雅的分支和合并实现。</p><p>5.git有着更强的撤销修改和修改历史版本的能力</p><p>6.git速度更快，效率更高</p></li></ol><h3 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h3><h4 id="考查点-2"><a href="#考查点-2" class="headerlink" title="考查点"></a>考查点</h4><ol><li><p>掌握Spring的IOC、AOP的概念与实现</p><p>链接：<a href="https://blog.csdn.net/javazejian/article/details/56267036" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/56267036</a></p><p>​           <a href="https://blog.csdn.net/javazejian/article/details/54561302" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/54561302</a></p></li><li><p>掌握Spring的Context 创建流程和Bean的生命周期</p></li><li><p>了解Spring常用注解的作用和使用方式</p><p><a href="https://www.cnblogs.com/leskang/p/5445698.html" target="_blank" rel="noopener">https://www.cnblogs.com/leskang/p/5445698.html</a></p></li><li><p>了解SpringBoot相关知识点</p></li><li><p>知道常用RPC框架的特点</p><p><a href="https://blog.csdn.net/u013952133/article/details/79256799" target="_blank" rel="noopener">https://blog.csdn.net/u013952133/article/details/79256799</a></p><p><a href="https://blog.csdn.net/quuqu/article/details/79304614" target="_blank" rel="noopener">https://blog.csdn.net/quuqu/article/details/79304614</a></p></li><li><p>了解Mybatis、Hibernate的实现原理</p></li></ol><h4 id="加分项-2"><a href="#加分项-2" class="headerlink" title="加分项"></a>加分项</h4><ol><li>阅读过框架源码，了解实现细节和思路</li><li>除了会用，还能理解理念</li><li>了解最新实现或者方向</li></ol><h4 id="真题汇总-4"><a href="#真题汇总-4" class="headerlink" title="真题汇总"></a>真题汇总</h4><ol><li><p>SSH和SSM框架组合的区别?</p><p>SSH:通常是指Strut2、Spring管理层组件、Hibernate负责持久化</p><p>SSM:指的则是SpringMVC控制器、Spring管理层组件、Mybatis负责持久化</p><p><strong>共同点：</strong> Spring依赖注入来管理各层的组件、使用面向切面编程AOP管理事务、日志等</p><p><strong>区别：</strong></p><p>  SSH和SSM不同主要在MVC实现方式，以及ORM持久化方面不同。SSM越来越轻量级配置，将注解开发发挥到了极致，而ORM实现更加灵活，SQL优化更加简便；而SSH比较注重配置开发，其中的Hibernate对JDBC完整封装更面向对象，对增删改查的数据维护更自动化，但是SQL优化方面比较弱，入门比较难。</p><p><strong>Struts实现：</strong></p><ul><li>客户端初始化一个指向servlet容器的请求</li><li>这个请求经过一系列Filter过滤器（这些过滤器中有一个叫做ActionContextCleanUp的可选过滤器，这个过滤器对struts2和其他框架集成很有帮助）</li><li>接着FilterDispatcher被调用，FilterDispatcher询问ActionMapper来决定这个请求是否需要调用某个action</li><li>如果actionMapper决定调用某个action，FilterDispatcher把这个请求交给ActionProxy</li><li>ActionProxy通过Configuration Mapper询问框架的配置文件，找到需要调用的Action类</li><li>ActionProxy创建一个ActionInvocation的实例</li><li>ActionInvocation实例使用命名模式来调用，在调用action过程前后，涉及到相关拦截器的调用。</li><li>一旦action执行完毕，ActionInvocation负责根据strut.xml的配置找到对应的返回结果。返回结果通常是一个需要被表示的jsp或者freemarker的模板。</li><li>将处理结果返回给客户端。</li></ul><p><strong>SpingMVC实现原理：</strong></p><ul><li>客户端发出一个http请求给web服务器，web服务器对url请求进行解析，如果匹配DispatcherServlet的请求映射路径（在web.xml文件中指定），web容器将请求转交给DispatcherServlet.</li><li>DispatcherSerlvet接受到这个请求之后将根据请求的信息以及HandlerMapping的配置找到处理请求的处理器(Handler)</li><li>DispatcherSerlvet根据HandlerMapping找到对应的Handler，将处理权交给Handler，再由具体的HandlerAdapter对比Handler进行具体的调用。</li><li>Hanlder对数据处理完成以后将返回一个ModelAndView()对象给DispatcherSerlvet</li><li>Handler返回的ModlAndView()只是一个逻辑视图并不是一个真正的视图，DispatcherServlet通过ViewResolver将逻辑视图转换为真正的视图View</li><li>Dispather通过model解析出ModelAndView()中的参数进行解析最终展现出完成的view并返回给客户端</li></ul><p><strong>Hibernate和Mybatis的对比</strong></p><p><strong>相同点：</strong>都是通过SessionFactoryBuilder由XML配置文件生成SessionFactory，然后由SessionFactory生成Session，最后都是由Session来开启执行事务和SQL语句。其中SessionFactoryBuilder、SessionFactory、Session的生命周期都是差不多。都支持JDBC和JIT事务处理。</p><p><strong>不同点：</strong></p><ul><li>Mybaits可以进行更为细致的SQL优化，可以减少字段查询</li><li>Mybatis容易掌握，Hibernate门槛比较高</li><li>Hibernate对对象的维护和缓存要比Mybatis简单，对增删改查的对象维护要方便</li><li>Hibernate数据库移植性比较好，Mybatis移植性不好，不同的数据库需要写不同的SQL</li><li>Hibernate有更好的二级缓存机制，可以使用第三方缓存。Mybatis本身提供的缓存机制不佳，更新操作不能刷新指定记录，会清空整个表，但是也可以使用第三方缓存。</li><li>Hibernate封装性比较好，屏蔽了数据库差异，自动生成了SQL语句，应对数据库变化能力较弱，SQL优化比较困难</li><li>MyBatis仅实现了SQL语句和对象的映射，需要针对具体的数据库写SQL语句，应对数据库变化能力较强，SQL语句优化较为方便。</li></ul><p><a href="https://blog.csdn.net/qq_40852784/article/details/79696008" target="_blank" rel="noopener">https://blog.csdn.net/qq_40852784/article/details/79696008</a></p></li><li><p>能描述一下Spring Context初始化的整个流程吗？</p><p><a href="https://blog.csdn.net/u010209217/article/details/80828067" target="_blank" rel="noopener">https://blog.csdn.net/u010209217/article/details/80828067</a></p></li><li><p>简单介绍一下Bean的生命周期和作用域吗？</p><p>在Spring中，组成应用程序的主体由SpringIOC容器所管理的对象，被称为Bean。简单讲，Bean就是由IOC容器初始化、装配、管理的对象。</p><p><strong>Bean的生命周期：</strong></p><p><code>Spring容器可以管理singleton作用域下Bean的生命周期，在此作用域下，Spring能够精确地知道Bean何时被创建，何时初始化完成，以及何时被销毁。而对于prototype作用域的Bean，Spring只负责创建，当容器创建了Bean的实例后，Bean的实例就交给了客户端的代码管理，Spring容器将不再跟踪其生命周期，并且不会管理那些被配置成prototype作用域的Bean的生命周期。</code></p></li></ol><ul><li><p>Spring对Bean进行实例化，默认Bean是单例；</p></li><li><p>Spring对Bean进行依赖注入；</p></li><li><p>如果Bean实现了BeanNameAware接口，Spring将Bean的id传给setBeanName()方法；</p></li><li><p>如果Bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory方法，将BeanFactory实例传进去；</p></li><li><p>如果Bean实现了ApplicationContextAware接口，它的SetApplicationContext方法将被调用，将应用上下文的引用传入到Bean中；</p></li><li><p>如果Bean实现了BeanPostProcessor接口，它的postProcessBeforeInitialization方法将被调用；</p></li><li><p>如果bean实现了InitializingBean接口，spring将调用它的afterPropertiesSet接口方法，类似的如果bean使用了init-method属性声明了初始化方法，该方法也会被调用；</p></li><li><p>如果bean实现了BeanPostProcessor接口，它的postProcessAfterInitialization接口方法将被调用；</p></li><li><p>此时bean已经准备就绪，可以被应用程序使用了，他们将一直驻留在应用上下文中，直到该应用上下文被销毁；</p></li><li><p>若bean实现了DisposableBean接口，spring将调用它的distroy()接口方法。同样的，如果bean使用了destroy-method属性声明了销毁方法，则该方法被调用；</p><p> <strong>Bean作用域：</strong></p></li><li><p>Singleton，唯一Bean实例</p></li><li><p>ProtoType，每次请求都会创建一个新的Bean实例</p></li><li><p>request，每一次 Http请求都会产生一个新的bean，该Bean仅在当前Http Request内有效</p></li><li><p>session，每一次 Http请求都会产生一个新的bean，该Bean仅在当前Http session内有效</p></li><li><p>globalSession，在一个全局的Http Session中，容器会返回该Bean的同一个实例，仅在使用portlet context时有效。</p><p> <a href="https://blog.csdn.net/fuzhongmin05/article/details/73389779" target="_blank" rel="noopener">https://blog.csdn.net/fuzhongmin05/article/details/73389779</a></p><p> <a href="https://www.cnblogs.com/zhanglei93/p/6231882.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhanglei93/p/6231882.html</a></p><p> <a href="http://www.pianshen.com/article/2914338821/" target="_blank" rel="noopener">http://www.pianshen.com/article/2914338821/</a></p></li></ul><p><strong>Spring的Bean默认都是单例的，这些单例bean在多线程程序下如何保证线程安全？</strong></p><p>Spring的单例都是基于BeanFactory也就是spring容器，单例Bean在次容器内只有一个，Java单例是基于JVM的，每个JVM内只有一个实例。在大多数情况下，单例Bean是很理想的方案。不过有时候你可能会发现你所使用的类是易变的，他们会保持一些状态，因此重用是不安全的。将class声明为单例就不是那么明智了。因为对象会被污染，再重用的时候就会出现问题。所以Spring定义了多种作用域。</p><ol start="4"><li><p>Spring配置中的palceholder占位符是如何替换的？有什么办法可以实现自定义的配置替换？</p></li><li><p>SpringMVC的工作流程是怎样的？</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1557385442923.png" alt="1557385442923"></p><ul><li>客户端发出一个http请求给web服务器，web服务器对url请求进行解析，如果匹配DispatcherServlet的请求映射路径（在web.xml文件中指定），web容器将请求转交给DispatcherServlet；</li><li>DispatcherSerlvet接受到这个请求之后将根据请求的信息以及HandlerMapping的配置找到处理请求的处理器(Handler)；</li><li>DispatcherSerlvet根据HandlerMapping找到对应的Handler，将处理权交给Handler，再由具体的HandlerAdapter对比Handler进行具体的调用（Controller，也叫后端控制器）；</li><li>Hanlder对数据处理完成以后将返回一个ModelAndView()对象给DispatcherSerlvet；</li><li>Handler返回的ModlAndView()只是一个逻辑视图并不是一个真正的视图，DispatcherServlet通过视图解析器（ViewResolver）将逻辑视图转换为真正的视图View（视图渲染）；</li><li>最终展现出完成的view并返回给客户端；</li></ul><p><a href="https://www.cnblogs.com/xiaoxi/p/6164383.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoxi/p/6164383.html</a></p></li><li><p>Spring如何解决循环依赖？</p><p><strong>循环依赖</strong></p><p>循环依赖就是循环引用，也就是两个或者两个以上的Bean互相持有对方，最终形成闭环。比如A依赖B，B依赖于C，C依赖于A。指的是对象的相互依赖。</p><p><strong>依赖场景</strong></p><p>（1）构造器的循环依赖<br>（2）field属性的循环依赖</p><p><strong>解决循环依赖</strong></p><p><a href="https://www.cnblogs.com/tiger-fu/p/8961361.html" target="_blank" rel="noopener">https://www.cnblogs.com/tiger-fu/p/8961361.html</a></p></li><li><p>Bean的构造方法、@PostConstruct注解、InitialzingBean、init-method的执行顺序是怎么样的？</p></li><li><p>RPC和Http的区别是什么？什么场景适合RPC，什么场景适合Http?</p><p>RPC我认为是一种协议应用的说法，而<code>http</code>是协议。<br>应用是基于协议之上的，所以有一种<code>rpc</code>的应用方式叫做基于http的rpc实现。</p><p><strong>区别：</strong></p><p>rpc不仅仅可以用http协议实现。</p><p>http只是rpc的载体、传输协议。但是宽泛起来也可以说，是rpc的一种实现。</p><p>json（jsonrpc），xml（xmlrpc），protobuf，等都只是一种序列化方法（codec）。</p><p>http，tcp，mq等都是传输协议。</p><p>rpc中，jsonrpc和xmlrpc一般认为是使用json和xml作为序列化方法，使用http作为传输媒介的rpc协议。</p></li><li><p>RPC的交互流程是怎样的？</p><p><a href="https://blog.csdn.net/heyeqingquan/article/details/78006587" target="_blank" rel="noopener">https://blog.csdn.net/heyeqingquan/article/details/78006587</a></p></li><li><p>请介绍一下Mybatis的缓存机制？</p><p><strong>一级缓存</strong></p><p><code>在应用程序运行过程中，我们可能再一次数据库会话中，执行多次查询条件完全相同的SQL，Mybatis提供了一级缓存的优化方案这部分场景，如果是相同的SQL语句，会优先命中一级缓存，避免直接对数据库进行查询，提供性能。每个SQLSession中持有了Executor，每个Executor中有一个LocalCache，当用户发起查询时，Mybatis根据当前执行的语句生成MappedStatement，在LocalCache进行查询，如果缓存命中的话，直接返回结果给用户，如果没有命中，查询数据库，结果写入LocalCache，最后结果返回给用户。</code></p><p><strong>一级缓存配置</strong></p><p><code>我们来看看如何使用MyBatis一级缓存。开发者只需在MyBatis的配置文件中，添加如下语句，就可以使用一级缓存。共有两个选项，</code>SESSION<code>或者</code>STATEMENT<code>，默认是</code>SESSION<code>级别，即在一个MyBatis会话中执行的所有语句，都会共享这一个缓存。一种是</code>STATEMENT<code>级别，可以理解为缓存只对当前执行的这一个</code>Statement<code>有效。</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"localCacheScope"</span> <span class="attr">value</span>=<span class="string">"SESSION"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>一级缓存总结</strong></p><ul><li>Mybatis的生命周期和SqlSession一致</li><li>Mybatis一级缓存内部设计简单，只是一个没有容量限制的HashMap，在缓存设计上有所欠缺</li><li>Mybatis一级缓存最大范围是SqlSession内部，有多个SqlSession或者分布式的环境下，数据读写会引起脏数据，建议设定缓存级别为statement</li></ul><p><strong>二级缓存</strong></p><p>如果多个SqlSession之间需要共享缓存，就需要使用二级缓存。开启二级缓存，会使用CachingExecutor，进入到一级缓存查询的流程前，先在CachingExecutor进行二级缓存的查询。</p><p>二级缓存开启后，同一个namespace下所有的查询操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享，是一个全局变量。当开启缓存后，数据库的查询流程就是 二级缓存 -&gt; 一级缓存 -&gt; 数据库</p><p><strong>二级缓存配置</strong></p><ul><li>在MyBatis的配置文件中开启二级缓存。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在MyBatis的映射XML中配置cache或者 cache-ref 。</p><p>cache标签用于声明这个namespace使用二级缓存，并且可以自定义配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>type</code>：cache使用的类型，默认是<code>PerpetualCache</code>，这在一级缓存中提到过。</li><li><code>eviction</code>： 定义回收的策略，常见的有FIFO，LRU。</li><li><code>flushInterval</code>： 配置一定时间自动刷新缓存，单位是毫秒。</li><li><code>size</code>： 最多缓存对象的个数。</li><li><code>readOnly</code>： 是否只读，若配置可读写，则需要对应的实体类能够序列化。</li><li><code>blocking</code>： 若缓存中找不到对应的key，是否会一直blocking，直到有对应的数据进入缓存。</li></ul><p><code>cache-ref</code>代表引用别的命名空间的Cache配置，两个命名空间的操作使用的是同一个Cache。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache-ref</span> <span class="attr">namespace</span>=<span class="string">"mapper.StudentMapper"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>二级缓存总结</strong></p><ul><li>MyBatis的二级缓存相对于一级缓存来说，实现了<code>SqlSession</code>之间缓存数据的共享，同时粒度更加的细，能够到<code>namespace</code>级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。</li><li>Mybatis在多表查询时，极大可能出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻</li><li>在分布式缓存下，由于默认的Mybatis Cache实现都是基于本地的，分布式环境下必然会出现脏数据，需要使用集中式缓存将Mybatis的Cache接口实现，有一定的开发成本，直接使用redis、Memcached等分布式缓存可能成本更低、安全性更高</li></ul><p><a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/01/19/mybatis-cache.html</a></p></li><li><p>Mybatis如何配置动态的sql?有哪些动态Sql标签？</p><p><if test="">…</if> 、<set> 、<where>、<trim></p></li></ol><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="考查点-3"><a href="#考查点-3" class="headerlink" title="考查点"></a>考查点</h4><ol><li>了解缓存使用场景，不同类型缓存的使用方式</li><li>掌握redis常用命令</li><li>了解redis在内存中的存储结构</li><li>了解redis的数据失效方式和剔除策略</li><li>了解redis的持久化、主从同步与cluster部署的原理</li></ol><h4 id="加分项-3"><a href="#加分项-3" class="headerlink" title="加分项"></a>加分项</h4><ol><li><p>结合实际应用场景来介绍缓存的使用</p></li><li><p>有用过分布式缓存设计和应用经验</p></li><li><p>了解缓存使用中可能产生的问题</p></li><li><p>知道redis典型的应用场景</p><p>排行榜、计数器、发布/订阅</p></li><li><p>知道redis的新特性</p></li></ol><h4 id="真题汇总-5"><a href="#真题汇总-5" class="headerlink" title="真题汇总"></a>真题汇总</h4><ol><li><p><strong>redis</strong>和<strong>memcached</strong>有什么区别？该如何使用？</p><ul><li><p>存储方式不同,memcache把所有数据存在内存中，数据不能超过内存大小，断电后数据会挂掉；</p></li><li><p>Redis有部分会存放在硬盘中，这样能保证数据的持久性；</p></li><li><p>数据支持类型不同 memcache对数据类型支持相对简单,redis有复杂的数据类型；</p></li><li><p>使用低层模型不同，他们之间底层的实现方式、以及客户端之间的通讯的应用协议不同。redis</p><p> 直接自己构建了VM机制，因为一般的系统调系统函数的话，会浪费一定的时间去移动和请求；</p></li><li><p>支持的value大小不一样 redis最大可以达到1GB，而memcache只有1MB；</p></li></ul><p><strong>Redis使用场景</strong></p><p>(1)、会话缓存（Session Cache）</p><p>(2)、全页缓存（FPC）</p><p>(3)、队列</p><p>(4)、排行榜、计数器</p><p>(5)、发布、订阅</p><p><a href="https://uule.iteye.com/blog/2429643" target="_blank" rel="noopener">https://uule.iteye.com/blog/2429643</a></p><p><a href="https://www.cnblogs.com/aspirant/p/8883871.html" target="_blank" rel="noopener">https://www.cnblogs.com/aspirant/p/8883871.html</a></p></li><li><p>你用过那些redis的数据结构？用在什么场景下？</p><p><a href="http://www.texixi.com/2016/04/27/Redis-%E8%BF%90%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">http://www.texixi.com/2016/04/27/Redis-%E8%BF%90%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E4%BB%8B%E7%BB%8D/</a></p></li><li><p>redis有那些持久化方式？区别是什么？</p><p><strong>持久化方式</strong></p><ul><li>RDB持久化能够在指定的时间间隔对你的数据进行快照存储</li><li>AOF持久化方式记录每次对服务器写的操作，当服务器重新启动的时候会重新执行这些命令来恢复原始的数据，AOF命令以redis协议追加保存每次写的操作到文件末尾</li></ul><p><strong>RDB的原理</strong></p><p><code>在Redis中RDB持久化的触发分为两种：自己手动触发和Redis定时触发</code></p><p>针对RDB方式的持久化，手动触发可以使用：</p><ul><li>save:会阻塞当前Redis服务器，直到持久化完成，线上应该禁止使用。</li><li>bgsave:该触发方式会fork一个子进程，由子进程负责持久化，因此阻塞只会发生在fork子进程的时候</li></ul><p>自动触发的场景有以下几点：</p><ul><li>根据我们的save m n 配置规则自动触发；</li><li>从节点全量复制时，主节点发送rdb文件给从节点完成复制操作，主节点触发bgsave；</li><li>执行debug reload时；</li><li>执行 <code>shutdown</code>时，如果没有开启aof，也会触发；</li></ul><p>由于 <code>save</code> 基本不会被使用到，我们重点看看 <code>bgsave</code> 这个命令是如何完成RDB的持久化的。</p><p><img src="D:%5Ctools%5Cwork%5C%E5%85%B6%E4%BB%96%5C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%5Cimages%5CRDB.png" alt=""></p><p><code>这里注意的是</code>fork<code>操作会阻塞，导致Redis读写性能下降。我们可以控制单个Redis实例的最大内存，来尽可能降低Redis在fork时的事件消耗。以及上面提到的自动触发的频率减少fork次数，或者使用手动触发，根据自己的机制来完成持久化。</code></p><p><strong>AOF的原理</strong></p><p>AOP的整体流程大体来看可以分为两步，一步是命令的实时写入(如果是appendfsync everysec配置，会有1s损耗)，第二步是对aof文件的重写。</p><p>对于增量追加到文件这一步的主要流程：命令写入=》追加到aof_buf=》同步到aof磁盘。那么这里为啥要先写入Buf同步到磁盘呢？如果实时写入磁盘会带来非常高的磁盘IO，影响整体性能。</p><p>AOF重写是为了减少aof文件大小，可以手动或者自动触发，关于自动触发的规则请看上面配置部分。fork的操作也是发生在重写这一步，也是这里会对主进程产生阻塞。</p><p><strong>手动触发：</strong><code>bgrewriteaof</code>，<strong>自动触发</strong> 就是根据配置规则来触发，当然自动触发的整体时间还跟Redis的定时任务频率有关系。</p><p><img src="D:%5Ctools%5Cwork%5C%E5%85%B6%E4%BB%96%5C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%5Cimages%5CAOF%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt=""></p><p>对于上图有四个关键点补充一下：</p><ol><li>在重写期间，由于主进程依然在响应命令，为了保证最终备份的完整性；因此它依然会写入旧的AOF file中，如果重写失败，能够保证数据不丢失。</li><li>为了把重写期间响应的写入信息也写入到新的文件中，因此也会为子进程保留一个buf，防止新写的file丢失数据。</li><li>重写是直接把当前内存的数据生成对应命令，并不需要读取老的AOF文件进行分析、命令合并。</li><li>AOF文件直接采用的文本协议，主要是兼容性好、追加方便、可读性高可认为修改修复。</li></ol><p><code>不管是RDB还是AOF都是先写入一个临时文件，然后通过</code>rename<code>完成文件的替换工作。</code></p><p><strong>区别：</strong></p><p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p><p>AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式追加记录，可以打开文件看到详细的操作记录。</p><p><a href="https://www.liangzl.com/get-article-detail-97255.html" target="_blank" rel="noopener">https://www.liangzl.com/get-article-detail-97255.html</a></p><p><a href="https://segmentfault.com/a/1190000015983518" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015983518</a></p><p><a href="https://segmentfault.com/a/1190000004491106" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004491106</a></p></li><li><p>redis过期策略是怎么样？redis有那些淘汰机制？</p><p><strong>过期策略：</strong>因为redis是基于内存来进行高可用、高并发的读写操作，既然是内存，那肯定有空间限制，如果只有10G内存，你一直往里面写数据，那肯定不行，所以就会采用一些过期策略把不需要的数据删除、或者淘汰掉。</p><p><strong>有哪些过期策略：</strong>定期删除、惰性删除</p><p>定期删除实现：所谓定期删除，指的是redis默认每隔100ms就随机抽取一些设置了过期时间的key，检查是否过期，如果过期就删除。</p><p><strong>为什么随机抽取？</strong></p><p>假如在redis里面插入了10w个key，并且都设置了过期时间，如果每次都检查所有的key，那cpu基本上消耗来在过期key的检查上，redis对外的性能也会大大的降低，简直就是一场灾难。</p><p><strong>随机检查会存在什么问题？</strong></p><p>可能会导致已经过期的Key没有被扫描到，而继续留在空间中，并占用空间，等待被删除。</p><p><strong>这种情况怎么解决？</strong></p><p>这时候就需要惰性删除了，就是在获取某个Key的时候，Redis会检查一下，如果这个Key设置了过期时间，并且已经过期了，那么就直接删除，返回空。</p><p><strong>如果大量的key没有被扫描到，且已过期，也没有被再次访问，即没有走惰性删除，这些大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，这种情况下，怎么办？</strong></p><p>Redis内部提供了内存淘汰机制，应该有好几种策略，但是我只知道LRU算法。</p><p><strong>redis淘汰机制：</strong></p><ul><li>noevication: 返回错误当内存限制达到并且客户端尝试执行让更多内存被使用的命令</li><li>allkeys-lru:尝试回收最少使用的键(LRU)，使得新添加的数据有空间存放</li><li>volatile-lru:尝试回收最少使用的键(LRU)，但仅限于在过期集合的键，使得新添加的数据有空间存放</li><li>allkeys-random: 回收随机的键使得新添加的数据有空间存放</li><li>volatile-random:回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键</li><li>volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放</li></ul><p><strong>手写LRU算法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cacheSize 缓存大小</span></span><br><span class="line"><span class="comment">     * true 表示让 linkedHashMap 按照访问顺序来进行排序，</span></span><br><span class="line"><span class="comment">     * 最近访问的放在头部，最老访问的放在尾部。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> cacheSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((<span class="keyword">int</span>) Math.ceil(cacheSize/<span class="number">0.75</span>)+<span class="number">1</span>,<span class="number">0.75f</span>,<span class="keyword">true</span>);</span><br><span class="line">        CACHE_SIZE = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当 map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size()&gt;CACHE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如何保证redis高可用和高并发？</p></li><li><p>如何使用redis实现延时队列？如何使用redis实现分布式锁？</p><p><strong>延时队列</strong></p><p><strong>分布式锁</strong></p><p><a href="https://segmentfault.com/a/1190000012919740" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012919740</a></p></li><li><p>美团针对Redis Rehash机制的探索和事件</p></li></ol><p><a href="https://tech.meituan.com/2018/07/27/redis-rehash-practice-optimization.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/07/27/redis-rehash-practice-optimization.html</a></p><ol start="8"><li>Redis高负载下的中断优化</li></ol><p><a href="https://tech.meituan.com/2018/03/16/redis-high-concurrency-optimization.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/03/16/redis-high-concurrency-optimization.html</a></p><ol start="8"><li>美团缓存那些事</li></ol><p><a href="https://tech.meituan.com/2017/03/17/cache-about.html" target="_blank" rel="noopener">https://tech.meituan.com/2017/03/17/cache-about.html</a></p><h3 id="消息队列和数据库"><a href="#消息队列和数据库" class="headerlink" title="消息队列和数据库"></a>消息队列和数据库</h3><h4 id="考查点-4"><a href="#考查点-4" class="headerlink" title="考查点"></a>考查点</h4><ol><li>了解消息队列、数据库的基本原理和常用队列、数据库的特点</li><li>了解Kafka的架构和消息处理流程</li><li>理解数据库事务的ACID特性和隔离级别</li><li>掌握常用的Mysql语句和函数</li><li>了解Mysql数据库不同引擎的特点以 及不同类型的索引实现</li></ol><h4 id="加分项-4"><a href="#加分项-4" class="headerlink" title="加分项"></a>加分项</h4><ol><li>了解新特性</li><li>知道数据调优经验</li><li>消息队列使用经验，不同场景下的取舍</li></ol><h4 id="真题汇总-6"><a href="#真题汇总-6" class="headerlink" title="真题汇总"></a>真题汇总</h4><ol><li><p>使用过消息队列吗？在什么场景下使用的？用来解决什么问题？</p></li><li><p>使用队列时如何保证可靠性？</p></li><li><p>MQ有可能发生重复消费吗？如何解决？</p></li><li><p>在数据库查询慢，如何优化？</p><p><strong>同6小节</strong></p></li><li><p>数据库事务有哪些特性？事务的隔离级别有哪几种？</p></li></ol><p><strong>事务特性：</strong></p><ul><li>原子性：一个事务必须视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。</li><li>一致性：数据库总数从一个一致性的状态转换到另一个一致性的状态</li><li>隔离性：一个事务所做的修改在最终提交以前，对其他事务是不可见的</li><li>持久性：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失</li></ul><p><strong>隔离级别：</strong></p><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（read-uncommitted）</td><td>是</td><td>是</td><td>是</td></tr><tr><td>不可重复读（read-committed）</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读（repeatable-read）</td><td>否</td><td>否</td><td>是</td></tr><tr><td>串行化（serializable）</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><p>链接：<a href="https://blog.csdn.net/csdnxingyuntian/article/details/57081233" target="_blank" rel="noopener">https://blog.csdn.net/csdnxingyuntian/article/details/57081233</a></p><ol start="6"><li>如何对sql语句进行优化？</li></ol><p><strong>优化方案</strong></p><ul><li>对查询进行优化，应尽量避免全表扫描，首先应考虑在where以及order by涉及的列上建议索引</li><li>应尽量避免在where子句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num is null</span><br></pre></td></tr></table></figure><p>  可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num&#x3D;0</span><br></pre></td></tr></table></figure><ul><li>应尽量避免在where使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</li><li>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num&#x3D;10 or num&#x3D;20</span><br></pre></td></tr></table></figure><ul><li>in 和 not in 也要慎用，否则会导致全表扫描</li><li>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</li><li>任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段</li><li>尽量的使用 varchar 代替 char ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些</li><li>避免频繁创建和删除临时表，以减少系统表资源的消耗</li><li>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销</li></ul><ol start="7"><li>消息队列设计精要？</li></ol><p>​    <a href="https://tech.meituan.com/2016/07/01/mq-design.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/07/01/mq-design.html</a></p><ol start="8"><li>Mysql索引原理以及慢查询优化</li></ol><p><a href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/06/30/mysql-index.html</a></p><ol start="9"><li>Kafka文件存储机制那些事</li></ol><p><a href="https://tech.meituan.com/2015/01/13/kafka-fs-design-theory.html" target="_blank" rel="noopener">https://tech.meituan.com/2015/01/13/kafka-fs-design-theory.html</a></p><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><h4 id="真题汇总-7"><a href="#真题汇总-7" class="headerlink" title="真题汇总"></a>真题汇总</h4><ol><li>Docker入门系列一：入门介绍</li></ol><p><a href="https://tech.meituan.com/2015/01/27/docker-introduction.html" target="_blank" rel="noopener">https://tech.meituan.com/2015/01/27/docker-introduction.html</a></p><ol start="2"><li>Docker系列二：基于容器的自动构建</li></ol><p><a href="https://tech.meituan.com/2015/03/10/auto-build.html" target="_blank" rel="noopener">https://tech.meituan.com/2015/03/10/auto-build.html</a></p><ol start="3"><li>微服务面试题</li></ol><p><a href="https://www.csrcrx.com/news/newsdetail-4817.html" target="_blank" rel="noopener">https://www.csrcrx.com/news/newsdetail-4817.html</a> （阿里面试题）</p><p><a href="http://www.pianshen.com/article/4093204511/" target="_blank" rel="noopener">http://www.pianshen.com/article/4093204511/</a></p><p><a href="https://my.oschina.net/u/3728166/blog/2961379" target="_blank" rel="noopener">https://my.oschina.net/u/3728166/blog/2961379</a></p><p><a href="http://www.3da4.com/thread-4948-1-1.html" target="_blank" rel="noopener">http://www.3da4.com/thread-4948-1-1.html</a></p><p><a href="https://www.cnblogs.com/kkdn/p/9074362.html" target="_blank" rel="noopener">https://www.cnblogs.com/kkdn/p/9074362.html</a></p><p><a href="https://blog.csdn.net/xjpdf10/article/details/82863397" target="_blank" rel="noopener">https://blog.csdn.net/xjpdf10/article/details/82863397</a></p><p><a href="https://www.liangzl.com/get-article-detail-19387.html" target="_blank" rel="noopener">https://www.liangzl.com/get-article-detail-19387.html</a></p><p><a href="https://segmentfault.com/a/1190000014766251?utm_source=tag-newest（Spring面试题）" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014766251?utm_source=tag-newest（Spring面试题）</a></p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1558454697660.png" alt="1558454697660"></p><h3 id="架构演进"><a href="#架构演进" class="headerlink" title="架构演进"></a>架构演进</h3><h4 id="考察点-1"><a href="#考察点-1" class="headerlink" title="考察点"></a>考察点</h4><ol><li>分布式架构的理解</li><li>了解系统优化的解决方法</li><li>对工作的熟悉程度</li></ol><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol><li>交代背景：Star法则</li><li>描述架构： 架构图交互流程</li><li>做了什么：重点突出</li><li>结果如何：用实例佐证</li><li>如何改进：存在的问题和解决方法</li><li>美团数据库高可用架构演讲与设想</li></ol><p><a href="https://tech.meituan.com/2017/06/29/database-availability-architecture.html" target="_blank" rel="noopener">https://tech.meituan.com/2017/06/29/database-availability-architecture.html</a></p><h3 id="HR面试"><a href="#HR面试" class="headerlink" title="HR面试"></a>HR面试</h3><ol><li><p>准备自我介绍？介绍内容要与简历一致</p></li><li><p>有什么业务爱好？不要只说自己爱读书、听音乐上网</p></li><li><p>谈谈你的缺点？不宜说出令人不放心、不舒服的缺点。不宜把那些明显的优点说成缺点。 </p><p><strong>我觉得我最近一年有一个缺点是我当小组长让我意识到自己的不足，我什么事情都不放心，都想亲力亲为，最后就导致自己的工作效率变低 了不少。我觉得自己应该放开手，既然是一个团队的，就应该相信他们可以把事情做好。如果真做的不对，可以再去帮助或者指导。</strong></p></li><li><p>与上级意见不一是，你将怎么办?</p><p><strong>我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。</strong></p></li><li><p>您在前一家公司的离职原因是什么?</p></li></ol><p>避免把”离职原因”说得太详细、太具体。也不能躲闪、回避，如”想换换环境”、”个人原因”等</p><p><a href="https://segmentfault.com/a/1190000018951978" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018951978</a></p><p><strong>写个程序猿的十条精进原则：</strong></p><p><a href="https://tech.meituan.com/2018/08/16/10-principles-for-engineers.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/08/16/10-principles-for-engineers.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法&lt;/h3&gt;&lt;h4 id=&quot;考查点&quot;&gt;&lt;a href=&quot;#考查点&quot; class=&quot;headerlink&quot; title=&quot;考查点&quot;&gt;&lt;/a&gt;考查点&lt;/h4&gt;&lt;o
      
    
    </summary>
    
    
    
      <category term="java常见面试题及答案" scheme="http://www.sumulige.com/tags/java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"/>
    
  </entry>
  
</feed>
