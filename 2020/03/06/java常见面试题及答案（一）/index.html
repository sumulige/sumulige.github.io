<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;zh-TW&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>java常见面试题及答案（一） | sumulige</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><script data-ad-client="ca-pub-9143006519047392" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">java常见面试题及答案（一）</h1><a id="logo" href="/.">sumulige</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/photograph"><i class="fa fa-photo"> photograph</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">java常见面试题及答案（一）</h1><div class="post-meta">Mar 6, 2020<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" href="/2020/03/06/java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%80%EF%BC%89/#vcomment"><span class="valine-comment-count" data-xid="/2020/03/06/java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%80%EF%BC%89/"></span><span> 条评论</span></a><div class="post-content"><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="考查点"><a href="#考查点" class="headerlink" title="考查点"></a>考查点</h4><ol>
<li>了解基本数据结构以及特点</li>
<li>表、栈、队列、树需要熟练掌握，深刻理解使用场景</li>
<li>了解常用的字符串处置算法</li>
<li>能够分析算法实现的复杂度</li>
<li>了解常用算法分类，解决问题的思路和解决那类问题</li>
</ol>
<h4 id="加分项"><a href="#加分项" class="headerlink" title="加分项"></a>加分项</h4><ol>
<li>能够将数据结构与实际使用场景结合</li>
<li>不同算法在业务场景中的应用</li>
<li>面对模糊题目能够沟通确认条件和边界</li>
<li>书写算法代码前，先讲一下解题思路</li>
<li>能够发现解答中的一些问题，给出改进思路</li>
</ol>
<p>####　真题汇总</p>
<ol>
<li>各种排序算法实现和复杂度、稳定性</li>
<li>二叉树的前、中、后序遍历</li>
<li>翻转句子中单词的顺序</li>
<li>用栈模拟队列</li>
<li>对10个亿数进行排序，限制内存1G</li>
<li>去掉两个数组中重复的数字</li>
<li>将一颗二叉树转换成其镜像</li>
<li>确定一个字符串中的括号是否匹配</li>
<li>给定一个开始词，一个结束词，一个字典，如何找到从开始词到结束词最短单词接龙路劲</li>
<li>如何查找两个二叉树节点得到最近公共祖先</li>
</ol>
<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ol>
<li>深入理解JVM内存模型</li>
<li>了解类加载机制</li>
<li>了解内存可见性</li>
<li>了解常用的GC算法实现和适用场景</li>
<li>能够根据业务场景适合JVM参数和GC算法</li>
</ol>
<p>加分项：</p>
<ol>
<li>编译器优化</li>
<li>问题排查经验和思路</li>
<li>JVM调优和调优思路</li>
<li>了解最新的技术趋势(ZGC、Graalvm)</li>
</ol>
<h4 id="真题汇总"><a href="#真题汇总" class="headerlink" title="真题汇总"></a>真题汇总</h4><ol>
<li>简单描述一下JVM内存模型?比较一下JVM内存结构、内存模型、对象模型的区别?</li>
</ol>
<p><strong>内存模型：</strong></p>
<p><code>Java内存模型（JMM）并不像JVM结构一样真实存在的，它只是一个抽象的概念。JMM是和多线程相关的，它描述了一组抽象的规则和规范，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。 简单总结，Java的多线程之间是通过共享内存进行通信的，而由于采用共享内存进行通信，在通信过程中会存在一系列如可见性、原子性、顺序一致性等问题，而JMM就是围绕多线程通信以及其相关的一系列特性建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。</code></p>
<p><img src="D:%5Ctools%5Cwork%5C%E5%85%B6%E4%BB%96%5C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%5Cimages%5CJMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt=""></p>
<p><a href="http://www.hollischuang.com/archives/2550" target="_blank" rel="noopener">http://www.hollischuang.com/archives/2550</a></p>
<p><strong>Java对象模型：</strong></p>
<p><code>Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。</code></p>
<p><code>HotSpot虚拟机中，设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。</code></p>
<p><code>每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个</code>instanceKlass<code>，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个</code>instanceOopDesc<code>对象，这个对象中包含了对象头以及实例数据。</code></p>
<p>   <img src="D:%5Ctools%5Cwork%5C%E5%85%B6%E4%BB%96%5C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%5Cimages%5CJava%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.png" alt=""></p>
<p>   这就是一个简单的Java对象的OOP-Klass模型，即Java对象模型。</p>
<p>   <strong>Java内存结构：</strong></p>
<p>   Java代码是运行在虚拟机上的，而虚拟机在执行Java程序的过程中把所管理的内存划分为若干个不同的数据区域，这些区域各有自己的用途。某些区域随着虚拟机进程的存在而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁。</p>
<p>   <img src="D:%5Ctools%5Cwork%5C%E5%85%B6%E4%BB%96%5C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%5Cimages%5CJVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt=""></p>
<p>   <strong>内存结构注意点：</strong></p>
<ul>
<li><p>以上是Java虚拟机规范，不同的虚拟机实现会各有不同，但是一般会遵守规范。</p>
</li>
<li><p>规范中定义的方法区，只是一种概念上的区域，并说明了其应该具有什么功能。但是并没有规定这个区域到底应该处于何处。所以，对于不同的虚拟机实现来说，是由一定的自由度的。</p>
</li>
<li><p>不同版本的方法区所处位置不同，上图中划分的是逻辑区域，并不是绝对意义上的物理区域。因为某些版本的JDK中方法区其实是在堆中实现的。</p>
</li>
<li><p>运行时常量池用于存放编译期生成的各种字面量和符号应用。但是，Java语言并不要求常量只有在编译期才能产生。比如在运行期，String.intern也会把新的常量放入池中。</p>
</li>
<li><p>除了以上介绍的JVM运行时内存外，还有一块内存区域可供使用，那就是直接内存。Java虚拟机规范并没有定义这块内存区域，所以他并不由JVM管理，是利用本地方法库直接在堆外申请的内存区域。</p>
</li>
<li><p>堆和栈的数据划分也不是绝对的，如HotSpot的JIT会针对对象分配做相应的优化。</p>
</li>
</ul>
<p>   <strong>内存模型是如何解决缓存一致性问题的？</strong></p>
<ul>
<li><p>通过在总线加<code>LOCK#</code>锁的方式；</p>
</li>
<li><p>通过缓存一致性协议（Cache Coherence Protocol）；</p>
<p> <strong>三者区别：</strong></p>
<ul>
<li><p>JVM结构：和java虚拟机的运行时区域有关；</p>
</li>
<li><p>Java内存模型：和Java并发有关系；</p>
</li>
<li><p>Java对象模型：和java对象在虚拟机中的表现形式有关</p>
<p><a href="http://www.hollischuang.com/archives/2509" target="_blank" rel="noopener">http://www.hollischuang.com/archives/2509</a>      </p>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p>什么情况下会触发FullGC? </p>
<p><strong>概念：</strong> <code>从年轻代空间(Eden和Survivor)回收内存被称为**Minor GC**，对老年代GC称为Major GC，而Full GC是对整个堆来说的，在最近几个版本的JDK默认对永生代即方法区的回收，出现FullGC的时候经常伴随着Minor GC，Major GC的速度一般会比Minor GC慢10倍以上。</code></p>
<p><strong>FullGC：</strong></p>
<ul>
<li>System.gc()方法的调用</li>
</ul>
<p><code>此方法的调用是建议JVM进行FullGC，虽然只是建议而非一定，但很多情况下它会触发FullGc，从而增加FullGC的频率，强烈建议能不使用此方法就不使用，让虚拟机自己去管理，可通过通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。</code></p>
<ul>
<li>老年代空间不足</li>
</ul>
<p><code>老年代空间只有在新生代对象传入以及创建为大对象、大数组才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：**java.lang.OutOfMemoryError: Java heap space** 。为避免以上两种状况引起的Full GC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</code></p>
<ul>
<li><p>永生代空间不足</p>
<p><code>JVM规范中运行时数据区域中的方法区，在HostSpot虚拟机又被称为永生代或者永生区，Permanent Generation中存放的为一些class信息、常量、静态变量等数据，当系统要加载类、反射的类、调用的方法比较多的时候，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：**ava.lang.OutOfMemoryError: PermGen space** 。为避免Perm Gen占满造成FullGC现象，可采用的方法为增大Perm Gen空间转为使用CMS GC。</code></p>
</li>
<li><p>CMS时出现promotion failed和concurrent mode failure</p>
</li>
<li><p>堆中分配了很大的对象</p>
<p><code>所谓大对象，是指需要大量连续内存空间的Java对象，例如很长的数组，此种对象会直接进入老年代，而老年代虽然有很大的剩余空间，但是无法找到足够大的连续空间来分配给当前对象，此种情况就会触发JVM进行FullGC。为了解决这个问题，CMS垃圾收集器提供了一个可配置的参数，即XX:+UseCMSCompactAtFullCollection开关参数，用于在“享受”完Full GC服务之后额外免费赠送一个碎片整理的过程，内存整理的过程无法并发的，空间碎片问题没有了，但提顿时间不得不变长了，JVM设计者们还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction,这个参数用于设置在执行多少次不压缩的Full GC后,跟着来一次带压缩的。</code></p>
</li>
</ul>
<p><a href="https://blog.csdn.net/chenleixing/article/details/46706039/" target="_blank" rel="noopener">https://blog.csdn.net/chenleixing/article/details/46706039/</a></p>
</li>
<li><p>java类加载器有几种？关系是怎样的？</p>
<p><code>每个编写的‘.java’扩展类文件都存储着需要执行的程序逻辑，这些java文件经过java编译器编译成扩展名为“.class”的文件，“.class”文件中保存着Java代码经过转换后的虚拟机指令，当需要使用某个类的时候，虚拟机将会加载它的class文件，并创建对应的class对象，将class文件加载到虚拟机的内存，这个过程叫做类加载过程。</code></p>
<p><img src="D:%5Ctools%5Cwork%5C%E5%85%B6%E4%BB%96%5C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%5Cimages%5C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt=""></p>
<ul>
<li>加载，类加载的过程一个阶段：通过一个类的完全限定查找此类字节码文件，并利用字节码文件创建一个class对象</li>
<li>验证，目的在于确保class文件的字节流包含信息符合当前虚拟机的要求，不会危害虚拟机自生安全。主要包含四种验证：文件格式验证、元数据验证、字节码验证、符合引用验证。</li>
<li>准备，为类变量(即static修饰的字段变量)分配内存并且设置该类变量的初始值为0。(如果static int i=5;这里只将i初始化为0，至于5的值将在初始化的时候赋值)，这里不包含用final修饰的static，因为final在编译的时候就分配了，注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是随着对象一起分配到堆中。</li>
<li>解析，主要将常量池中的符号引用替换为直接引用的过程。符号引用就是一组符号来描述目标，可以是任何字面量，而直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li>
<li>初始化，类加载到最后阶段，若该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化成员变量。</li>
</ul>
<p>类加载分为5个过程，而类加载的任务是根据一个类的全限定名来读取二进制字节流到JVM中，然后转换为一个与目标类对应的java.lang.class对象实例，在虚拟机提供了三种类加载器启动（Bootstrap）类加载器、扩展（Extension）类加载器、系统（System）类加载器（也称应用类加载器）。</p>
<p><strong>类加载：</strong></p>
<ul>
<li><p>启动(Bootstrap)类加载器</p>
<p>启动类加载器主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，是虚拟机自身的一部分，它负责将<code>&lt;JAVA_HOME&gt;/lib</code> 路径下的核心库或者 -xbootclasspath参数指定的路径下的jar包加载到内存中，注意必由于虚拟机是按照文件名识别加载jar包的，如rt.jar，如果文件名不被虚拟机识别，即使把jar包丢到lib目录下也是没有作用的（出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类）</p>
</li>
<li><p>扩展(Extension)类加载器</p>
<p>扩展类加载器是指Sun公司实现的<strong>sun.misc.Launcher$ExtClassLoader</strong>类，由Java实现，是Launcher的静态内部类，它负责加载<code>&lt;JAVA_HOME&gt;/lib/ext</code>目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用标准扩展类加载器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ExtClassLoader类中获取路径的代码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> File[] getExtDirs() &#123;</span><br><span class="line">     <span class="comment">//加载&lt;JAVA_HOME&gt;/lib/ext目录中的类库</span></span><br><span class="line">     String s = System.getProperty(<span class="string">"java.ext.dirs"</span>);</span><br><span class="line">     File[] dirs;</span><br><span class="line">     <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">         StringTokenizer st =</span><br><span class="line">             <span class="keyword">new</span> StringTokenizer(s, File.pathSeparator);</span><br><span class="line">         <span class="keyword">int</span> count = st.countTokens();</span><br><span class="line">         dirs = <span class="keyword">new</span> File[count];</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">             dirs[i] = <span class="keyword">new</span> File(st.nextToken());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         dirs = <span class="keyword">new</span> File[<span class="number">0</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> dirs;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>系统(System)类加载器</p>
<p>也称应用程序加载器是指 Sun公司实现的<code>sun.misc.Launcher$AppClassLoader</code>。它负责加载系统类路径 java - classpath或者-D java.class.path指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统加载器，一般情况下该类加载是程序默认的加载器，通过ClassLoader#getSystemClassLoader方法可以获取到该类加载器。</p>
</li>
</ul>
<p><strong>类加载器间的关系：</strong></p>
<ul>
<li>启动类加载器，由C++实现，没有父类</li>
<li>扩展类加载器（ExtClassLoader），由Java实现，父类加载器为Null</li>
<li>系统类加载器（AppClassLoader），由Java实现，父类加载器为ExtClassLoader</li>
<li>自定义加载器，父类加载器肯定是AppClassLoader</li>
</ul>
<p><strong>双亲委派流程：</strong></p>
<p>双亲委派模式是在java1.2后引入的，如果一个类加载器收到了类加载请求，它不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终到达顶层的启动类加载器，如果父类加载器可以完成加载任务，就成功返回，倘若父类加载器无法完成此类加载任务，子加载器才会尝试自己去加载，这就是双亲委派，即使每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我干不了，儿子才会自己想办法去完成。</p>
<p><strong>双亲委派优势：</strong></p>
<p>采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委派模式传递到启动类加载器，而启动类加载器在核心API发现这个名字的类，发现该类已经被加载，并不会重新加载网络传递过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。</p>
<p><strong>双亲委派破坏者：</strong></p>
<p>线程上下文类加载器。</p>
<p><a href="https://blog.csdn.net/javazejian/article/details/73413292" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/73413292</a></p>
</li>
<li><p>1.8为什么用Metaspace（元空间）替换掉PermGen（永久代）?Metaspace保存在哪？</p>
<p><strong>替换原因：</strong></p>
<ul>
<li>字符串在永久代中，很容易出现性能问题和内存溢出</li>
<li>类和方法的信息等比较难确定其大小，因此对永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出</li>
<li>永久代会为GC带来不必要的复杂度，并且回收率低</li>
<li>Oracle可能将HotSpot与JRockit合二为一</li>
</ul>
<p><strong>元空间保存不在虚拟机中，而是本地内存</strong></p>
<p><a href="https://www.cnblogs.com/paddix/p/5309550.html" target="_blank" rel="noopener">https://www.cnblogs.com/paddix/p/5309550.html</a></p>
<p><a href="http://www.cnblogs.com/duanxz/p/3520829.html" target="_blank" rel="noopener">http://www.cnblogs.com/duanxz/p/3520829.html</a></p>
</li>
<li><p>编译器会对指令做哪些优化？（简单描述编译器指令重排）</p>
<p><strong>优化：</strong></p>
<ul>
<li>程序顺序原则：一个线程内保证了语义的串行性</li>
<li>volatile规则：volatile变量的写，先发生于读，保证了volatile变量的可见性</li>
<li>锁规则：解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前</li>
<li>传递性：A先与B，B先于C，那么A必须先于C</li>
<li>线程的start方法先于他的每一个动作</li>
<li>线程的所有操作先于线程的终结（Thread.join()）</li>
<li>线程的中断（interrupt()）先于被中断线程的代码</li>
<li>对象的构造函数执行结束先于finalize()方法</li>
</ul>
<!--有疑问-->
</li>
<li><p>简单介绍一下volatile可以解决那些问题？如何做到？</p>
<p><strong>volatile：</strong></p>
<ul>
<li>内存可见性</li>
</ul>
<p>当写一个volatile变量时，JMM会把该线程对应的工作内存中的共享变量值刷新到主内存，当读取一个volatile变量时，JMM会把该线程对应的工作内存置为无效，那么该线程将只能从主内存中重新读取共享变量。</p>
<ul>
<li>指令重排序</li>
</ul>
<p>内存屏障，又称为内存栅栏，是一个CPU的指令，它的作用有两个，一个是保证特定操作的执行顺序，二是保证某些变量的内存可见性。由于编译器和处理器的都能执行指令重排序，如果在指令之间插入一条内存屏障则会告诉编译器和CPU，不管什么指令都不能和这条内存屏障指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序的优化。内存屏障的另一个作用就是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。总之，volatile变量正是通过内存屏障实现其在内存中的语义，即可见性和禁止重排优化。</p>
<p>非常典型的<strong>禁止重排优化</strong>的例子DCL：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DoubleCheckLock instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckLock</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckLock <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一次检测</span></span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckLock<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//多线程环境下可能会出现问题的地方</span></span><br><span class="line">                    instance = <span class="keyword">new</span> DoubleCheckLock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/javazejiarticle/details/72772461#volatile%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89" target="_blank" rel="noopener">https://blog.csdn.net/javazejiarticle/details/72772461#volatile%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89</a></p>
</li>
<li><p>简单描述一下GC的分代回收？</p>
<p><strong>为什么要分代？</strong></p>
<p><code>不同的对象生命周期是不一样的。因此，不同生命周期的对象可以采用不同的收集方式，以便提高回收效率。在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会 长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有 效果的，因为可能进行了很多次遍历，但是他们依旧存在。因此，分代垃圾回收采用分治的思想，进行代的划 分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。</code></p>
<p>垃圾回收器创建基于以下两个假设：</p>
<ul>
<li>大多数对象很快就会变得不可达</li>
<li>只有极少数情况会出现旧对象持有新对象的引用</li>
</ul>
<p>这两条假设被称为”<strong>弱分代假设</strong>“。为了证明此假设，在HotSpot VM中物理内存空间被划分为两部分：<strong>新生代(young generate)</strong>和<strong>老年代(old generation)</strong>。</p>
<p><strong>GC分代回收：</strong></p>
<p>虚拟机中共划分为三个代：年轻代、老年代、永久代</p>
<p><strong>新生代：</strong></p>
<p>大部分的新创建对象分配在新生代。因为大部分对象很快就会变得不可达，所以它们被分配在新生代，然后消失不再。当对象从新生代移除时，我们称之为”<strong>minor GC</strong>“。</p>
<p><strong>新生代的结构：</strong></p>
<ul>
<li>一个Eden区</li>
<li>两个Survivor区</li>
</ul>
<ol>
<li>大多数新生对象都被分配到Eden区</li>
<li>第一次GC过后Eden还存活的对象被移动到其中一个Survivor区</li>
<li>再次GC过程中，Eden还存活的对象会被移动到之前已经移入对象的Survivor区</li>
<li>一旦该Survivor区域无空间可用的时候，还存活的对象会从当前Survivor区移动到另外一个空的Survivor区。而当前Survivor区就会再次置为空状态</li>
<li>经过数次在两个Survivor区域移动后还存活的对象最后被移动到老年代。</li>
</ol>
<p><strong>两个Survivor区域在任何时候必定有一个保持空白。如果同时有数据存在于两个Survivor区或者两个区域的的使用量都是0，则意味着你的系统可能出现了运行错误。</strong></p>
<p><strong>老年代：</strong></p>
<p>存活在新生代中但未变为不可达的对象会被复制到老年代。一般来说老年代的内存空间比新生代大，所以在老年代GC发生的频率较新生代低一些。当对象从老年代被移除时，我们称之为”<strong>major GC</strong>“(或者<strong>full GC</strong>)。</p>
<p><strong>老年代垃圾回收：</strong></p>
<ul>
<li><p>Serial GC(-XX:+UseSerialGC)</p>
<p>在老年代，则使用了一种称之为”<strong>mark-sweep-compact</strong>“的算法。</p>
</li>
</ul>
<ol>
<li>首先该算法需要在老年代中标记出存活着的对象</li>
<li>然后从前到后检查堆空间中存活的对象，并保持位置不变</li>
<li>最后，把存活的对象移动到堆空间的前面部分以保持使用的堆空间的连续性，从而把堆空间分为两个部分：有对象和无对象(称为空间压缩)</li>
</ol>
<p>Serial GC适用于CPU核数较少且使用的内存空间较小的场景。</p>
<p>其中<strong>Serial GC务必不要在生产环境的服务器上使用</strong>，这种GC是为单核CPU上的桌面应用设计的。使用Serial GC会明显的损耗应用的性能。</p>
<ul>
<li>Paraller GC(-XX:+UseParallelGC)</li>
</ul>
<p>Serial GC使用单一线程执行GC，而parallel GC则使用多个线程并发执行，因此parallel GC 较serial GC具有更快的速度。Parallel GC适用于多核CPU且使用了较大内存空间的场景。Parallel GC又被称为”<strong>高吞吐GC(throughput GC)</strong>“</p>
<ul>
<li>Paraller Old GC(-XX:+UseParallelOldGC)</li>
</ul>
<p>在JDK 5中被引入，与Paraller GC相比唯一的区别在于Paraller的GC算法是为老年代设计的。它的执行过程分为三步：标记（Mark）-总结（Summary）-压缩(Commpaction)。其中summary步骤会会分别为存活的对象在已执行过GC的空间上标出位置，因此与mark-sweep-compact算法中的sweep步骤有所区别，并需要一些复杂步骤才能完成。</p>
<ul>
<li>CMS(-XX:+UseConcMarkSweepGC)</li>
</ul>
<p>​     从图上可看出并发标记-清理(Concurrent Mark-Sweep) GC比以后上其他GC都要复杂。开始时的初始标记(initial mark)比较简单，只有靠近类加载器的存活对象会被标记，因此停顿时间(stop-the-world)比较短暂。在并发标记(concurrent mark)阶段，由刚被确认和标记过的存活对象所关联的对象将被会跟踪和检测存活状态。此步骤的不同之处在于有多个线程并行处理此过程。在重标记(remark)阶段，由并发标记所关联的新增或中止的对象瘵被会检测。在最后的并发清理(concurrent sweep)阶段，垃圾回收过程被真正执行。在垃圾回收执行过程中，其他线程依然在执行。得益于CMS GC的执行方式，在GC期间系统中断时间非常短暂。CMS GC也被称为低延迟GC，适用于所有<strong>应用对响应时间要求比较严格的场景</strong>。</p>
<p>​       <strong>CMS缺点：</strong></p>
<p>​           1.与其他GC相比，CMS GC要求更多的内存空间和CPU资源</p>
<p>​           2.CMS GC默认不提供内存压缩</p>
<ul>
<li>G1</li>
</ul>
<p>每当一个区域分配满对象后，新创建的对象就会分配到另外一个区域，并开始执行GC。在这种GC中不会出现其他GC中的对象在新生代和老生代三区域中移动的现象。G1是为了取代在长期使用中暴露出大量问题且饱受抱怨的CMS GC。</p>
<p><a href="https://segmentfault.com/a/1190000004233812" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004233812</a></p>
<p><a href="https://blog.csdn.net/wangtaomtk/article/details/52263908" target="_blank" rel="noopener">https://blog.csdn.net/wangtaomtk/article/details/52263908</a></p>
</li>
<li><p>G1垃圾回收算法和CMS的区别有哪些？</p>
<p><strong>区别：</strong></p>
<ul>
<li>分代收集</li>
</ul>
<p>这个是现在垃圾收集器的标配，G1和CMS也不例外。但是G1同时回收老年代和年轻代，而CMS只能回收老年代，需要配合一个年轻代收集器。另外G1的分代更多是逻辑上的概念，G1将内存分成多个等大小的region，<code>Eden</code>/ <code>Survivor</code>/<code>Old</code>分别是一部分region的逻辑集合，物理上内存地址并不连续。</p>
<p>CMS在old GC的时候会回收整个Old区，对G1来说没有old gc概念，而是区分<code>Fully young gc</code>和<code>Mixed gc</code>，</p>
<p>前者对应年轻代的垃圾回收，后者混合了年轻代和部分老年代的收集，因此每次收集肯定会回收年轻代，老年代根据内存情况可以不回收或者回收部分或者全部。</p>
<ul>
<li>如何处理跨代引用</li>
<li>如何处理并发过程中的对象变化</li>
<li>Write Barrier</li>
<li>Full GC</li>
</ul>
<p><a href="https://www.jianshu.com/p/bdd6f03923d1" target="_blank" rel="noopener">https://www.jianshu.com/p/bdd6f03923d1</a></p>
</li>
<li><p>对象引用有哪些方式？有什么特点？</p>
</li>
</ol>
<p><strong>对象引用：</strong></p>
<ul>
<li><p>强引用</p>
</li>
<li><p>弱引用</p>
</li>
<li><p>软引用</p>
</li>
<li><p>虚引用</p>
</li>
</ul>
<p><a href="https://www.jianshu.com/p/6d264d02e992" target="_blank" rel="noopener">https://www.jianshu.com/p/6d264d02e992</a></p>
<ol start="10">
<li>使用过那些JVM调优工具？主要分析那些内容？</li>
</ol>
<p><a href="https://www.cnblogs.com/warehouse/p/9479104.html" target="_blank" rel="noopener">https://www.cnblogs.com/warehouse/p/9479104.html</a></p>
<ol start="11">
<li>JVM常见面试题：</li>
</ol>
<p>链接：</p>
<ul>
<li><a href="https://www.cnblogs.com/alsf/p/9398951.html" target="_blank" rel="noopener">https://www.cnblogs.com/alsf/p/9398951.html</a></li>
<li><a href="https://www.liangzl.com/get-article-detail-15614.html" target="_blank" rel="noopener">https://www.liangzl.com/get-article-detail-15614.html</a></li>
<li><a href="https://blog.csdn.net/sun1021873926/article/details/78002118" target="_blank" rel="noopener">https://blog.csdn.net/sun1021873926/article/details/78002118</a></li>
</ul>
<ol start="12">
<li><p>从实际案例中聊聊Java应用的GC优化</p>
<p><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html" target="_blank" rel="noopener">https://tech.meituan.com/2017/12/29/jvm-optimize.html</a></p>
</li>
<li><p>Java Hotspot G1 GC 的一些关键技术,</p>
<p><a href="https://tech.meituan.com/2016/09/23/g1.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/09/23/g1.html</a></p>
</li>
<li><p>常见性能优化策略的总结</p>
</li>
</ol>
<p><a href="https://tech.meituan.com/2016/12/02/performance-tunning.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/12/02/performance-tunning.html</a></p>
<ol start="15">
<li>性能优化模式</li>
</ol>
<p><a href="https://tech.meituan.com/2015/12/10/performance-tuning-pattern.html" target="_blank" rel="noopener">https://tech.meituan.com/2015/12/10/performance-tuning-pattern.html</a></p>
<h3 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h3><h4 id="常用设计模式与应用场景"><a href="#常用设计模式与应用场景" class="headerlink" title="常用设计模式与应用场景"></a>常用设计模式与应用场景</h4><p><strong>设计模式分为三个类：创建类模式、结构类模式、行为类模式；</strong></p>
<p><strong>创建类模式：</strong></p>
<ul>
<li>工厂方式模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类，使一个类的实例化延迟到其子类；</li>
<li>建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示；</li>
<li>抽象工厂模式：为创建一组相关或者相互依赖的对象提供一个接口，而且无须指定他们的具体类；</li>
<li>单例模式：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例；</li>
<li>原型模式：通过对象复制来实现的模式就叫做原型模式，用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象；</li>
</ul>
<p><strong>结构模式：</strong></p>
<ul>
<li>适配器模式：将一个类的接口变换成客户端所期待的另一种接口，从而使原本因不匹配而无法在一起工作的两个类能够在一起工作；</li>
<li>桥梁模式：将抽象与实现解耦，使得两者可以独立变换；</li>
<li>组合模式：将对象组合成树形结构以表示<strong>部分-整体</strong>的场次结构，使得用户对单个对象组合对象的使用具有一致性；</li>
<li>装饰模式：动态的给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活；</li>
<li>门面模式：要求一个子系统的外部与其内部通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使的子系统更易于使用；</li>
<li>享元模式：是池技术的重要实现方式，使得共享对象可有效地支持大量的细粒度的对象。</li>
<li>代理模式：为其对象提供一种代理以控制对这个对象的访问；</li>
</ul>
<p><strong>行为模式：</strong></p>
<ul>
<li>责任链模式：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系，将这些对象连 成一条链，并沿着这条链传递该请求，直到有对象处理它为止；</li>
<li>命令模式：这是一个高内聚的模式，将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能；</li>
<li>解释器模式：是一个种按照规定语法进行解析的方案；定义为：给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示业解释语言中的句子。</li>
<li>迭代模式：它提供一种方法访问一个容器对象中各个对象，而又不需要暴露该对象的内部细节。</li>
<li>中介者模式：用一个中介对象封装一系列对象的交互，中介者使各个对象不需要显示的相互作用，从而使其耦合松散，而且可以独立的改变他们之间的交互；</li>
<li>备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将对象恢复到原先保存的状态。通俗地讲，备忘录模式就是一个对象的备份模式，提供了一种程序数据的备份方法；</li>
<li>观察者模式：也叫做发布订阅模式，定义对象之间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新；</li>
<li>状态模式：状态模式是封装，状态的变更引起了行为变更。当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类；</li>
<li>策略模式：定义一组算法，将每个算法封装起来，并且使他们之间可以互换；</li>
<li>模板方法模式：定义一个操作中的算法框架，而将一些步骤延迟到子类中；使得子类可以不改变一个算法结构即可重定义该算法的某些框架；</li>
<li>访问者模式：封装一些作用于某种数据结构中的各个元素的操作，他可以在不改变数据结构的前提下定义作用这些元素的新操作；</li>
</ul>
<p><strong>常用设计模式：</strong></p>
<ul>
<li>单例模式</li>
</ul>
<p>基本概念：保证一个类仅有一个实例，并提供一个访问它的全局访问点；</p>
<p>常见写法：</p>
<p><strong>懒汉式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">/**持有私有静态实例，防止被引用，此处赋值为Null，目的是实现延迟加载**/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**私有构造方法，防止被实例化**/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**1.懒汉式，静态工程方法，创建实例**/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：延迟加载(需要的时候才去加载)，适合单线程操作；</p>
<p>缺点：线程不安全，在多线程很容易出现不同步的情况，如在数据库对象进行频繁的读写操作；</p>
<p><strong>双重线程检查模式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInner</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonInner sInst = <span class="keyword">null</span>; &lt;&lt;&lt; 这里添加了<span class="keyword">volatile</span></span><br><span class="line">    <span class="comment">/**私有的构造函数**/</span></span><br><span class="line">    <span class="keyword">private</span> SingletonInner&#123;&#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonInner <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SingletonInner inst = sInst;  &lt;&lt;&lt; 在这里创建了临时变量</span><br><span class="line">            <span class="keyword">if</span>(inst == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (SingletonInner<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                    inst = sInst;</span><br><span class="line">                    <span class="keyword">if</span>(inst == <span class="keyword">null</span>)&#123;</span><br><span class="line">                        inst = <span class="keyword">new</span> SingletonInner();</span><br><span class="line">                        sInst = inst;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;    </span><br><span class="line">          <span class="keyword">return</span> inst; &lt;&lt;&lt; 注意这里返回的是临时变量</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：延迟加载，线程安全</p>
<p>缺点：写法复杂，不简洁</p>
<p><strong>内部类的实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInner</span> </span>&#123;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 内部类实现单例模式 </span></span><br><span class="line"><span class="comment">     * 延迟加载，减少内存开销   </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> SingletonInner instance = <span class="keyword">new</span> SingletonInner();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 私有的构造函数 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonInner</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonInner <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"SingletonInner"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>工厂模式</li>
</ul>
<p>基本概念：为创建提供过渡接口，以便将创建对象的具体过程屏蔽起来，达到提高灵活性的目的；</p>
<p>分为三类：</p>
<ol>
<li>简单工厂模式：不利于产生系列产品；</li>
<li>工厂方法模式：又称为多型性工厂；</li>
<li>抽象工厂模式：又称为工具箱，产生产品族，但不利于产生新的产品；</li>
</ol>
<ul>
<li><p>建造模式</p>
<p>基本概念：是一种概念构建的设计模式，它可以将复杂对象的构建过程抽象出来，使这个抽象过程的不同实现方法可以构建出不同表现的对象。Builder模式生是一步一步创建一个复杂的对象，它允许用户可以指定复杂对象的类型和内容就可以构建他们。用户不知道内部的具体构建细节。Builder模式是非常类似抽象工厂模式，细微的区别大概只有在反复使用中才能体会到。</p>
<p>为何使用：</p>
<p>是为了将构建复杂对象的过程和它的部件解耦。注意：是解耦过程和部件。<br>因为一个复杂的对象，不但有很多大量组成部分，如汽车，有很多部件：车轮、方向盘、发动机，还有各种小零件等等，部件很多，但远不止这些，如何将这些部件装配成一辆汽车，这个装配过程也很复杂(需要很好的组装技术)，Builder模式就是为了将部件和组装过程分开。</p>
</li>
</ul>
<p><strong>Builder模式的应用</strong></p>
<p>在Java实际使用中，我们经常用到”池”(Pool)的概念，当资源提供者无法提供足够的资源，并且这些资源需要被很多用户反复共享时，就需要使用池。”池”实际是一段内存，当池中有一些复杂的资源的”断肢”(比如数据库的连接池，也许有时一个连接会中断)，如果循环再利用这些”断肢”，将提高内存使用效率，提高池的性能。修改Builder模式中Director类使之能诊断”断肢”断在哪个部件上，再修复这个部件。</p>
<ul>
<li>观察者模式</li>
</ul>
<p>基本概念：观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。观察者模式又叫发布-订阅(Publish/Subscribe)模式。</p>
<p><img src="D:%5Ctools%5Cwork%5C%E5%85%B6%E4%BB%96%5C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%5Cimages%5C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt=""></p>
<p>图是Observer 模式的结构图,让我们可以进行更方便的描述:</p>
<p>   Subject类：它把所有对观察者对象的引用保存在一个聚集里，每个主题都可以有任何数量的观察着。抽象主题提供一个接口，可以增加和删除观察着对象。</p>
<p>​    Observer类：抽象观察者，为所有的具体观察者定义一个接口，在得到主题的通知时更新自己</p>
<p>   ConcreteSubject类：具体主题，将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。</p>
<p>​    ConcreteObserver类：具体观察者，实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。</p>
<ul>
<li>代理模式</li>
</ul>
<p>基本概念：为其他对象提供一种代理以控制对这个对象的访问。也可以说，在出发点到目的地之间有一道中间层，意为代理。</p>
<p>为什么要使用：</p>
<ol>
<li>授权机制不同级别的用户对同一对象拥有不同的访问权利，如在论坛系统中，就使用Proxy进行授权机制，访问论坛有两种人：注册用户和游客，论坛通过类似ForumProxy这样的代理来控制这两种用户对论坛的访问权限</li>
<li>某个客户端不能直接操作某个对象，但又必须和那个对象有所互动。</li>
</ol>
<p><a href="https://www.cnblogs.com/cr330326/p/5627658.html" target="_blank" rel="noopener">https://www.cnblogs.com/cr330326/p/5627658.html</a></p>
<p><a href="https://www.hollischuang.com/archives/category/%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">https://www.hollischuang.com/archives/category/%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F</a></p>
<h4 id="Java语言特性"><a href="#Java语言特性" class="headerlink" title="Java语言特性"></a>Java语言特性</h4><ol>
<li><p>JUC：ConcurrentXXX、原子类、Executor、Caller&amp;&amp;Future、Queue、Locks</p>
</li>
<li><p>常用集合: <strong>HashMap、ConcurrentHashMap</strong>、ArrayList&amp;LinkedList、hashSet、TreeMap</p>
<p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：</p>
<p><img src="D:%5Ctools%5Cwork%5C%E5%85%B6%E4%BB%96%5C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%5Cimages%5CMap%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt=""></p>
<p>下面针对各个实现类的特点做一些说明：</p>
<p>（1）HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因为具有很快的访问速度，但遍历顺序却是不确定的。HashMap最多只允许一条记录的键为Null，运行多条记录的值为null。HashMap非线程安全，即任意时刻可以有多个线程同时写HashMap，可能会导致数据不一致。如果需要满足线程安全，可以用Collections的SynchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p>
<p>（2）HashTable：HashTable是遗留类，很多映射的常用功能和HashMap类似，不同的是它继承Distionary类，并且是线程安全的，任一时间只有一个线程能写HashTable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。HashTable不建议在新代码中使用，不需要线程安全的场合可以使用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p>
<p>（3）LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，再用Iterator遍历LinkedHashMap时，先得到记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p>
<p>（4）TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</p>
<p><strong>HashMap:</strong></p>
<p><strong>基本概念</strong></p>
<p>它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因为具有很快的访问速度，但遍历顺序却是不确定的。HashMap最多只允许一条记录的键为Null，运行多条记录的值为null。HashMap非线程安全，即任意时刻可以有多个线程同时写HashMap，可能会导致数据不一致。如果需要满足线程安全，可以用Collections的SynchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p>
<p><strong>存储结构</strong></p>
<p>HashMap结构图：</p>
<p>1.7 </p>
<p>![](D:\tools\work\其他\面试总结\images\1.7 HashMap结构图.png)</p>
</li>
</ol>
<p>   1.8 </p>
<p>   <img src="D:%5Ctools%5Cwork%5C%E5%85%B6%E4%BB%96%5C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%5Cimages%5C1.8HashMap%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt=""></p>
<p>   <strong>JDK8核心方法优化：</strong></p>
<p>   <strong>put方法</strong></p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line"> <span class="number">3</span>     <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"> <span class="number">4</span> &#125;</span><br><span class="line"> <span class="number">5</span> </span><br><span class="line"> <span class="number">6</span> <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">7</span>                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line"> <span class="number">8</span>     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"> <span class="number">9</span>     <span class="comment">// 步骤①：tab为空则创建</span></span><br><span class="line"><span class="number">10</span>     <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line"><span class="number">11</span>         n = (tab = resize()).length;</span><br><span class="line"><span class="number">12</span>     <span class="comment">// 步骤②：计算index，并对null做处理 </span></span><br><span class="line"><span class="number">13</span>     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) </span><br><span class="line"><span class="number">14</span>         tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="number">15</span>     <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">16</span>         Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="number">17</span>         <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></span><br><span class="line"><span class="number">18</span>         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line"><span class="number">19</span>             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="number">20</span>             e = p;</span><br><span class="line"><span class="number">21</span>         <span class="comment">// 步骤④：判断该链为红黑树</span></span><br><span class="line"><span class="number">22</span>         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line"><span class="number">23</span>             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="number">24</span>         <span class="comment">// 步骤⑤：该链为链表</span></span><br><span class="line"><span class="number">25</span>         <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">26</span>             <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line"><span class="number">27</span>                 <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">28</span>                     p.next = newNode(hash, key,value,<span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//链表长度大于8转换为红黑树进行处理</span></span><br><span class="line"><span class="number">29</span>                     <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st  </span></span><br><span class="line"><span class="number">30</span>                         treeifyBin(tab, hash);</span><br><span class="line"><span class="number">31</span>                     <span class="keyword">break</span>;</span><br><span class="line"><span class="number">32</span>                 &#125;</span><br><span class="line">                    <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line"><span class="number">33</span>                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line"><span class="number">34</span>                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) </span><br><span class="line"><span class="number">35</span>							<span class="keyword">break</span>;</span><br><span class="line"><span class="number">36</span>                 p = e;</span><br><span class="line"><span class="number">37</span>             &#125;</span><br><span class="line"><span class="number">38</span>         &#125;</span><br><span class="line"><span class="number">39</span>         </span><br><span class="line"><span class="number">40</span>         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line"><span class="number">41</span>             V oldValue = e.value;</span><br><span class="line"><span class="number">42</span>             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">43</span>                 e.value = value;</span><br><span class="line"><span class="number">44</span>             afterNodeAccess(e);</span><br><span class="line"><span class="number">45</span>             <span class="keyword">return</span> oldValue;</span><br><span class="line"><span class="number">46</span>         &#125;</span><br><span class="line"><span class="number">47</span>     &#125;</span><br><span class="line"><span class="number">48</span>     ++modCount;</span><br><span class="line"><span class="number">49</span>     <span class="comment">// 步骤⑥：超过最大容量 就扩容</span></span><br><span class="line"><span class="number">50</span>     <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line"><span class="number">51</span>         resize();</span><br><span class="line"><span class="number">52</span>     afterNodeInsertion(evict);</span><br><span class="line"><span class="number">53</span>     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="number">54</span> &#125;</span><br></pre></td></tr></table></figure>

   <!--Put方法分解-->

<pre><code>1. 判断当前桶是否为空，空的话就初始化
2. 根据当前key的hashcode定位到具体的桶中并判断是否为空，为空表明没有Hash冲突就直接在当前位置创建一个新桶
3. 如果当前桶有值（冲突），那么就要比较当前桶中的key、value的Hashcode与写入的key是否相等，相等就直接覆盖value
4. 如果当前桶为红黑树，那就要按照红黑树的方式写入数据
5. 如果是个链表，就需要将当前的key、value封装成一个新节点写入到当前桶的后面(形成链表)
6. 接着判断当前链表的大小是否大于设置的阈值，大于时就转换为红黑树
7. 如果在遍历过程中找到 key 相同时直接退出遍历。
8. 如果 `e != null` 就相当于存在相同的 key,那就需要将值覆盖。
9. 最后判断是否需要进行扩容。</code></pre><p>   <strong>get方法</strong></p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先将 key hash 之后取得所定位的桶。</p>
</li>
<li><p>如果桶为空则直接返回 null 。</p>
</li>
<li><p>否则判断桶的第一个位置(有可能是链表、红黑树)的 key 是否为查询的 key，是就直接返回 value。</p>
</li>
<li><p>如果第一个不匹配，则判断它的下一个是红黑树还是链表。</p>
</li>
<li><p>红黑树就按照树的查找方式返回值。</p>
</li>
<li><p>不然就按照链表的方式遍历匹配返回值。</p>
</li>
<li><p><strong>jdk1.8做了哪些优化？</strong></p>
<p>当 Hash 冲突严重时，在桶上形成的链表会变的越来越长，这样在查询时的效率就会越来越低；时间复杂度为 <code>O(N)</code>。在JDk1.8重点优化了这个查询效率。主要体现在两个核心方法（get/put）可以看出1.8对大链表做了优化，修改为红黑数之后查询效率直接提高到了O(logn)；</p>
<p>修改了几个重要的参数：</p>
</li>
</ul>
<ol>
<li>TREEIFY_THRESHOLD：用于判断是否需要将链表转换为红黑树的阈值</li>
<li>HashEntry修改为Node，Node 的核心组成其实也是和 1.7 中的 HashEntry 一样，存放的都是 <strong><code>key value hashcode next</code></strong> 等数据。</li>
</ol>
<ul>
<li><p>是线程安全的吗？</p>
<p>不是，在并发场景下，会出现死循环。HashMap 扩容的时候会调用 <code>resize()</code> 方法，就是这里的并发操作容易在一个桶上形成环形链表；这样当获取一个不存在的 key 时，计算出的 index 正好是环形链表的下标就会出现死循环。</p>
</li>
<li><p>JDK1.7和JDK1.8HashMap区别？</p>
</li>
</ul>
<p>   <strong>1.7</strong></p>
<p>   使用一个Entry数组来存储数据，用key的hashcode取模来决定key会被放到数组里的位置，如果hashcode相同，或者hashcode取模后的结果相同，那么这些key会被定位到Entry数组的同一个格子里，这些key会形成一个链表；在hash函数特别差的情况下，比如说所有key的hashcode都相同，这个链表可能会很长，那么put/get操作都可能需要遍历这个链表，也就是最差情况下时间复杂度为O（n）。<br>   <strong>1.8</strong></p>
<p>   使用一个node数组来存储数据，但是这个Node可能是链表结构，也可能是红黑树结构；如果插入的元素key的hashcode相同，那么这些key也会被定为到Node数组的同一个格子里，如果不超过8个使用链表存储，超过8个，会调用treeifyBin函数，将链表转为红黑树。那么即使所有key的hashcode完全相同，由于红黑树的特点，查找某个特定元素，也只需要O（logn）的开销。</p>
<p>   <strong>红黑树特性：</strong></p>
<ol>
<li>每个节点不是红的就是黑的；</li>
<li>根节点都是黑色，叶子节点指的是为空的节点</li>
<li>如果一个节点是红色的，那么它 的子节点一定是黑色的</li>
<li>从一个节点到该节点的子孙节点所有路径上包含相同数据的黑节点</li>
</ol>
<ul>
<li><p>如何解决？有没有线程安全的并发容器？</p>
<p>在不替换HashMap的情况下可以使用Collections.SynchronizedMap来保证Map的线程安全。第二个就是可以用ConcurrentHashMap。</p>
</li>
<li><p>如果两个键的hashcode相同，你如何获取对象？</p>
<p>当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket（散列桶）位置，找到bucket位置后，会调用key.equals()方法去找到链表中正确的节点，最终找到要找的值对象。</p>
</li>
<li><p>什么原因导致HashMap冲突的？</p>
<p>在HashMap中，哈希桶数组table的长度length大小必须是2的N次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设置为素数，相对来说素数导致冲突的概率要小于合数，Hashtable初始化桶大小是11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规的设计，主要是为了在取模和扩容的时候做优化，同时为了减少冲突，HashMap的定位哈希桶索引位置时，也加入了高位参与运算的过程。</p>
</li>
<li><p>有什么方法可以减少碰撞？</p>
</li>
</ul>
<p>   <strong>好的Hash算算法和扩容机制。</strong></p>
<p>  <strong>使用不可变的、声明为final对象，并且采用合适的hashCode()和equals()方法，将会减少碰撞</strong></p>
<p>   如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞。</p>
<p>   这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。</p>
<ul>
<li><p>为什么String、Integer这样的适合作为键？</p>
<p>因为String是final，而且已经重写了hashCode()和equals()方法了。不可变性是必要的，因为为了要计算HashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的 hashcode 的话，那么就不能从 HashMap 中找到你想要的对象。</p>
<p><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/06/24/java-hashmap.html</a></p>
<p><a href="https://segmentfault.com/a/1190000012926722?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012926722?utm_source=tag-newest</a></p>
<p><a href="http://www.importnew.com/31278.html" target="_blank" rel="noopener">http://www.importnew.com/31278.html</a></p>
<p><a href="http://www.codeceo.com/article/java-hashmap-concurrenthashmap.html" target="_blank" rel="noopener">http://www.codeceo.com/article/java-hashmap-concurrenthashmap.html</a></p>
</li>
</ul>
<p>   <strong>ConcurrentHashMap:</strong></p>
<p>   <strong>JDK1.7和JDK1.8的区别？</strong> </p>
<p>   （JDK1.7）</p>
<p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p>
<p>   put实现：当执行put方法插入数据的时候，先通过hash值在segment中找到对应的位置，然后如果相应位置的segment还未初始化，则通过CAS进行赋值，接着执行segment对象的put方法通过加锁机制插入数据。</p>
<p>  get实现：因为concurrenthashmap是可以并发插入数据的，所以准确计算元素时有一定的难度，所以是先采用不加锁的方式，连续计算元素的个数，最多计算3次，如果前后两次计算结果相同，那么说明元素个数是准确的；如果前后两次计算结果都不相同，则给每个segment加锁，再计算一次元素的个数。</p>
<p> （JDK1.8）</p>
<pre><code>ConcurrentHashMap抛弃了原有的Segment分段锁，采用了CAS+synchronized来保证并发安全性，其中的value 、next都用了volatile修饰，保证了可见性。</code></pre><p>最大特性是引入了CAS，借助unsafe来实现native code。CAS有三个操作数，内存值V、旧的预期值A、要修改的值B。当前仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。unsafe借助了CPU指令cmpxchg来实现的。</p>
<p>CAS出现的问题：ABA；解决：对变量增加一个版本号，每次修改版本号加1，比较的时候比较版本号。</p>
<p><strong>put实现：</strong></p>
<ul>
<li><p>如果Node还未初始化，那么通过CAS插入相应的数据；</p>
</li>
<li><p>如果Node不为空，且当前该节点不处于移动状态，那么对该节点加synchronized锁，如果该节点hash不小于0，则遍历链表更新节点或者插入新节点；</p>
</li>
<li><p>如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；</p>
</li>
<li><p>如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</p>
</li>
<li><p>如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</p>
</li>
</ul>
<p><strong>size实现：</strong> 1.8中使用一个volatile类型的变量baseCount记录元素的个数，当插入新数据或则删除数据时，会通过addCount()方法更新baseCount。因为元素个数保存baseCount中，部分元素的变化个数保存在CounterCell数组中，通过累加baseCount和CounterCell数组中的数量，即可得到元素的总个数。</p>
<p>   <a href="https://blog.csdn.net/majinggogogo/article/details/80042096" target="_blank" rel="noopener">https://blog.csdn.net/majinggogogo/article/details/80042096</a></p>
<p>   <a href="http://ifeve.com/concurrenthashmap/" target="_blank" rel="noopener">http://ifeve.com/concurrenthashmap/</a></p>
<p>   <a href="http://www.cnblogs.com/huangjuncong/p/9478505.html" target="_blank" rel="noopener">http://www.cnblogs.com/huangjuncong/p/9478505.html</a></p>
<p>   <a href="https://blog.csdn.net/bill_xiang_/article/details/81122044" target="_blank" rel="noopener">https://blog.csdn.net/bill_xiang_/article/details/81122044</a></p>
<p>   <a href="http://www.cnblogs.com/huangjuncong/p/9478505.html" target="_blank" rel="noopener">http://www.cnblogs.com/huangjuncong/p/9478505.html</a></p>
<p>   <a href="https://blog.csdn.net/woaiwym/article/details/80675789" target="_blank" rel="noopener">https://blog.csdn.net/woaiwym/article/details/80675789</a></p>
<ol start="3">
<li><p>动态代理与反射</p>
<p><strong>动态代理：</strong></p>
<p>大道理上讲代理是一种软件设计模式，目的地希望能做到代码重用。</p>
</li>
</ol>
<p>​    JDK动态代理：在java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。</p>
<p>​    CGLIB动态代理：通过cglib的jar包实现动态代理,该方法只需要对目标对象继承即可 </p>
<p>   <strong>反射：</strong></p>
<p>   <a href="https://blog.csdn.net/javazejian/article/details/70768369" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/70768369</a></p>
<ol start="4">
<li><p>数据类型：空间占用、基本数据结构、自动转型与强制转型、封装与拆箱 <!--（暂无总结）--></p>
</li>
<li><p>Java版本特性：1.8 Lambda表达式、Stream API、方法引用  <!--（暂无总结）--></p>
</li>
</ol>
<h4 id="真题汇总-1"><a href="#真题汇总-1" class="headerlink" title="真题汇总"></a>真题汇总</h4><ol>
<li><p>进程和线程的区别与联系</p>
<p><code>在过去没有线程的操作系统中，资源的分配和执行都是由进程完成的。随着技术的发展，为了减少由于进程切换带来的开销，提升并发能力，操作系统中引入线程。把原本属于进程的工作一分为二，进程还是负责资源的分配，而线程负责执行。</code></p>
<p><strong>进程是资源分配的基本单位，而线程是调度的基本单位。</strong></p>
<p><strong>开销方面：</strong>每个进程都有独立的代码和数据空间，程序之间的切换会有较大的开销；线程可以看作轻量级的进程，同一类线程共享代码和数据空间，每个线程都有独立的运行栈和程序计数器，线程之间的切换开销小；</p>
<p><strong>所处环境：</strong>在操作系统中能同时运行多个进程；而在同一个进程中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行 ）；分时操作系统把CPU的时间划分长短基本相同的时间区间，也就是时间片，通过操作时间管理，把这些时间片依次轮流地分配给各个用户 使用；</p>
<p><strong>内存分配方面：</strong>系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU，系统不会为线程分配内存，线程之间共享内存；</p>
</li>
<li><p>简单介绍一下进程的切换过程 <!--(暂无总结)--></p>
</li>
<li><p>你经常使用那些Linux 命令，主要用来解决那些问题</p>
<p>文件常用命令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd + 文件路径、 ls：查看当前文件下所有文件 、 pwd:查看当前所在路径、rm -rf 文件名：删除文件</span><br></pre></td></tr></table></figure>

<ul>
<li>top:查看cpu占有率</li>
<li>ps -ef |grep tomcat 查看tomcat是否启动</li>
<li>kill -9 进程号 杀死进程</li>
<li>tail -n 10 -f filename 查看文件filename最后十行并动态刷新</li>
<li>su root：从一般用户切换到root用户</li>
</ul>
</li>
<li><p>为什么TCP建连三次握手而断连需要四次？ <!--(暂无总结)--></p>
</li>
<li><p>为什么TCP关闭链接时需要Time_Wait状态？为什么要等2MSL? <!--(暂无总结)--></p>
</li>
<li><p>一次完整的Http请求过程是怎么样的？ <!--(暂无总结)--></p>
</li>
<li><p>Http2和Http的区别有哪些？</p>
<p><strong>二进制传输</strong></p>
<p>http2采用二进制传输，相较于文本传输的http1来说更加可靠</p>
<p><strong>多路复用</strong></p>
<p>http1一个连接只能提交一个请求；而http2可以同时处理无数个请求，可以降低连接的占用数量，进一步提升网络的吞吐量</p>
<p><strong>头部压缩</strong></p>
<p>http2通过gzip与compress对头部进行压缩，并且在客户端与服务端各维护了一份头部索引表，只需要根据索引id就可以进行头部信息的传输，缩小了头部容量，间接提升了传输效率。</p>
</li>
<li><p>在你的项目中使用过那些设计模式？主要用来解决什么问题？</p>
</li>
<li><p>final,finally,finalize的区别和使用场景？</p>
<ul>
<li>final：可以作为修饰符修饰变量、方法和类，被final修饰的变量只能一次赋值；被final修饰的方法不能在子类中被重写；被final修饰的类不能被继承；</li>
<li>finally：用在异常处理中定义总是执行的代码，无论try中的代码块是否引起了异常，finally中的代码总会执行；</li>
<li>finalize：此方法是Object类中定义的方法，当垃圾回收器将无用对象从内存中清除的时候，该对象的finalize方法被调用。</li>
</ul>
</li>
<li><p>简单描述一下java的异常机制？</p>
<p>Java把异常作为一种类，当做对象来处理。所有异常类的基类是Throwable类，两大子类分别是Error和Exception。这些异常类可以分为三种类型：系统错误、异常和运行时异常。系统错误由Java虚拟机抛出，用Error类表示。Error类描述的是内部系统错误，例如Java虚拟机崩溃。这种情况仅凭程序自身是无法处理的，在程序中也不会对Error异常进行捕捉和抛出。</p>
<p>异常（Exception）又分为RuntimeException(运行时异常)和CheckedException(检查异常)，两者区别如下：</p>
<ul>
<li>RuntimeException：程序运行过程中出现错误，才会被检查的异常。例如：类型错误转换，数组下标访问越界，空指针异常、找不到指定类等等。</li>
<li>CheckedException：来自于Exception且非运行时异常都是检查异常，编译器会强制检查并通过try-catch块来对其捕获，或者在方法头声明该异常，交给调用者处理。</li>
</ul>
<p>两种异常的处理方式：<strong>若是运行时异常，则表明程序出错，应该找到错误并修改，而不是对其捕获。若是检查异常，遵循该原则：谁知情谁处理，谁负责谁处理，谁导致谁处理。处理就是对其捕获并处理。</strong></p>
</li>
<li><p>美团酒店实时数据规则引擎应用实践</p>
</li>
</ol>
<p><a href="https://tech.meituan.com/2018/04/19/hb-rt-operation.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/04/19/hb-rt-operation.html</a></p>
<ol start="14">
<li>序列化和反序列化</li>
</ol>
<p><a href="https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html" target="_blank" rel="noopener">https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html</a></p>
<ol start="15">
<li>如何防止CSRF攻击？</li>
</ol>
<p><a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/10/11/fe-security-csrf.html</a></p>
<ol start="17">
<li>红黑树深入分析Java实现</li>
</ol>
<p><a href="https://tech.meituan.com/2016/12/02/redblack-tree.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/12/02/redblack-tree.html</a></p>
<ol start="18">
<li>Ajax 跨域问题如何解决？</li>
</ol>
<p><strong>JSONP</strong></p>
<p>JSONP的弊端有哪些？服务器需要改动代码支持、只支持get请求、发送的不是xhr请求</p>
<p>被调用方解决跨域，服务端如何实现：</p>
<ol>
<li><p>filter解决方法,添加拦截器，拦截所有请求。并设置允许那个域和什么请求可以访问到。如果设置所有域和方法就设置成*号。<br>简单请求和非简单请求：OPTIONS预检命令、OPTIONS预检命令缓存</p>
</li>
<li><p>Spring框架：加注解@CrossOrigin</p>
</li>
</ol>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h4><ol>
<li>理解线程的同步和互斥的原理</li>
<li>掌握线程安全相关机制</li>
<li>了解JUC工具的使用场景和实现原理</li>
<li>属性线程池的原理、使用场景、常用配置</li>
<li>理解线程的同步与异步、阻塞与非阻塞</li>
</ol>
<h4 id="加分项-1"><a href="#加分项-1" class="headerlink" title="加分项"></a>加分项</h4><ol>
<li><p>结合实际项目经验或者案例介绍原理</p>
</li>
<li><p>解决多线程问题排查思路和经验</p>
</li>
<li><p>熟悉常用的线程分析工具和方法</p>
</li>
<li><p>了解java8对JUC的增强</p>
<p><strong>并发工具方面：</strong></p>
<p>  新的类和接口：</p>
<ul>
<li>ConcurrentHashMap.keySetView&lt;K,V&gt;类：ConcurrentHashMap的键集合视图。</li>
<li>CompletionException:异常类</li>
</ul>
<p><strong>ConcurrentHashMap增加了新方法</strong></p>
<p>增加了30多个方法，包括foreach系列、reduce系列，增加后的concurrentHashMap更适合做缓存了。</p>
<p><strong>java.util.concurrent.atomic包改进</strong></p>
<p>增加了四个类：DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder</p>
<p><strong>增加StampedLock类</strong></p>
<p>stampedLock是一种新的锁实现，很可能在大多数场景都可以替换ReentrantReadWirteLock。它为读写锁提供了三种模式：Writing、ReadingOptimistic、Reading</p>
<p><a href="http://ifeve.com/java-se-8-concurrent-tool-enhance/" target="_blank" rel="noopener">http://ifeve.com/java-se-8-concurrent-tool-enhance/</a></p>
</li>
<li><p>了解Reactive异步编程思路 <strong>(暂无总结)</strong></p>
</li>
</ol>
<h4 id="真题汇总-2"><a href="#真题汇总-2" class="headerlink" title="真题汇总"></a>真题汇总</h4><ol>
<li><p><strong>如何实现生产和消费者模型？（锁、信号量、线程通信、阻塞队列等）</strong></p>
<p><a href="http://www.importnew.com/27063.html" target="_blank" rel="noopener">http://www.importnew.com/27063.html</a></p>
</li>
<li><p><strong>如何理解同步和异步、阻塞和非阻塞</strong>                                                 </p>
<p>IO : <a href="http://www.pig66.com/news/a/2018/0905/35468.html" target="_blank" rel="noopener">http://www.pig66.com/news/a/2018/0905/35468.html</a></p>
<p>回答：</p>
<p>（1）同步和异步关注的是<strong>消息通信机制</strong>。所谓同步就是在发出一个调用时，在没有得到结果之前，该调用就不会返回，但一旦调用返回，调用者就得到返回值了。简单的可以说：调用者主动等待这个调用结果。异步：调用在发出之后，这个调用就会直接返回了。所以没有返回结果。简单说：调用者不会立即得到结果，而是在调用发出后，被调用者用过状态、通知来通知调用者，或者通过回调函数处理这个调用。</p>
<p><strong>同步和异步举例</strong>：你打电话书店老板有没有《分布式系统》这本书，通过同步通信机制，书店老板会说，你稍微我查一下。等查好了告诉你结果。异步通信机制，书店老板会说，我查好 了给你打电话。然后查好了他会主动给你打电话。在这里老板通过“回电”这种方式来回调。</p>
<p>（2）阻塞和非阻塞关注的是<strong>程序在等待调用结果时候的状态</strong></p>
<p>   阻塞调用的是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。可以线程可以干其他事情。</p>
<p><strong>阻塞和非阻塞例子</strong>：你你打电话书店老板有没有《分布式系统》这本书，你如果是阻塞调用，你会一直把自己挂起，直到得到了这本书有没有结果，如果是非阻塞调用，你不管老板有没有告诉你，你自己先一边玩了，当然你也要偶尔问问老板有没有返回结果。</p>
</li>
<li><p><strong>线程池处理任务的流程是什么？</strong></p>
<p><strong>什么是线程池？</strong>帮我们重复管理线程，避免创建大量的线程增加开销，提高响应速度。</p>
<p>一个对象创建需要经过以下几步：</p>
<ul>
<li>检查对应的类是否已经被加载、解析和初始化</li>
<li>类加载后，为新生对象分配内存</li>
<li>将分配的内存空间初始为0</li>
<li>对对象进行关键信息的设置，比如对象的哈希码等</li>
<li>然后执行Init方法初始化对象</li>
</ul>
<p><strong>线程池的处理流程主要分为3步</strong></p>
<ul>
<li>提交任务后，线程池先判断线程数是否达到核心线程数(corePoolSize)。如果未达到线程数，则创建核心线程处理任务；否则就执行下一步；</li>
<li>接着线程池判断任务队列是否满了。如果没满，则将任务添加到任务队列中；否则，就执行下一步；</li>
<li>接着因为任务队列满了，线程池就判断线程数是否达到了最大线程数。如果未达到，则创建非核心线程处理任务；否则就执行饱和策略，默认会抛出RejectedExecutionException异常。</li>
</ul>
<p><strong>饱和策略：RejectedExecutionHandler</strong></p>
<p>当任务队列和线程池都满了采用的是应对策略，默认是AbordPolicy，表示无法处理新任务，并抛出RejectedExecutionException异常。此外还有3中策略：</p>
<ul>
<li>CallerRunsPolicy：用调用者所在的线程处理任务。此策略提供简单的反馈机制，能够减缓新任务的提交速度。</li>
<li>DiscardPolicy：不能执行任务，并将任务删除。</li>
<li>DiscardOldestPolicy：丢弃队列最近的任务，并执行当前的任务。</li>
</ul>
<p><strong>常见的四种线程池：</strong></p>
<ul>
<li><p><strong>CachedThreadPool</strong> 用于并发执行大量短期的小任务，或者是负载较轻的服务器。</p>
</li>
<li><p><strong>FixedThreadPool</strong> 用于负载比较重的服务器，为了资源的合理利用，需要限制当前线程数量。</p>
</li>
<li><p><strong>SingleThreadExecutor</strong> 用于串行执行任务的场景，每个任务必须按顺序执行，不需要并发执行。</p>
</li>
<li><p>*<em>ScheduledThreadPoolExecutor *</em>用于需要多个后台线程执行周期任务，同时需要限制线程数量的场景。</p>
<p>之前提供了四种线程池，在<strong>jdk8</strong>加入了newWorkStealingPool，变成了五种线程池，这是一个经常被人忽略的线程池。</p>
</li>
</ul>
<p><strong>考点分析：</strong></p>
<ul>
<li>掌握Executor框架的主要内容，至少了解组成与职责，掌握基本开发用例中的使用。</li>
<li>对线程池和相关开发工具类型的理解，甚至是源码层面的掌握。</li>
<li>实践中有哪些常见问题，基本的诊断思路是怎样的。 </li>
<li>如何根据自身应用特点合理使用线程池。</li>
</ul>
<p>链接：<a href="https://blog.csdn.net/u011240877/article/details/73440993" target="_blank" rel="noopener">https://blog.csdn.net/u011240877/article/details/73440993</a></p>
<p>​       <a href="http://www.cnblogs.com/superfj/p/7544971.html" target="_blank" rel="noopener">http://www.cnblogs.com/superfj/p/7544971.html</a></p>
</li>
<li><p><strong>wait和sleep有什么不同？</strong></p>
<p><strong>区别：</strong> </p>
<ul>
<li>sleep可以在任何地方使用；wait方法只能在同步方法和同步代码块中使用；</li>
<li>sleep是线程Thread类的方法，调用会暂停此线程指定的时间，但监控依然保持，不会释放对象锁，到时间自动恢复；wait()方法是object的方法，调用会放弃锁，进入到等待队列，待调用notify()/notifyAll()唤醒指定的线程或者所有线程，才会进入锁池，再次获得对象锁才会进入运行状态；</li>
</ul>
<p>链接： <a href="https://www.cnblogs.com/lyx210019/p/9427146.html" target="_blank" rel="noopener">https://www.cnblogs.com/lyx210019/p/9427146.html</a></p>
</li>
<li><p><strong>Synchronized和ReentrantLock有什么不同？</strong></p>
<p> <strong>不同：</strong></p>
<ul>
<li><p>功能区别：</p>
<p>synchronized是基于jvm底层实现的数据同步，lock是基于Java编写，主要通过硬件依赖CPU指令实现数据同步。</p>
<p>synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁。</p>
<p>出现异常的话，synchronized会自动释放锁。而ReenTrantLock需要手工释放锁，否则会出现造成死锁。</p>
<p>synchronized可重入，不可中断，默认是公平锁。ReenTrantLock可中断，可以设置锁是公平锁和非公平锁。</p>
</li>
<li><p>性能区别：在synchronized优化之前，它的性能比ReenTrantLock差很多，但是自从1.6 synchronized引入了偏向锁、轻量级锁、适应自旋锁后，两者的性能就差不多了，在两种情况都可用的情况下，官方建议使用synchronized。其实synchronized的优化我感觉借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。</p>
</li>
</ul>
<p>区别：<a href="https://www.cnblogs.com/jiangds/p/6476293.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiangds/p/6476293.html</a></p>
<p>两种锁的实现：<a href="https://blog.csdn.net/zxd8080666/article/details/83214089" target="_blank" rel="noopener">https://blog.csdn.net/zxd8080666/article/details/83214089</a></p>
</li>
<li><p><strong>读写锁适用于什么场景？ReentrantReadWriteLock是如何实现的？</strong></p>
<p><strong>应用场景：</strong>一些业务场景中，大部分只是读数据，写数据很少，如果仅仅是读数据的话并不会影响数据正确性（出现脏读），而如果在这种业务场景下，依然使用独占锁的话，很显然这将是出现性能瓶颈的地方。针对这种读多写少的情况，java还提供了另外一个实现Lock接口的ReentrantReadWriteLock(读写锁)</p>
<p><strong>如何实现：</strong></p>
<p>链接：<a href="https://www.jianshu.com/p/4a624281235e" target="_blank" rel="noopener">https://www.jianshu.com/p/4a624281235e</a></p>
<p><a href="https://blog.csdn.net/qq_19431333/article/details/70568478" target="_blank" rel="noopener">https://blog.csdn.net/qq_19431333/article/details/70568478</a></p>
<p><a href="https://www.cnblogs.com/xiaoxi/p/9140541.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoxi/p/9140541.html</a></p>
</li>
<li><p><strong>线程间是如何通信的？</strong></p>
<p><strong>如何通信：</strong></p>
<ul>
<li><p>等待通知机制</p>
</li>
<li><p>使用join方法，从源码中可以看出，join也是利用等待通知机制；</p>
</li>
<li><p>volatile共享内存，主要修饰为了内存可见性。</p>
</li>
<li><p>CountDownLatch工具，可以实现 join 相同的功能，但是更加的灵活；</p>
</li>
<li><p>CyclicBarrier并发工具</p>
</li>
<li><p>线程响应中断，调用了thread.interrput()方法，其实就是将thread中的一个标志属性设置为了true。</p>
</li>
<li><p>管道通信</p>
<p>答案链接：<a href="https://segmentfault.com/a/1190000013842437" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013842437</a></p>
</li>
</ul>
</li>
<li><p><strong>保证线程安全的方法有哪些？</strong></p>
<p><strong>保证线程安全的方法</strong></p>
<ul>
<li>synchronized</li>
<li>Lock</li>
</ul>
<p><strong>线程安全概念：</strong>能够正确的处理多个线程之间的共享变量，使程序功能正确的完成。</p>
<p>把线程安全拆解，可以总结出是<strong>并发、多线程、共享变量</strong>导致出现的线程安全问题。</p>
<p><strong>什么是并发：</strong>在操作系统中，指同一时间段中有几个程序都处于运行状态，且这几个程序都是在同一个处理机上运行。</p>
<p><strong>操作系统如何实现这种并发呢？</strong></p>
<p>现在我们用的操作系统，无论是Windows、Linux都是多用户多任务分时操作系统。使用这些操作系统用户是可以”同时“干很多事。但是实际上，对单CPU计算机来说，在CPU中，同一时间只能干一件事。</p>
<p>为了看起来像是同时干多件事，操作系统把CPU的时间划分成长短基本相同的时间区间，可以称为<strong>时间片</strong>，通过操作系统的管理，把这些时间片依次轮流的分配给各个用户使用。</p>
<p>如果某个作业在时间片结束之前，整个任务还有没有完成，那么该作业就会被暂停下来，放弃CPU，等待下一次再继续做。此时CPU又分配给另一个作业去使用。</p>
<p>由于计算器处理器速度很快，就算一个用户作业用完时间片到获得到下一个CPU时间片，中间有所停顿，但是用户察觉不出来，好像整个系统全由它独占一样。</p>
<p>所以，在CPU的计算机中，我们看起来同时干很多事，其实都是通过时间片技术并发来完成的。</p>
<p><strong>并发和并行之间的关系</strong></p>
<p>并行，当系统有一个以上CPU时，一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源。可以同时进行，这种方式我们称为并行。</p>
<p><strong>多线程和进程</strong></p>
<p>在多任务处理系统中，CPU需要处理所有程序的操作，当用户来回切换它们时，需要记录这些程序执行到哪里。在操作系统中，CPU切换到另一个进程需要保存当前进程的状态并恢复另一个进程的状态：当前运行任务转为就绪（或者挂起、删除）状态，另一个被选定的就绪任务成为当前任务。<strong>上下文切换</strong>就是这样一个过程，他允许CPU记录并恢复各种正在运行程序的状态，使它能够完成切换操作。</p>
<p><strong>共享变量</strong> 指的是多个线程都可以操作的变量。</p>
<p>在JVM中，java堆和方法区的区域是多个线程共享的数据区域。也就是说保存在堆和方法区中的变量就是Java共享变量。</p>
</li>
<li><p><strong>ThreadLocal用来解决什么？ThreadLocal是如何实现的？</strong></p>
<p>ThreadLocals是一个解决线程并发问题的一个类，用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用 同步技术。但是当我们不想使用同步技术的时候，我们可以使用ThreadLocal变量。</p>
<p>每个线程都会拥有它们自己的Thread变量，它们可以使用get/set方法去获取它们默认值或者线程内部改变它们的值。ThreadLocal实例通常是希望它们同线程状态关联起来。</p>
<p>底层实现主要是存有一个map,以线程为key,泛型作为value,可以理解为线程级别的缓存。每一个线程都获得一个单独的map.</p>
</li>
<li><p><strong>死锁的产生条件？如何分析是否有线程死锁？</strong></p>
<p>死锁是一种特定的状态，在实体之间，由于循环依赖导致彼此一直处于等待之中，没有任何个体可以继续前进。死锁不仅仅实在线程之间会发生，存在资源独占的线程之间同样也可能出现死锁。通常来说，我们大多数聚焦在多线程场景中的死锁，指两个线程或多个线程之间，由于相互持有对方需要的锁，而永久处于阻塞状态。</p>
<p><strong>如何定位：</strong>定位死锁最常见的方法就是利用jstack等工具获取线程栈，然后定位互相之间的依赖关系，进而找到死锁。如果有明显的死锁，往往jstack就能直接定位，类似JConsole甚至可以在图形界面进行有效的死锁检测。如果程序发生了死锁，绝大多数情况下都是无法在线解决的，只能重启，修正程序本身，所以在开发阶段互相审查，或者利用工具进行预防排查，就会显得很重要。</p>
<p>  <strong>死锁的发生：</strong><br>   1.互斥条件，类似Java中Monitor都是独占的，要么是我用，要么是你用。<br>   2.互斥条件是长期持有的，在使用结束之前，自己不会释放，也不能被其他线程抢占。<br>   3.循环依赖关系，两个或者多个个体之间出现了锁条环。<br>   <strong>编码预防死锁</strong>：<br>   1.尽可能避免使用多个锁，并且只有需要时才持有锁。<br>   2.如果必须使用多个锁，尽量设计好锁的获取顺序。<br>   3.使用带有超时的方法，为程序带来可控性。 </p>
</li>
<li><p><strong>在实际工作中遇到过什么并发问题？如何发现排查并解决的？</strong></p>
</li>
<li><p><strong>并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？</strong></p>
</li>
<li><p><strong>AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？</strong></p>
<p>AtomicInteger是对int类型的一个封装，提供原子性的访问和更新操作，其原子性操作实现是基于CAS技术。 所谓CAS，表征的是一些列操作的集合，获取当前数值，进行一些运算，利用CAS指令试图进行更新。如果当前数值未变，代表其他线程没有进行并发修改，则成功更新。否则，可能出现不同<br>的选择，要么进行重试，要么返回一个成功或者失败的结果。</p>
</li>
<li><p><strong>synchronized底层如何实现？什么是锁的升级和降级？</strong></p>
<p><strong>底层实现：</strong>synchronized代码块是由一对monitorenter/monitorexit指令实现的，Monitor对象是同步的基本实现单元。在java6之前，Monitor的实现完全依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级的操作。现在的jdk中，jvm对此进行了改进，提供了三种不同的Montior实现，也就是常说的三种不同的锁：偏向锁、轻量级锁、重量级锁，大大改进了其性能。<br><strong>锁的升级和降级：</strong>就是jvm优化synchronized运行的机制，当jvm检测到不同的竞争状态时，会自动切换到合适的锁实现，这种切换就是锁的升级和降级。<br>​      当没有竞争出现时候，默认时候的是偏向锁。JVM会利用CAS操作，在对象头上的mark word 部分设置线程ID,以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于很有应用场景中，大部分对象生命周期最多会被一个线程锁定，使用偏向锁可以降低无竞争开销。如果有其他线程试图锁定某个已经被偏向过的对象，JVM就需要撤销偏向锁，并切换到轻量级锁实现。轻量级锁依靠CAS操作Mark Word来试图获取锁，如果重试成功，就会使用普通的轻量级锁，否则，就会使用重量级锁。当JVM进入到安全点的时候，会检查 是否有闲置的Monitor，然后试图降级。</p>
<p><strong>其他锁，为什么我们需要读写锁等其他锁呢？</strong><br>   因为他们行为上有一定的局限性，要么不占，要么独占。实际应用场景中，有的时候不需要大量竞争写操作，而是以并发读取为主，为了进一步优化并发操作的粒度，并发包提供了读写锁等扩展锁的能力，它锁基于的原理就是多个读操作是不需要互斥的，因为读操作并不会更改数据，所以不存在互相干扰。而写操作则会导致并发一致性的问题，所以线程之间、读写线程之间、需要精心设置互斥逻辑。坏处是读写锁需要比较大的开销。</p>
<p> <strong>思考题，自旋锁是做什么的?它的使用场景是什么？</strong><br>   竞争锁失败的线程，并不会真实的在操作系统层面挂起等待，而是JVM会让线程做几个空循环，在经过若干次循环后，如果可以获取锁，那么就进入临界区，如果还不能获取锁，才会真实的将线程在操作系统层面挂起。在单核cpu上，自选锁是无用的，因为自旋锁尝试获取锁不成功会一直尝试，这会一直占用cpu，其他线程不可能执行，由于其他线程无法执行，所以当前无法释放锁。</p>
<p><strong>使用场景：</strong><br>​     自旋锁可以减少线程的开销，这对于线程竞争不激烈，且占用锁时间非常短的代码块来说，有较大的提升。因为自选的消耗会小于线程阻塞挂起操作的消耗。<br>​     如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步代码块，那么就不适用自旋锁了，因为自旋锁在获取锁前一直是占用cpu做无用功，线程自选的消耗大于线程阻塞挂起操作的消耗，造成cpu的浪费。</p>
<p>   自选锁在锁竞争中起到了什么作用？ 可以认为不是一种锁，而是针对短期等待的性能优化技术。</p>
</li>
<li><p>一个线程两次调用start()方法会出现什么情况？谈谈线程的生命周期和状态转移？</p>
<p><strong>出现情况：</strong> java的线程是不允许启动两次的，第二次调用会抛出IllegalThreadStateException,这是一种运行时异常，多次调用start被认为是编程错误。</p>
<p><strong>生命周期：</strong>关于线程生命周期的不同状态，在java5以后，线程状态被明确定义在其公共内部枚举类型java.lang.Thread.State 中，分别是：</p>
<ul>
<li>新建(NEW),表示线程被创建出来还没真正启动的状态，可以认为它是个Java内部状态。</li>
<li>就绪(RUNNABLE)，表示该线程已经在JVM中执行，当前由于执行需要计算资源，它可能正在运行，也可能还在等待系统分配给它CPU片，在就绪队列里面排队。 在其他一些分析中，会额外区分一种状态RUNNING，但是从javaAPI的角度，并不能表示出来。</li>
<li>.阻塞(BLOCKED),阻塞表示线程正在Monitor lock.比如，线程试图通过synchronized去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。</li>
<li>等待(WAITING),表示正在等待其他线程采取某些操作。一个常见的场景类似于生产者和消费者模式，发现任务条件尚未满足，就让当前消费者线程等待(wait),另外的生产者线程去准备任务数据，然后通过类似notify等动作，通知消费者可以继续工作。Thread.join()也会令线程进入到等待状态。计时等待(TIMED_WAIT)，其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如wait和join等方法的指定超时版本。</li>
<li>终止（TERMINATED），不管是意外退出还是正常执行结束，线程已经完成使命，终止运行，也有人把这个状态叫做死亡。</li>
</ul>
<ol start="17">
<li>不可不说的<strong>JAVA锁</strong>事</li>
</ol>
<p><a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/11/15/java-lock.html</a></p>
<ol start="18">
<li>高性能队列：Disruptor</li>
</ol>
<p><a href="https://tech.meituan.com/2016/11/18/disruptor.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/11/18/disruptor.html</a></p>
</li>
</ol>
<h3 id="常用工具集"><a href="#常用工具集" class="headerlink" title="常用工具集"></a>常用工具集</h3><h4 id="考查点-1"><a href="#考查点-1" class="headerlink" title="考查点"></a>考查点</h4><ol>
<li>了解常用的JVM分析工具</li>
<li>掌握git常用操作和工作流</li>
<li>了解Linux下常用的分析工具</li>
</ol>
<h4 id="真题汇总-3"><a href="#真题汇总-3" class="headerlink" title="真题汇总"></a>真题汇总</h4><ol>
<li><p>排查JVM问题有哪些常用工具？</p>
<ul>
<li>jps，显示系统内所有的JVM进程；</li>
<li>jstat，可以收集jvm相关的运行数据；</li>
<li>jinfo，显示jvm配置信息；</li>
<li>jhat，用于分析heapddump文件，他可以建立一个http/html服务，使用者可以在浏览器上查看分析结果；</li>
<li>jmap，用于生成jvm内存快照</li>
<li>jstack，显示jvm线程快照；</li>
</ul>
<p><a href="https://www.jianshu.com/p/4d13a09844bd" target="_blank" rel="noopener">https://www.jianshu.com/p/4d13a09844bd</a></p>
</li>
<li><p>git合并代码有哪两种方法？有什么区别？</p>
<p>git Merge：这种合并是将两个分支的历史合并到一起，现有的分支并不会被更改,它会比对双方不同的文件缓存下来，生成一个commit,去push</p>
<p>git Rebase：这种合并通常称之为“衍合”，他是修改提交历史，比对双方的commit，然后找出不同的去缓存，然后在去push，修改你的commit历史。</p>
</li>
<li><p>Git和svn的区别？</p>
<p>1.git是分布式的scm,svn是集中式的。(最核心)</p>
<p>2.git是每个历史版本都存储完整的文件,便于恢复,svn是存储差异文件,历史版本不可恢复。(核心)</p>
<p>3.git可离线完成大部分操作,svn则不能。</p>
<p>4.git有着更优雅的分支和合并实现。</p>
<p>5.git有着更强的撤销修改和修改历史版本的能力</p>
<p>6.git速度更快，效率更高</p>
</li>
</ol>
<h3 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h3><h4 id="考查点-2"><a href="#考查点-2" class="headerlink" title="考查点"></a>考查点</h4><ol>
<li><p>掌握Spring的IOC、AOP的概念与实现</p>
<p>链接：<a href="https://blog.csdn.net/javazejian/article/details/56267036" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/56267036</a></p>
<p>​           <a href="https://blog.csdn.net/javazejian/article/details/54561302" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/54561302</a></p>
</li>
<li><p>掌握Spring的Context 创建流程和Bean的生命周期</p>
</li>
<li><p>了解Spring常用注解的作用和使用方式</p>
<p><a href="https://www.cnblogs.com/leskang/p/5445698.html" target="_blank" rel="noopener">https://www.cnblogs.com/leskang/p/5445698.html</a></p>
</li>
<li><p>了解SpringBoot相关知识点</p>
</li>
<li><p>知道常用RPC框架的特点</p>
<p><a href="https://blog.csdn.net/u013952133/article/details/79256799" target="_blank" rel="noopener">https://blog.csdn.net/u013952133/article/details/79256799</a></p>
<p><a href="https://blog.csdn.net/quuqu/article/details/79304614" target="_blank" rel="noopener">https://blog.csdn.net/quuqu/article/details/79304614</a></p>
</li>
<li><p>了解Mybatis、Hibernate的实现原理</p>
</li>
</ol>
<h4 id="加分项-2"><a href="#加分项-2" class="headerlink" title="加分项"></a>加分项</h4><ol>
<li>阅读过框架源码，了解实现细节和思路</li>
<li>除了会用，还能理解理念</li>
<li>了解最新实现或者方向</li>
</ol>
<h4 id="真题汇总-4"><a href="#真题汇总-4" class="headerlink" title="真题汇总"></a>真题汇总</h4><ol>
<li><p>SSH和SSM框架组合的区别?</p>
<p>SSH:通常是指Strut2、Spring管理层组件、Hibernate负责持久化</p>
<p>SSM:指的则是SpringMVC控制器、Spring管理层组件、Mybatis负责持久化</p>
<p><strong>共同点：</strong> Spring依赖注入来管理各层的组件、使用面向切面编程AOP管理事务、日志等</p>
<p><strong>区别：</strong></p>
<p>  SSH和SSM不同主要在MVC实现方式，以及ORM持久化方面不同。SSM越来越轻量级配置，将注解开发发挥到了极致，而ORM实现更加灵活，SQL优化更加简便；而SSH比较注重配置开发，其中的Hibernate对JDBC完整封装更面向对象，对增删改查的数据维护更自动化，但是SQL优化方面比较弱，入门比较难。</p>
<p><strong>Struts实现：</strong></p>
<ul>
<li>客户端初始化一个指向servlet容器的请求</li>
<li>这个请求经过一系列Filter过滤器（这些过滤器中有一个叫做ActionContextCleanUp的可选过滤器，这个过滤器对struts2和其他框架集成很有帮助）</li>
<li>接着FilterDispatcher被调用，FilterDispatcher询问ActionMapper来决定这个请求是否需要调用某个action</li>
<li>如果actionMapper决定调用某个action，FilterDispatcher把这个请求交给ActionProxy</li>
<li>ActionProxy通过Configuration Mapper询问框架的配置文件，找到需要调用的Action类</li>
<li>ActionProxy创建一个ActionInvocation的实例</li>
<li>ActionInvocation实例使用命名模式来调用，在调用action过程前后，涉及到相关拦截器的调用。</li>
<li>一旦action执行完毕，ActionInvocation负责根据strut.xml的配置找到对应的返回结果。返回结果通常是一个需要被表示的jsp或者freemarker的模板。</li>
<li>将处理结果返回给客户端。</li>
</ul>
<p><strong>SpingMVC实现原理：</strong></p>
<ul>
<li>客户端发出一个http请求给web服务器，web服务器对url请求进行解析，如果匹配DispatcherServlet的请求映射路径（在web.xml文件中指定），web容器将请求转交给DispatcherServlet.</li>
<li>DispatcherSerlvet接受到这个请求之后将根据请求的信息以及HandlerMapping的配置找到处理请求的处理器(Handler)</li>
<li>DispatcherSerlvet根据HandlerMapping找到对应的Handler，将处理权交给Handler，再由具体的HandlerAdapter对比Handler进行具体的调用。</li>
<li>Hanlder对数据处理完成以后将返回一个ModelAndView()对象给DispatcherSerlvet</li>
<li>Handler返回的ModlAndView()只是一个逻辑视图并不是一个真正的视图，DispatcherServlet通过ViewResolver将逻辑视图转换为真正的视图View</li>
<li>Dispather通过model解析出ModelAndView()中的参数进行解析最终展现出完成的view并返回给客户端</li>
</ul>
<p><strong>Hibernate和Mybatis的对比</strong></p>
<p><strong>相同点：</strong>都是通过SessionFactoryBuilder由XML配置文件生成SessionFactory，然后由SessionFactory生成Session，最后都是由Session来开启执行事务和SQL语句。其中SessionFactoryBuilder、SessionFactory、Session的生命周期都是差不多。都支持JDBC和JIT事务处理。</p>
<p><strong>不同点：</strong></p>
<ul>
<li>Mybaits可以进行更为细致的SQL优化，可以减少字段查询</li>
<li>Mybatis容易掌握，Hibernate门槛比较高</li>
<li>Hibernate对对象的维护和缓存要比Mybatis简单，对增删改查的对象维护要方便</li>
<li>Hibernate数据库移植性比较好，Mybatis移植性不好，不同的数据库需要写不同的SQL</li>
<li>Hibernate有更好的二级缓存机制，可以使用第三方缓存。Mybatis本身提供的缓存机制不佳，更新操作不能刷新指定记录，会清空整个表，但是也可以使用第三方缓存。</li>
<li>Hibernate封装性比较好，屏蔽了数据库差异，自动生成了SQL语句，应对数据库变化能力较弱，SQL优化比较困难</li>
<li>MyBatis仅实现了SQL语句和对象的映射，需要针对具体的数据库写SQL语句，应对数据库变化能力较强，SQL语句优化较为方便。</li>
</ul>
<p><a href="https://blog.csdn.net/qq_40852784/article/details/79696008" target="_blank" rel="noopener">https://blog.csdn.net/qq_40852784/article/details/79696008</a></p>
</li>
<li><p>能描述一下Spring Context初始化的整个流程吗？</p>
<p><a href="https://blog.csdn.net/u010209217/article/details/80828067" target="_blank" rel="noopener">https://blog.csdn.net/u010209217/article/details/80828067</a></p>
</li>
<li><p>简单介绍一下Bean的生命周期和作用域吗？</p>
<p>在Spring中，组成应用程序的主体由SpringIOC容器所管理的对象，被称为Bean。简单讲，Bean就是由IOC容器初始化、装配、管理的对象。</p>
<p><strong>Bean的生命周期：</strong></p>
<p><code>Spring容器可以管理singleton作用域下Bean的生命周期，在此作用域下，Spring能够精确地知道Bean何时被创建，何时初始化完成，以及何时被销毁。而对于prototype作用域的Bean，Spring只负责创建，当容器创建了Bean的实例后，Bean的实例就交给了客户端的代码管理，Spring容器将不再跟踪其生命周期，并且不会管理那些被配置成prototype作用域的Bean的生命周期。</code></p>
</li>
</ol>
<ul>
<li><p>Spring对Bean进行实例化，默认Bean是单例；</p>
</li>
<li><p>Spring对Bean进行依赖注入；</p>
</li>
<li><p>如果Bean实现了BeanNameAware接口，Spring将Bean的id传给setBeanName()方法；</p>
</li>
<li><p>如果Bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory方法，将BeanFactory实例传进去；</p>
</li>
<li><p>如果Bean实现了ApplicationContextAware接口，它的SetApplicationContext方法将被调用，将应用上下文的引用传入到Bean中；</p>
</li>
<li><p>如果Bean实现了BeanPostProcessor接口，它的postProcessBeforeInitialization方法将被调用；</p>
</li>
<li><p>如果bean实现了InitializingBean接口，spring将调用它的afterPropertiesSet接口方法，类似的如果bean使用了init-method属性声明了初始化方法，该方法也会被调用；</p>
</li>
<li><p>如果bean实现了BeanPostProcessor接口，它的postProcessAfterInitialization接口方法将被调用；</p>
</li>
<li><p>此时bean已经准备就绪，可以被应用程序使用了，他们将一直驻留在应用上下文中，直到该应用上下文被销毁；</p>
</li>
<li><p>若bean实现了DisposableBean接口，spring将调用它的distroy()接口方法。同样的，如果bean使用了destroy-method属性声明了销毁方法，则该方法被调用；</p>
<p> <strong>Bean作用域：</strong></p>
</li>
<li><p>Singleton，唯一Bean实例</p>
</li>
<li><p>ProtoType，每次请求都会创建一个新的Bean实例</p>
</li>
<li><p>request，每一次 Http请求都会产生一个新的bean，该Bean仅在当前Http Request内有效</p>
</li>
<li><p>session，每一次 Http请求都会产生一个新的bean，该Bean仅在当前Http session内有效</p>
</li>
<li><p>globalSession，在一个全局的Http Session中，容器会返回该Bean的同一个实例，仅在使用portlet context时有效。</p>
<p> <a href="https://blog.csdn.net/fuzhongmin05/article/details/73389779" target="_blank" rel="noopener">https://blog.csdn.net/fuzhongmin05/article/details/73389779</a></p>
<p> <a href="https://www.cnblogs.com/zhanglei93/p/6231882.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhanglei93/p/6231882.html</a></p>
<p> <a href="http://www.pianshen.com/article/2914338821/" target="_blank" rel="noopener">http://www.pianshen.com/article/2914338821/</a></p>
</li>
</ul>
<p><strong>Spring的Bean默认都是单例的，这些单例bean在多线程程序下如何保证线程安全？</strong></p>
<p>Spring的单例都是基于BeanFactory也就是spring容器，单例Bean在次容器内只有一个，Java单例是基于JVM的，每个JVM内只有一个实例。在大多数情况下，单例Bean是很理想的方案。不过有时候你可能会发现你所使用的类是易变的，他们会保持一些状态，因此重用是不安全的。将class声明为单例就不是那么明智了。因为对象会被污染，再重用的时候就会出现问题。所以Spring定义了多种作用域。</p>
<ol start="4">
<li><p>Spring配置中的palceholder占位符是如何替换的？有什么办法可以实现自定义的配置替换？</p>
</li>
<li><p>SpringMVC的工作流程是怎样的？</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1557385442923.png" alt="1557385442923"></p>
<ul>
<li>客户端发出一个http请求给web服务器，web服务器对url请求进行解析，如果匹配DispatcherServlet的请求映射路径（在web.xml文件中指定），web容器将请求转交给DispatcherServlet；</li>
<li>DispatcherSerlvet接受到这个请求之后将根据请求的信息以及HandlerMapping的配置找到处理请求的处理器(Handler)；</li>
<li>DispatcherSerlvet根据HandlerMapping找到对应的Handler，将处理权交给Handler，再由具体的HandlerAdapter对比Handler进行具体的调用（Controller，也叫后端控制器）；</li>
<li>Hanlder对数据处理完成以后将返回一个ModelAndView()对象给DispatcherSerlvet；</li>
<li>Handler返回的ModlAndView()只是一个逻辑视图并不是一个真正的视图，DispatcherServlet通过视图解析器（ViewResolver）将逻辑视图转换为真正的视图View（视图渲染）；</li>
<li>最终展现出完成的view并返回给客户端；</li>
</ul>
<p><a href="https://www.cnblogs.com/xiaoxi/p/6164383.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoxi/p/6164383.html</a></p>
</li>
<li><p>Spring如何解决循环依赖？</p>
<p><strong>循环依赖</strong></p>
<p>循环依赖就是循环引用，也就是两个或者两个以上的Bean互相持有对方，最终形成闭环。比如A依赖B，B依赖于C，C依赖于A。指的是对象的相互依赖。</p>
<p><strong>依赖场景</strong></p>
<p>（1）构造器的循环依赖<br>（2）field属性的循环依赖</p>
<p><strong>解决循环依赖</strong></p>
<p><a href="https://www.cnblogs.com/tiger-fu/p/8961361.html" target="_blank" rel="noopener">https://www.cnblogs.com/tiger-fu/p/8961361.html</a></p>
</li>
<li><p>Bean的构造方法、@PostConstruct注解、InitialzingBean、init-method的执行顺序是怎么样的？</p>
</li>
<li><p>RPC和Http的区别是什么？什么场景适合RPC，什么场景适合Http?</p>
<p>RPC我认为是一种协议应用的说法，而<code>http</code>是协议。<br>应用是基于协议之上的，所以有一种<code>rpc</code>的应用方式叫做基于http的rpc实现。</p>
<p><strong>区别：</strong></p>
<p>rpc不仅仅可以用http协议实现。</p>
<p>http只是rpc的载体、传输协议。但是宽泛起来也可以说，是rpc的一种实现。</p>
<p>json（jsonrpc），xml（xmlrpc），protobuf，等都只是一种序列化方法（codec）。</p>
<p>http，tcp，mq等都是传输协议。</p>
<p>rpc中，jsonrpc和xmlrpc一般认为是使用json和xml作为序列化方法，使用http作为传输媒介的rpc协议。</p>
</li>
<li><p>RPC的交互流程是怎样的？</p>
<p><a href="https://blog.csdn.net/heyeqingquan/article/details/78006587" target="_blank" rel="noopener">https://blog.csdn.net/heyeqingquan/article/details/78006587</a></p>
</li>
<li><p>请介绍一下Mybatis的缓存机制？</p>
<p><strong>一级缓存</strong></p>
<p><code>在应用程序运行过程中，我们可能再一次数据库会话中，执行多次查询条件完全相同的SQL，Mybatis提供了一级缓存的优化方案这部分场景，如果是相同的SQL语句，会优先命中一级缓存，避免直接对数据库进行查询，提供性能。每个SQLSession中持有了Executor，每个Executor中有一个LocalCache，当用户发起查询时，Mybatis根据当前执行的语句生成MappedStatement，在LocalCache进行查询，如果缓存命中的话，直接返回结果给用户，如果没有命中，查询数据库，结果写入LocalCache，最后结果返回给用户。</code></p>
<p><strong>一级缓存配置</strong></p>
<p><code>我们来看看如何使用MyBatis一级缓存。开发者只需在MyBatis的配置文件中，添加如下语句，就可以使用一级缓存。共有两个选项，</code>SESSION<code>或者</code>STATEMENT<code>，默认是</code>SESSION<code>级别，即在一个MyBatis会话中执行的所有语句，都会共享这一个缓存。一种是</code>STATEMENT<code>级别，可以理解为缓存只对当前执行的这一个</code>Statement<code>有效。</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"localCacheScope"</span> <span class="attr">value</span>=<span class="string">"SESSION"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>一级缓存总结</strong></p>
<ul>
<li>Mybatis的生命周期和SqlSession一致</li>
<li>Mybatis一级缓存内部设计简单，只是一个没有容量限制的HashMap，在缓存设计上有所欠缺</li>
<li>Mybatis一级缓存最大范围是SqlSession内部，有多个SqlSession或者分布式的环境下，数据读写会引起脏数据，建议设定缓存级别为statement</li>
</ul>
<p><strong>二级缓存</strong></p>
<p>如果多个SqlSession之间需要共享缓存，就需要使用二级缓存。开启二级缓存，会使用CachingExecutor，进入到一级缓存查询的流程前，先在CachingExecutor进行二级缓存的查询。</p>
<p>二级缓存开启后，同一个namespace下所有的查询操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享，是一个全局变量。当开启缓存后，数据库的查询流程就是 二级缓存 -&gt; 一级缓存 -&gt; 数据库</p>
<p><strong>二级缓存配置</strong></p>
<ul>
<li>在MyBatis的配置文件中开启二级缓存。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>在MyBatis的映射XML中配置cache或者 cache-ref 。</p>
<p>cache标签用于声明这个namespace使用二级缓存，并且可以自定义配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>type</code>：cache使用的类型，默认是<code>PerpetualCache</code>，这在一级缓存中提到过。</li>
<li><code>eviction</code>： 定义回收的策略，常见的有FIFO，LRU。</li>
<li><code>flushInterval</code>： 配置一定时间自动刷新缓存，单位是毫秒。</li>
<li><code>size</code>： 最多缓存对象的个数。</li>
<li><code>readOnly</code>： 是否只读，若配置可读写，则需要对应的实体类能够序列化。</li>
<li><code>blocking</code>： 若缓存中找不到对应的key，是否会一直blocking，直到有对应的数据进入缓存。</li>
</ul>
<p><code>cache-ref</code>代表引用别的命名空间的Cache配置，两个命名空间的操作使用的是同一个Cache。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache-ref</span> <span class="attr">namespace</span>=<span class="string">"mapper.StudentMapper"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>二级缓存总结</strong></p>
<ul>
<li>MyBatis的二级缓存相对于一级缓存来说，实现了<code>SqlSession</code>之间缓存数据的共享，同时粒度更加的细，能够到<code>namespace</code>级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。</li>
<li>Mybatis在多表查询时，极大可能出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻</li>
<li>在分布式缓存下，由于默认的Mybatis Cache实现都是基于本地的，分布式环境下必然会出现脏数据，需要使用集中式缓存将Mybatis的Cache接口实现，有一定的开发成本，直接使用redis、Memcached等分布式缓存可能成本更低、安全性更高</li>
</ul>
<p><a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/01/19/mybatis-cache.html</a></p>
</li>
<li><p>Mybatis如何配置动态的sql?有哪些动态Sql标签？</p>
<p><if test="">…</if> 、<set> 、<where>、<trim></p>
</li>
</ol>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="考查点-3"><a href="#考查点-3" class="headerlink" title="考查点"></a>考查点</h4><ol>
<li>了解缓存使用场景，不同类型缓存的使用方式</li>
<li>掌握redis常用命令</li>
<li>了解redis在内存中的存储结构</li>
<li>了解redis的数据失效方式和剔除策略</li>
<li>了解redis的持久化、主从同步与cluster部署的原理</li>
</ol>
<h4 id="加分项-3"><a href="#加分项-3" class="headerlink" title="加分项"></a>加分项</h4><ol>
<li><p>结合实际应用场景来介绍缓存的使用</p>
</li>
<li><p>有用过分布式缓存设计和应用经验</p>
</li>
<li><p>了解缓存使用中可能产生的问题</p>
</li>
<li><p>知道redis典型的应用场景</p>
<p>排行榜、计数器、发布/订阅</p>
</li>
<li><p>知道redis的新特性</p>
</li>
</ol>
<h4 id="真题汇总-5"><a href="#真题汇总-5" class="headerlink" title="真题汇总"></a>真题汇总</h4><ol>
<li><p><strong>redis</strong>和<strong>memcached</strong>有什么区别？该如何使用？</p>
<ul>
<li><p>存储方式不同,memcache把所有数据存在内存中，数据不能超过内存大小，断电后数据会挂掉；</p>
</li>
<li><p>Redis有部分会存放在硬盘中，这样能保证数据的持久性；</p>
</li>
<li><p>数据支持类型不同 memcache对数据类型支持相对简单,redis有复杂的数据类型；</p>
</li>
<li><p>使用低层模型不同，他们之间底层的实现方式、以及客户端之间的通讯的应用协议不同。redis</p>
<p> 直接自己构建了VM机制，因为一般的系统调系统函数的话，会浪费一定的时间去移动和请求；</p>
</li>
<li><p>支持的value大小不一样 redis最大可以达到1GB，而memcache只有1MB；</p>
</li>
</ul>
<p><strong>Redis使用场景</strong></p>
<p>(1)、会话缓存（Session Cache）</p>
<p>(2)、全页缓存（FPC）</p>
<p>(3)、队列</p>
<p>(4)、排行榜、计数器</p>
<p>(5)、发布、订阅</p>
<p><a href="https://uule.iteye.com/blog/2429643" target="_blank" rel="noopener">https://uule.iteye.com/blog/2429643</a></p>
<p><a href="https://www.cnblogs.com/aspirant/p/8883871.html" target="_blank" rel="noopener">https://www.cnblogs.com/aspirant/p/8883871.html</a></p>
</li>
<li><p>你用过那些redis的数据结构？用在什么场景下？</p>
<p><a href="http://www.texixi.com/2016/04/27/Redis-%E8%BF%90%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">http://www.texixi.com/2016/04/27/Redis-%E8%BF%90%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E4%BB%8B%E7%BB%8D/</a></p>
</li>
<li><p>redis有那些持久化方式？区别是什么？</p>
<p><strong>持久化方式</strong></p>
<ul>
<li>RDB持久化能够在指定的时间间隔对你的数据进行快照存储</li>
<li>AOF持久化方式记录每次对服务器写的操作，当服务器重新启动的时候会重新执行这些命令来恢复原始的数据，AOF命令以redis协议追加保存每次写的操作到文件末尾</li>
</ul>
<p><strong>RDB的原理</strong></p>
<p><code>在Redis中RDB持久化的触发分为两种：自己手动触发和Redis定时触发</code></p>
<p>针对RDB方式的持久化，手动触发可以使用：</p>
<ul>
<li>save:会阻塞当前Redis服务器，直到持久化完成，线上应该禁止使用。</li>
<li>bgsave:该触发方式会fork一个子进程，由子进程负责持久化，因此阻塞只会发生在fork子进程的时候</li>
</ul>
<p>自动触发的场景有以下几点：</p>
<ul>
<li>根据我们的save m n 配置规则自动触发；</li>
<li>从节点全量复制时，主节点发送rdb文件给从节点完成复制操作，主节点触发bgsave；</li>
<li>执行debug reload时；</li>
<li>执行 <code>shutdown</code>时，如果没有开启aof，也会触发；</li>
</ul>
<p>由于 <code>save</code> 基本不会被使用到，我们重点看看 <code>bgsave</code> 这个命令是如何完成RDB的持久化的。</p>
<p><img src="D:%5Ctools%5Cwork%5C%E5%85%B6%E4%BB%96%5C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%5Cimages%5CRDB.png" alt=""></p>
<p><code>这里注意的是</code>fork<code>操作会阻塞，导致Redis读写性能下降。我们可以控制单个Redis实例的最大内存，来尽可能降低Redis在fork时的事件消耗。以及上面提到的自动触发的频率减少fork次数，或者使用手动触发，根据自己的机制来完成持久化。</code></p>
<p><strong>AOF的原理</strong></p>
<p>AOP的整体流程大体来看可以分为两步，一步是命令的实时写入(如果是appendfsync everysec配置，会有1s损耗)，第二步是对aof文件的重写。</p>
<p>对于增量追加到文件这一步的主要流程：命令写入=》追加到aof_buf=》同步到aof磁盘。那么这里为啥要先写入Buf同步到磁盘呢？如果实时写入磁盘会带来非常高的磁盘IO，影响整体性能。</p>
<p>AOF重写是为了减少aof文件大小，可以手动或者自动触发，关于自动触发的规则请看上面配置部分。fork的操作也是发生在重写这一步，也是这里会对主进程产生阻塞。</p>
<p><strong>手动触发：</strong><code>bgrewriteaof</code>，<strong>自动触发</strong> 就是根据配置规则来触发，当然自动触发的整体时间还跟Redis的定时任务频率有关系。</p>
<p><img src="D:%5Ctools%5Cwork%5C%E5%85%B6%E4%BB%96%5C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%5Cimages%5CAOF%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt=""></p>
<p>对于上图有四个关键点补充一下：</p>
<ol>
<li>在重写期间，由于主进程依然在响应命令，为了保证最终备份的完整性；因此它依然会写入旧的AOF file中，如果重写失败，能够保证数据不丢失。</li>
<li>为了把重写期间响应的写入信息也写入到新的文件中，因此也会为子进程保留一个buf，防止新写的file丢失数据。</li>
<li>重写是直接把当前内存的数据生成对应命令，并不需要读取老的AOF文件进行分析、命令合并。</li>
<li>AOF文件直接采用的文本协议，主要是兼容性好、追加方便、可读性高可认为修改修复。</li>
</ol>
<p><code>不管是RDB还是AOF都是先写入一个临时文件，然后通过</code>rename<code>完成文件的替换工作。</code></p>
<p><strong>区别：</strong></p>
<p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p>
<p>AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式追加记录，可以打开文件看到详细的操作记录。</p>
<p><a href="https://www.liangzl.com/get-article-detail-97255.html" target="_blank" rel="noopener">https://www.liangzl.com/get-article-detail-97255.html</a></p>
<p><a href="https://segmentfault.com/a/1190000015983518" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015983518</a></p>
<p><a href="https://segmentfault.com/a/1190000004491106" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004491106</a></p>
</li>
<li><p>redis过期策略是怎么样？redis有那些淘汰机制？</p>
<p><strong>过期策略：</strong>因为redis是基于内存来进行高可用、高并发的读写操作，既然是内存，那肯定有空间限制，如果只有10G内存，你一直往里面写数据，那肯定不行，所以就会采用一些过期策略把不需要的数据删除、或者淘汰掉。</p>
<p><strong>有哪些过期策略：</strong>定期删除、惰性删除</p>
<p>定期删除实现：所谓定期删除，指的是redis默认每隔100ms就随机抽取一些设置了过期时间的key，检查是否过期，如果过期就删除。</p>
<p><strong>为什么随机抽取？</strong></p>
<p>假如在redis里面插入了10w个key，并且都设置了过期时间，如果每次都检查所有的key，那cpu基本上消耗来在过期key的检查上，redis对外的性能也会大大的降低，简直就是一场灾难。</p>
<p><strong>随机检查会存在什么问题？</strong></p>
<p>可能会导致已经过期的Key没有被扫描到，而继续留在空间中，并占用空间，等待被删除。</p>
<p><strong>这种情况怎么解决？</strong></p>
<p>这时候就需要惰性删除了，就是在获取某个Key的时候，Redis会检查一下，如果这个Key设置了过期时间，并且已经过期了，那么就直接删除，返回空。</p>
<p><strong>如果大量的key没有被扫描到，且已过期，也没有被再次访问，即没有走惰性删除，这些大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，这种情况下，怎么办？</strong></p>
<p>Redis内部提供了内存淘汰机制，应该有好几种策略，但是我只知道LRU算法。</p>
<p><strong>redis淘汰机制：</strong></p>
<ul>
<li>noevication: 返回错误当内存限制达到并且客户端尝试执行让更多内存被使用的命令</li>
<li>allkeys-lru:尝试回收最少使用的键(LRU)，使得新添加的数据有空间存放</li>
<li>volatile-lru:尝试回收最少使用的键(LRU)，但仅限于在过期集合的键，使得新添加的数据有空间存放</li>
<li>allkeys-random: 回收随机的键使得新添加的数据有空间存放</li>
<li>volatile-random:回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键</li>
<li>volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放</li>
</ul>
<p><strong>手写LRU算法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cacheSize 缓存大小</span></span><br><span class="line"><span class="comment">     * true 表示让 linkedHashMap 按照访问顺序来进行排序，</span></span><br><span class="line"><span class="comment">     * 最近访问的放在头部，最老访问的放在尾部。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> cacheSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((<span class="keyword">int</span>) Math.ceil(cacheSize/<span class="number">0.75</span>)+<span class="number">1</span>,<span class="number">0.75f</span>,<span class="keyword">true</span>);</span><br><span class="line">        CACHE_SIZE = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当 map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size()&gt;CACHE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何保证redis高可用和高并发？</p>
</li>
<li><p>如何使用redis实现延时队列？如何使用redis实现分布式锁？</p>
<p><strong>延时队列</strong></p>
<p><strong>分布式锁</strong></p>
<p><a href="https://segmentfault.com/a/1190000012919740" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012919740</a></p>
</li>
<li><p>美团针对Redis Rehash机制的探索和事件</p>
</li>
</ol>
<p><a href="https://tech.meituan.com/2018/07/27/redis-rehash-practice-optimization.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/07/27/redis-rehash-practice-optimization.html</a></p>
<ol start="8">
<li>Redis高负载下的中断优化</li>
</ol>
<p><a href="https://tech.meituan.com/2018/03/16/redis-high-concurrency-optimization.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/03/16/redis-high-concurrency-optimization.html</a></p>
<ol start="8">
<li>美团缓存那些事</li>
</ol>
<p><a href="https://tech.meituan.com/2017/03/17/cache-about.html" target="_blank" rel="noopener">https://tech.meituan.com/2017/03/17/cache-about.html</a></p>
<h3 id="消息队列和数据库"><a href="#消息队列和数据库" class="headerlink" title="消息队列和数据库"></a>消息队列和数据库</h3><h4 id="考查点-4"><a href="#考查点-4" class="headerlink" title="考查点"></a>考查点</h4><ol>
<li>了解消息队列、数据库的基本原理和常用队列、数据库的特点</li>
<li>了解Kafka的架构和消息处理流程</li>
<li>理解数据库事务的ACID特性和隔离级别</li>
<li>掌握常用的Mysql语句和函数</li>
<li>了解Mysql数据库不同引擎的特点以 及不同类型的索引实现</li>
</ol>
<h4 id="加分项-4"><a href="#加分项-4" class="headerlink" title="加分项"></a>加分项</h4><ol>
<li>了解新特性</li>
<li>知道数据调优经验</li>
<li>消息队列使用经验，不同场景下的取舍</li>
</ol>
<h4 id="真题汇总-6"><a href="#真题汇总-6" class="headerlink" title="真题汇总"></a>真题汇总</h4><ol>
<li><p>使用过消息队列吗？在什么场景下使用的？用来解决什么问题？</p>
</li>
<li><p>使用队列时如何保证可靠性？</p>
</li>
<li><p>MQ有可能发生重复消费吗？如何解决？</p>
</li>
<li><p>在数据库查询慢，如何优化？</p>
<p><strong>同6小节</strong></p>
</li>
<li><p>数据库事务有哪些特性？事务的隔离级别有哪几种？</p>
</li>
</ol>
<p><strong>事务特性：</strong></p>
<ul>
<li>原子性：一个事务必须视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。</li>
<li>一致性：数据库总数从一个一致性的状态转换到另一个一致性的状态</li>
<li>隔离性：一个事务所做的修改在最终提交以前，对其他事务是不可见的</li>
<li>持久性：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失</li>
</ul>
<p><strong>隔离级别：</strong></p>
<table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交（read-uncommitted）</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>不可重复读（read-committed）</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读（repeatable-read）</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<p>链接：<a href="https://blog.csdn.net/csdnxingyuntian/article/details/57081233" target="_blank" rel="noopener">https://blog.csdn.net/csdnxingyuntian/article/details/57081233</a></p>
<ol start="6">
<li>如何对sql语句进行优化？</li>
</ol>
<p><strong>优化方案</strong></p>
<ul>
<li>对查询进行优化，应尽量避免全表扫描，首先应考虑在where以及order by涉及的列上建议索引</li>
<li>应尽量避免在where子句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num is null</span><br></pre></td></tr></table></figure>

<p>  可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num&#x3D;0</span><br></pre></td></tr></table></figure>

<ul>
<li>应尽量避免在where使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</li>
<li>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num&#x3D;10 or num&#x3D;20</span><br></pre></td></tr></table></figure>

<ul>
<li>in 和 not in 也要慎用，否则会导致全表扫描</li>
<li>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</li>
<li>任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段</li>
<li>尽量的使用 varchar 代替 char ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些</li>
<li>避免频繁创建和删除临时表，以减少系统表资源的消耗</li>
<li>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销</li>
</ul>
<ol start="7">
<li>消息队列设计精要？</li>
</ol>
<p>​    <a href="https://tech.meituan.com/2016/07/01/mq-design.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/07/01/mq-design.html</a></p>
<ol start="8">
<li>Mysql索引原理以及慢查询优化</li>
</ol>
<p><a href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/06/30/mysql-index.html</a></p>
<ol start="9">
<li>Kafka文件存储机制那些事</li>
</ol>
<p><a href="https://tech.meituan.com/2015/01/13/kafka-fs-design-theory.html" target="_blank" rel="noopener">https://tech.meituan.com/2015/01/13/kafka-fs-design-theory.html</a></p>
<h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><h4 id="真题汇总-7"><a href="#真题汇总-7" class="headerlink" title="真题汇总"></a>真题汇总</h4><ol>
<li>Docker入门系列一：入门介绍</li>
</ol>
<p><a href="https://tech.meituan.com/2015/01/27/docker-introduction.html" target="_blank" rel="noopener">https://tech.meituan.com/2015/01/27/docker-introduction.html</a></p>
<ol start="2">
<li>Docker系列二：基于容器的自动构建</li>
</ol>
<p><a href="https://tech.meituan.com/2015/03/10/auto-build.html" target="_blank" rel="noopener">https://tech.meituan.com/2015/03/10/auto-build.html</a></p>
<ol start="3">
<li>微服务面试题</li>
</ol>
<p><a href="https://www.csrcrx.com/news/newsdetail-4817.html" target="_blank" rel="noopener">https://www.csrcrx.com/news/newsdetail-4817.html</a> （阿里面试题）</p>
<p><a href="http://www.pianshen.com/article/4093204511/" target="_blank" rel="noopener">http://www.pianshen.com/article/4093204511/</a></p>
<p><a href="https://my.oschina.net/u/3728166/blog/2961379" target="_blank" rel="noopener">https://my.oschina.net/u/3728166/blog/2961379</a></p>
<p><a href="http://www.3da4.com/thread-4948-1-1.html" target="_blank" rel="noopener">http://www.3da4.com/thread-4948-1-1.html</a></p>
<p><a href="https://www.cnblogs.com/kkdn/p/9074362.html" target="_blank" rel="noopener">https://www.cnblogs.com/kkdn/p/9074362.html</a></p>
<p><a href="https://blog.csdn.net/xjpdf10/article/details/82863397" target="_blank" rel="noopener">https://blog.csdn.net/xjpdf10/article/details/82863397</a></p>
<p><a href="https://www.liangzl.com/get-article-detail-19387.html" target="_blank" rel="noopener">https://www.liangzl.com/get-article-detail-19387.html</a></p>
<p><a href="https://segmentfault.com/a/1190000014766251?utm_source=tag-newest（Spring面试题）" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014766251?utm_source=tag-newest（Spring面试题）</a></p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1558454697660.png" alt="1558454697660"></p>
<h3 id="架构演进"><a href="#架构演进" class="headerlink" title="架构演进"></a>架构演进</h3><h4 id="考察点-1"><a href="#考察点-1" class="headerlink" title="考察点"></a>考察点</h4><ol>
<li>分布式架构的理解</li>
<li>了解系统优化的解决方法</li>
<li>对工作的熟悉程度</li>
</ol>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol>
<li>交代背景：Star法则</li>
<li>描述架构： 架构图交互流程</li>
<li>做了什么：重点突出</li>
<li>结果如何：用实例佐证</li>
<li>如何改进：存在的问题和解决方法</li>
<li>美团数据库高可用架构演讲与设想</li>
</ol>
<p><a href="https://tech.meituan.com/2017/06/29/database-availability-architecture.html" target="_blank" rel="noopener">https://tech.meituan.com/2017/06/29/database-availability-architecture.html</a></p>
<h3 id="HR面试"><a href="#HR面试" class="headerlink" title="HR面试"></a>HR面试</h3><ol>
<li><p>准备自我介绍？介绍内容要与简历一致</p>
</li>
<li><p>有什么业务爱好？不要只说自己爱读书、听音乐上网</p>
</li>
<li><p>谈谈你的缺点？不宜说出令人不放心、不舒服的缺点。不宜把那些明显的优点说成缺点。 </p>
<p><strong>我觉得我最近一年有一个缺点是我当小组长让我意识到自己的不足，我什么事情都不放心，都想亲力亲为，最后就导致自己的工作效率变低 了不少。我觉得自己应该放开手，既然是一个团队的，就应该相信他们可以把事情做好。如果真做的不对，可以再去帮助或者指导。</strong></p>
</li>
<li><p>与上级意见不一是，你将怎么办?</p>
<p><strong>我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。</strong></p>
</li>
<li><p>您在前一家公司的离职原因是什么?</p>
</li>
</ol>
<p>避免把”离职原因”说得太详细、太具体。也不能躲闪、回避，如”想换换环境”、”个人原因”等</p>
<p><a href="https://segmentfault.com/a/1190000018951978" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018951978</a></p>
<p><strong>写个程序猿的十条精进原则：</strong></p>
<p><a href="https://tech.meituan.com/2018/08/16/10-principles-for-engineers.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/08/16/10-principles-for-engineers.html</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://www.sumulige.com/2020/03/06/java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%80%EF%BC%89/" data-id="ck7f6mfkw0014ebtlaqdh6ev0" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASYAAAEmCAAAAADqr2IGAAAEi0lEQVR42u3aS27bQBAFQN//0s42QWL6vW4q0NDFlUGL5LAkoH/z8REfn38dv5//+5PJHa6vTT7frvx6hTccmDBhwoTpLZk+L4/9y19DXHNff37Gmlz1j2sxYcKECdPhTO3tZkE3f1bON1ttvU5MmDBhwvRjmK6Xm5SXeRl8naAkuPlVmDBhwoQJUxtu26D+f9rTmDBhwoTpZzLlAThvjOaDzzzw78+/vBeOCRMmTJjejCkPq8/7+yXZByZMmDBhehumz8XRNn+TpvCsNM036wzfFBMmTJgwHcs0GwQmo8S7AnPehG2f245IMWHChAnTiUz5CyeB9hUDxaQtuzkfvSkmTJgwYTqcKcoaRuH5FZtsZqPK/ClRxoQJEyZMmI5iSsL5XcH1rq05+ylkfhUmTJgwYTqdKWm/5uEzX1ZbrLaN4LYp/OV5TJgwYcJ0LNNmTJg3bVvW9qvKC+a2uYwJEyZMmE5nmgXvdhSahO1Zgd3eedYUxoQJEyZM5zLNxn53JQH5a+Rt2bbALpIGTJgwYcJ0INNsWLhpy+Zbf2ZJQJKUtK1qTJgwYcL0DKb2BdpkIi+YZ3doi+Qi0cGECRMmTMcybYrV1w012401myFomwxhwoQJE6azmGbt0SQ5aMei7deWHDnZN81lTJgwYcJ0LNO9u1PabUB5tN00hTdpStHnxoQJEyZMhzDNxpZ3bZppC+/ZV5ukC6tfFiZMmDBhehummd8NQXRRyiavt1/bx/5nhgkTJkyY3oBpFv7vWtzsWe3mnruuwoQJEyZMz2CaFZ/tVe3mm3uP1XMxYcKECdOBTPmLJcF7FviT87Nw3m7fwYQJEyZMT2KatWvv2vp5b2s4T2g+9o/EhAkTJkyHMCW3a4vVe9OFtuSepQjRDwUTJkyYMB3LVAzz4ibprKxNXvuu1GdYDGPChAkTpgOZ2i04s8I1D8azIjZJXJIvABMmTJgwPY8pLzvzUnmWauSJxWy0eUObGxMmTJgwHcXUPmBWxOalbJIQbMr1NrHAhAkTJkzPYNpsi2lHoRvitkWbJy7frBMTJkyYMB3L9LptNO2Ac1Oszgarw6kvJkyYMGE6iim5LH+xtuDMv722IK9/HdcJBCZMmDBhOpbprpK1DdJ54ToL8/uBa1R/Y8KECROmt2fat1bzQN6Wqa8eeSatYUyYMGHC9DymTcu1HR/mV7Wjx9nKi4QAEyZMmDAdyHT90dk2l7uarbPtQcl/o3QHEyZMmDA9gmnz4HxBs+A9OzYD1z/OY8KECROmY5na4WK7xE1ITmJxOzTdPBETJkyYMJ3I9FkesxbqJsloG7t58VysARMmTJgwHcu0KSPzVmxeAM+SgDaV2SQ6mDBhwoTpRKY2CZgVonmztb1DO0wdNqkxYcKECdPhTJsAnCx31njdN21nz/qy1YsJEyZMmB7NNNsKk6Mnr7RpSefv+I+VYMKECROmH8CUFJYt3Gy0mQf7duz65VWYMGHChOlwpnZjzab0fV0bN09i2r8xYcKECdO5TJsmabtRpt24Mwv/7T6cTfsYEyZMmDC9MdMvt1sayx0o9CMAAAAASUVORK5CYII=">分享</a><div class="tags"><a href="/tags/java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/">java常见面试题及答案</a></div><div class="post-nav"><a class="pre" href="/2020/03/06/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%9D%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89/">vue学习笔记-初识（一）</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'true' ? true : false;
var verify = 'true' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'ivpEhNzW7MXaOpXrMfU90jjq-gzGzoHsz',
  appKey:'65olvYK78WGdFMmAWd49Bo5A',
  placeholder:'Just so so',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/hazel/" style="font-size: 15px;">hazel</a> <a href="/tags/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 15px;">java学习笔记</a> <a href="/tags/java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/" style="font-size: 15px;">java常见面试题及答案</a> <a href="/tags/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 15px;">vue学习笔记</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/hazel%E8%83%BD%E4%B8%BA%E6%88%91%E4%BB%AC%E5%81%9A%E4%BB%80%E4%B9%88/">hazel能为我们做什么</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91(AVL)%E3%80%81%E7%BA%A2%E9%BB%91%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%8D%81%EF%BC%89/">java学习笔记-二叉树、平衡二叉树(AVL)、红黑二叉树（十）</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2%EF%BC%88%E4%B8%80%EF%BC%89/">java学习笔记-写在前面（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2%EF%BC%88%E4%BA%8C%EF%BC%89/">java学习笔记-写在前面（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-IO%EF%BC%88%E5%85%AD%EF%BC%89/">java学习笔记-IO（六）</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89/">java学习笔记-基础算法（七）</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/">java学习笔记-多线程（十一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%B8%B8%E7%94%A8%E7%B1%BB%EF%BC%88%E5%9B%9B%EF%BC%89/">java学习笔记-常用类（四）</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%9B%86%E5%90%88%EF%BC%88%E4%BA%94%EF%BC%89/">java学习笔记-集合（五）</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84%EF%BC%88%E4%B8%89%EF%BC%89/">java学习笔记-数组（三）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">sumulige.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>